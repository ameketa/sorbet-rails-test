# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `inherited_resources` gem.
# Please instead update this file by running `bin/tapioca gem inherited_resources`.

module InheritedResources
  class << self
    # Change the flash keys used by FlashResponder.
    def flash_keys=(array); end
  end
end

InheritedResources::ACTIONS = T.let(T.unsafe(nil), Array)

# Holds all default actions for InheritedResouces.
module InheritedResources::Actions
  # POST /resources
  def create(options = T.unsafe(nil), &block); end

  # DELETE /resources/1
  def destroy(options = T.unsafe(nil), &block); end

  # GET /resources/1/edit
  def edit(options = T.unsafe(nil), &block); end

  # GET /resources
  def index(options = T.unsafe(nil), &block); end

  # GET /resources/new
  def new(options = T.unsafe(nil), &block); end

  # GET /resources/1
  def show(options = T.unsafe(nil), &block); end

  # PUT /resources/1
  def update(options = T.unsafe(nil), &block); end

  protected

  # POST /resources
  def create!(options = T.unsafe(nil), &block); end

  # DELETE /resources/1
  def destroy!(options = T.unsafe(nil), &block); end

  # GET /resources/1/edit
  def edit!(options = T.unsafe(nil), &block); end

  # GET /resources
  def index!(options = T.unsafe(nil), &block); end

  # GET /resources/new
  def new!(options = T.unsafe(nil), &block); end

  # GET /resources/1
  def show!(options = T.unsafe(nil), &block); end

  # PUT /resources/1
  def update!(options = T.unsafe(nil), &block); end
end

# Base helpers for InheritedResource work. Some methods here can be overwritten
# and you will need to do that to customize your controllers from time to time.
module InheritedResources::BaseHelpers
  protected

  # Returns the association chain, with all parents (does not include the
  # current resource).
  def association_chain; end

  # This class allows you to set a instance variable to begin your
  # association chain. For example, usually your projects belongs to users
  # and that means that they belong to the current logged in user. So you
  # could do this:
  #
  #   def begin_of_association_chain
  #     @current_user
  #   end
  #
  # So every time we instantiate a project, we will do:
  #
  #   @current_user.projects.build(params[:project])
  #   @current_user.projects.find(params[:id])
  #
  # The variable set in begin_of_association_chain is not sent when building
  # urls, so this is never going to happen when calling resource_url:
  #
  #   project_url(@current_user, @project)
  #
  # If the user actually scopes the url, you should use belongs_to method
  # and declare that projects belong to user.
  def begin_of_association_chain; end

  # This method is responsible for building the object on :new and :create
  # methods. If you overwrite it, don't forget to cache the result in an
  # instance variable.
  def build_resource; end

  # This is how the collection is loaded.
  #
  # You might want to overwrite this method if you want to add pagination
  # for example. When you do that, don't forget to cache the result in an
  # instance_variable:
  #
  #   def collection
  #     @projects ||= end_of_association_chain.paginate(params[:page]).all
  #   end
  def collection; end

  # Responsible for saving the resource on :create method. Overwriting this
  # allow you to control the way resource is saved. Let's say you have a
  # PassworsController who is responsible for finding an user by email and
  # sent password instructions for him. Instead of overwriting the entire
  # :create method, you could do something:
  #
  #   def create_resource(object)
  #     object.send_instructions_by_email
  #   end
  def create_resource(object); end

  # Handle the :destroy method for the resource. Overwrite it to call your
  # own method for destroying the resource, as:
  #
  #   def destroy_resource(object)
  #     object.cancel
  #   end
  def destroy_resource(object); end

  # Returns if the controller has a parent. When only base helpers are loaded,
  # it's always false and should not be overwritten.
  #
  # @return [Boolean]
  def parent?; end

  # This is how the resource is loaded.
  #
  # You might want to overwrite this method when you are using permalink.
  # When you do that, don't forget to cache the result in an
  # instance_variable:
  #
  #   def resource
  #     @project ||= end_of_association_chain.find_by_permalink!(params[:id])
  #   end
  #
  # You also might want to add the exclamation mark at the end of the method
  # because it will raise a 404 if nothing can be found. Otherwise it will
  # probably render a 500 error message.
  def resource; end

  # Responsible for updating the resource in :update method. This allow you
  # to handle how the resource is going to be updated, let's say in a different
  # way than the usual :update:
  #
  #   def update_resource(object, attributes)
  #     object.reset_password!(attributes)
  #   end
  def update_resource(object, attributes); end

  private

  # Hook to apply scopes. By default returns only the target_object given.
  # It's extend by HasScopeHelpers.
  def apply_scopes_if_available(target_object); end

  # getting role for mass-asignment
  def as_role; end

  # extract attributes from params
  def build_resource_params; end

  # This methods gets your begin_of_association_chain, join it with your
  # parents chain and returns the scoped association.
  def end_of_association_chain; end

  # Get collection ivar based on the current resource controller.
  def get_collection_ivar; end

  # Get resource ivar based on the current resource controller.
  def get_resource_ivar; end

  # Returns the name of the method used for building the resource in cases
  # where we have a parent. This is overwritten in singleton scenarios.
  def method_for_association_build; end

  # Returns the name of the method to be called, before returning the end
  # of the association chain. This is overwritten by singleton cases
  # where no method for association chain is called.
  def method_for_association_chain; end

  # Returns the appropriated method to build the resource.
  def method_for_build; end

  # Returns finder method for instantiate resource by params[:id]
  def method_for_find; end

  # Returns hash of sanitized params in a form like
  # `{:project => {:project_attribute => 'value'}}`
  #
  # This method makes use of `project_params` (or `smth_else_params`) which
  # is a default Rails controller method for strong parameters definition.
  #
  # `permitted_params` is usually fired by method :new, :create, :update
  # actions. Action :new usually has no parameters so strong parameters
  # `require` directive raises a +ActionController::ParameterMissing+
  # exception. `#permitted_params` rescues such exceptions in :new and
  # returns an empty hash of parameters (which is reasonable default).
  # If for any reasons you need something more specific, you can redefine
  # this method in a way previous `inherited_resources` versions did:
  #
  #    # Unnecessary redefinition
  #    def permitted_params
  #      params.permit(:project => [:project_attribute])
  #    end
  def permitted_params; end

  # Fast accessor to resource_collection_name
  def resource_collection_name; end

  # Fast accessor to resource_instance_name
  def resource_instance_name; end

  # memoize the extraction of attributes from params
  def resource_params; end

  def resource_params_method_name; end
  def resource_request_name; end

  # Used to allow to specify success and failure within just one block:
  #
  #   def create
  #     create! do |success, failure|
  #       failure.html { redirect_to root_url }
  #     end
  #   end
  #
  # It also calculates the response url in case a block without arity is
  # given and returns it. Otherwise returns nil.
  def respond_with_dual_blocks(object, options, &block); end

  # checking if role given
  #
  # @return [Boolean]
  def role_given?; end

  # Set collection ivar based on the current resource controller.
  def set_collection_ivar(collection); end

  # Set resource ivar based on the current resource controller.
  def set_resource_ivar(resource); end

  # URL to redirect to when redirect implies collection url.
  def smart_collection_url; end

  # URL to redirect to when redirect implies resource url.
  def smart_resource_url; end

  # Symbols chain in base helpers return nothing. This is later overwritten
  # by belongs_to and can be complex in polymorphic cases.
  def symbols_for_association_chain; end

  # Adds the given object to association chain.
  def with_chain(object); end

  def without_protection; end

  # @return [Boolean]
  def without_protection_given?; end
end

# = belongs_to
#
# Let's suppose that we have some tasks that belongs to projects. To specify
# this assoication in your controllers, just do:
#
#    class TasksController < InheritedResources::Base
#      belongs_to :project
#    end
#
# belongs_to accepts several options to be able to configure the association.
# For example, if you want urls like /projects/:project_title/tasks, you
# can customize how InheritedResources find your projects:
#
#    class TasksController < InheritedResources::Base
#      belongs_to :project, :finder => :find_by_title!, :param => :project_title
#    end
#
# It also accepts :route_name, :parent_class and :instance_name as options.
# Check the lib/inherited_resources/class_methods.rb for more.
#
# = nested_belongs_to
#
# Now, our Tasks get some Comments and you need to nest even deeper. Good
# practices says that you should never nest more than two resources, but sometimes
# you have to for security reasons. So this is an example of how you can do it:
#
#    class CommentsController < InheritedResources::Base
#      nested_belongs_to :project, :task
#    end
#
# If you need to configure any of these belongs to, you can nested them using blocks:
#
#    class CommentsController < InheritedResources::Base
#      belongs_to :project, :finder => :find_by_title!, :param => :project_title do
#        belongs_to :task
#      end
#    end
#
# Warning: calling several belongs_to is the same as nesting them:
#
#    class CommentsController < InheritedResources::Base
#      belongs_to :project
#      belongs_to :task
#    end
#
# In other words, the code above is the same as calling nested_belongs_to.
module InheritedResources::BelongsToHelpers
  protected

  def parent; end

  # Parent is always true when belongs_to is called.
  #
  # @return [Boolean]
  def parent?; end

  def parent_type; end

  private

  # Evaluate the parent given. This is used to nest parents in the
  # association chain.
  def evaluate_parent(parent_symbol, parent_config, chain = T.unsafe(nil)); end

  def get_parent_ivar(instance_name); end
  def set_parent_instance(parent_config, chain); end

  # Maps parents_symbols to build association chain. In this case, it
  # simply return the parent_symbols, however on polymorphic belongs to,
  # it has some customization.
  def symbols_for_association_chain; end
end

# An object from BlankSlate simply discards all messages sent to it.
class InheritedResources::BlankSlate
  def method_missing(*args); end
end

module InheritedResources::ClassMethods
  protected

  # Defines wich actions will be inherited from the inherited controller.
  # Syntax is borrowed from resource_controller.
  #
  #   actions :index, :show, :edit
  #   actions :all, :except => :index
  #
  # @raise [ArgumentError]
  def actions(*actions_to_keep); end

  # Defines that this controller belongs to another resource.
  #
  #   belongs_to :projects
  #
  # == Options
  #
  # * <tt>:parent_class</tt> - Allows you to specify what is the parent class.
  #
  #     belongs_to :project, :parent_class => AdminProject
  #
  # * <tt>:class_name</tt> - Also allows you to specify the parent class, but you should
  #                          give a string. Added for ActiveRecord belongs to compatibility.
  #
  # * <tt>:instance_name</tt> - The instance variable name. By default is the name of the association.
  #
  #     belongs_to :project, :instance_name => :my_project
  #
  # * <tt>:finder</tt> - Specifies which method should be called to instantiate the parent.
  #
  #     belongs_to :project, :finder => :find_by_title!
  #
  #   This will make your projects be instantiated as:
  #
  #     Project.find_by_title!(params[:project_id])
  #
  #   Instead of:
  #
  #     Project.find(params[:project_id])
  #
  # * <tt>:param</tt> - Allows you to specify params key to retrieve the id.
  #                     Default is :association_id, which in this case is :project_id.
  #
  # * <tt>:route_name</tt> - Allows you to specify what is the route name in your url
  #                          helper. By default is association name.
  #
  # * <tt>:collection_name</tt> - Tell how to retrieve the next collection. Let's
  #                               suppose you have Tasks which belongs to Projects
  #                               which belongs to companies. This will do somewhere
  #                               down the road:
  #
  #      @company.projects
  #
  #   But if you want to retrieve instead:
  #
  #      @company.admin_projects
  #
  #   You supply the collection name.
  #
  # * <tt>:polymorphic</tt> - Tell the association is polymorphic.
  #
  # * <tt>:singleton</tt> - Tell it's a singleton association.
  #
  # * <tt>:optional</tt> - Tell the association is optional (it's a special
  #                        type of polymorphic association)
  #
  # @raise [ArgumentError]
  def belongs_to(*symbols, &block); end

  # Defines custom restful actions by resource or collection basis.
  #
  #   custom_actions :resource => [:delete, :transit], :collection => :search
  #
  # == Options
  #
  # * <tt>:resource</tt> -  Allows you to specify resource actions.
  #     custom_actions :resource => :delete
  #                         This macro creates 'delete' method in controller and defines
  #                         delete_resource_{path,url} helpers. The body of generated 'delete'
  #                         method is same as 'show' method. So you can override it if need
  #
  # * <tt>:collection</tt> - Allows you to specify collection actions.
  #     custom_actions :collection => :search
  #                         This macro creates 'search' method in controller and defines
  #                         search_resources_{path,url} helpers. The body of generated 'search'
  #                         method is same as 'index' method. So you can override it if need
  def custom_actions(options); end

  # Used to overwrite the default assumptions InheritedResources do. Whenever
  # this method is called, it should be on the top of your controller, since
  # almost other methods depends on the values given to <<tt>>defaults</tt>.
  #
  # == Options
  #
  # * <tt>:resource_class</tt> - The resource class which by default is guessed
  #                              by the controller name. Defaults to Project in
  #                              ProjectsController.
  #
  # * <tt>:collection_name</tt> - The name of the collection instance variable which
  #                               is set on the index action. Defaults to :projects in
  #                               ProjectsController.
  #
  # * <tt>:instance_name</tt> - The name of the singular instance variable which
  #                             is set on all actions besides index action. Defaults to
  #                             :project in ProjectsController.
  #
  # * <tt>:route_collection_name</tt> - The name of the collection route. Defaults to :collection_name.
  #
  # * <tt>:route_instance_name</tt> - The name of the singular route. Defaults to :instance_name.
  #
  # * <tt>:route_prefix</tt> - The route prefix which is automically set in namespaced
  #                            controllers. Default to :admin on Admin::ProjectsController.
  #
  # * <tt>:singleton</tt> - Tells if this controller is singleton or not.
  #
  # * <tt>:finder</tt> - Specifies which method should be called to instantiate the resource.
  #
  #     defaults :finder => :find_by_slug
  #
  # @raise [ArgumentError]
  def defaults(options); end

  # Defines that this controller belongs to another resource.
  #
  #   belongs_to :projects
  #
  # == Options
  #
  # * <tt>:parent_class</tt> - Allows you to specify what is the parent class.
  #
  #     belongs_to :project, :parent_class => AdminProject
  #
  # * <tt>:class_name</tt> - Also allows you to specify the parent class, but you should
  #                          give a string. Added for ActiveRecord belongs to compatibility.
  #
  # * <tt>:instance_name</tt> - The instance variable name. By default is the name of the association.
  #
  #     belongs_to :project, :instance_name => :my_project
  #
  # * <tt>:finder</tt> - Specifies which method should be called to instantiate the parent.
  #
  #     belongs_to :project, :finder => :find_by_title!
  #
  #   This will make your projects be instantiated as:
  #
  #     Project.find_by_title!(params[:project_id])
  #
  #   Instead of:
  #
  #     Project.find(params[:project_id])
  #
  # * <tt>:param</tt> - Allows you to specify params key to retrieve the id.
  #                     Default is :association_id, which in this case is :project_id.
  #
  # * <tt>:route_name</tt> - Allows you to specify what is the route name in your url
  #                          helper. By default is association name.
  #
  # * <tt>:collection_name</tt> - Tell how to retrieve the next collection. Let's
  #                               suppose you have Tasks which belongs to Projects
  #                               which belongs to companies. This will do somewhere
  #                               down the road:
  #
  #      @company.projects
  #
  #   But if you want to retrieve instead:
  #
  #      @company.admin_projects
  #
  #   You supply the collection name.
  #
  # * <tt>:polymorphic</tt> - Tell the association is polymorphic.
  #
  # * <tt>:singleton</tt> - Tell it's a singleton association.
  #
  # * <tt>:optional</tt> - Tell the association is optional (it's a special
  #                        type of polymorphic association)
  #
  # @raise [ArgumentError]
  def nested_belongs_to(*symbols, &block); end

  # A quick method to declare optional belongs to.
  def optional_belongs_to(*symbols, &block); end

  # A quick method to declare polymorphic belongs to.
  def polymorphic_belongs_to(*symbols, &block); end

  # A quick method to declare singleton belongs to.
  def singleton_belongs_to(*symbols, &block); end

  # Defines the role to use when creating or updating resource.
  # Makes sense when using rails 3.1 mass assignment conventions
  def with_role(role); end

  def without_protection(flag); end

  private

  def acts_as_polymorphic!; end
  def acts_as_shallow!; end
  def acts_as_singleton!; end
  def create_custom_action(resource_or_collection, action); end

  # Hook called on inheritance.
  def inherited(base); end

  # Initialize resources class accessors and set their default values.
  def initialize_resources_class_accessors!; end
end

# Allows controllers to write actions using a class method DSL.
#
#   class MyController < InheritedResources::Base
#     create! do |success, failure|
#       success.html { render :text => "It works!" }
#     end
#   end
module InheritedResources::DSL
  class << self
    # @private
    def included(base); end
  end
end

# = polymorphic associations
#
# In some cases you have a resource that belongs to two different resources
# but not at the same time. For example, let's suppose you have File, Message
# and Task as resources and they are all commentable.
#
# Polymorphic associations allows you to create just one controller that will
# deal with each case.
#
#   class Comment < InheritedResources::Base
#     belongs_to :file, :message, :task, :polymorphic => true
#   end
#
# Your routes should be something like:
#
#   resources :files do
#     resources :comments #=> /files/13/comments
#   end
#   resources :tasks do
#     resources :comments #=> /tasks/17/comments
#   end
#   resources :messages do
#     resources :comments #=> /messages/11/comments
#   end
#
# When using polymorphic associations, you get some free helpers:
#
#   parent?         #=> true
#   parent_type     #=> :task
#   parent_class    #=> Task
#   parent          #=> @task
#
# This polymorphic controllers thing is a great idea by James Golick and he
# built it in resource_controller. Here is just a re-implementation.
#
# = optional polymorphic associations
#
# Let's take another break from ProjectsController. Let's suppose we are
# building a store, which sell products.
#
# On the website, we can show all products, but also products scoped to
# categories, brands, users. In this case case, the association is optional, and
# we deal with it in the following way:
#
#   class ProductsController < InheritedResources::Base
#     belongs_to :category, :brand, :user, :polymorphic => true, :optional => true
#   end
#
# This will handle all those urls properly:
#
#   /products/1
#   /categories/2/products/5
#   /brands/10/products/3
#   /user/13/products/11
#
# = nested polymorphic associations
#
# You can have polymorphic associations with nested resources. Let's suppose
# that our File, Task and Message resources in the previous example belongs to
# a project.
#
# This way we can have:
#
#   class CommentsController < InheritedResources::Base
#     belongs_to :project {
#       belongs_to :file, :message, :task, :polymorphic => true
#     }
#   end
#
# Or:
#
#   class CommentsController < InheritedResources::Base
#     nested_belongs_to :project
#     nested_belongs_to :file, :message, :task, :polymorphic => true
#   end
#
# Choose the syntax that makes more sense to you. :)
#
# Finally your routes should be something like:
#
#   resources :projects do
#     resources :files do
#       resources :comments #=> /projects/1/files/13/comments
#     end
#     resources :tasks do
#       resources :comments #=> /projects/1/tasks/17/comments
#     end
#     resources :messages do
#       resources :comments #=> /projects/1/messages/11/comments
#     end
#   end
#
# The helpers work in the same way as above.
module InheritedResources::PolymorphicHelpers
  protected

  # Returns the parent object. They are also available with the instance
  # variable name: @task, @file, @note...
  def parent; end

  # If the polymorphic association is optional, we might not have a parent.
  #
  # @return [Boolean]
  def parent?; end

  def parent_class; end

  # Returns the parent type. A Comments class can have :task, :file, :note
  # as parent types.
  def parent_type; end

  private

  # Maps parents_symbols to build association chain.
  #
  # If the parents_symbols find :polymorphic, it goes through the
  # params keys to see which polymorphic parent matches the given params.
  #
  # When optional is given, it does not raise errors if the polymorphic
  # params are missing.
  def symbols_for_association_chain; end
end

class InheritedResources::Railtie < ::Rails::Engine; end

class InheritedResources::Responder < ::ActionController::Responder
  include ::Responders::FlashResponder
end

# Shallow provides a functionality that goes on pair with Rails' shallow.
# It is very similar to "optional" but it actually finds all the parents
# resources instead of leaving them blank. Consider the following example:
#
#   belongs_to :post, :shallow => true do
#     belongs_to :comment
#   end
#
# When accessed as /comments/1, Inherited Resources will automatically get
# the post resource so both objects are actually accessible through the views.
#
# However, when using optional, Inherited Resources wouldn't actually bother
# with finding the parent object.
module InheritedResources::ShallowHelpers
  private

  def load_parents(instance, parent_symbols); end
  def symbols_for_association_chain; end
end

# = singleton
#
# Singletons are usually used in associations which are related through has_one
# and belongs_to. You declare those associations like this:
#
#   class ManagersController < InheritedResources::Base
#     belongs_to :project, :singleton => true
#   end
#
# But in some cases, like an AccountsController, you have a singleton object
# that is not necessarily associated with another:
#
#   class AccountsController < InheritedResources::Base
#     defaults :singleton => true
#   end
#
# Besides that, you should overwrite the methods :resource and :build_resource
# to make it work properly:
#
#   class AccountsController < InheritedResources::Base
#     defaults :singleton => true
#
#     protected
#       def resource
#         @current_user.account
#       end
#
#       def build_resource(attributes = {})
#         Account.new(attributes)
#       end
#   end
#
# When you have a singleton controller, the action index is removed.
module InheritedResources::SingletonHelpers
  protected

  # Singleton methods does not deal with collections.
  def collection; end

  # Overwrites how singleton deals with resource.
  #
  # If you are going to overwrite it, you should notice that the
  # end_of_association_chain here is not the same as in default belongs_to.
  #
  #   class TasksController < InheritedResources::Base
  #     belongs_to :project
  #   end
  #
  # In this case, the association chain would be:
  #
  #   Project.find(params[:project_id]).tasks
  #
  # So you would just have to call find(:all) at the end of association
  # chain. And this is what happened.
  #
  # In singleton controllers:
  #
  #   class ManagersController < InheritedResources::Base
  #     belongs_to :project, :singleton => true
  #   end
  #
  # The association chain will be:
  #
  #   Project.find(params[:project_id])
  #
  # So we have to call manager on it, not find.
  def resource; end

  private

  # Returns the appropriated method to build the resource.
  def method_for_association_build; end

  # Sets the method_for_association_chain to nil. See <tt>resource</tt>
  # above for more information.
  def method_for_association_chain; end
end

# = URLHelpers
#
# When you use InheritedResources it creates some UrlHelpers for you.
# And they handle everything for you.
#
#  # /posts/1/comments
#  resource_url          # => /posts/1/comments/#{@comment.to_param}
#  resource_url(comment) # => /posts/1/comments/#{comment.to_param}
#  new_resource_url      # => /posts/1/comments/new
#  edit_resource_url     # => /posts/1/comments/#{@comment.to_param}/edit
#  collection_url        # => /posts/1/comments
#  parent_url            # => /posts/1
#
#  # /projects/1/tasks
#  resource_url          # => /projects/1/tasks/#{@task.to_param}
#  resource_url(task)    # => /projects/1/tasks/#{task.to_param}
#  new_resource_url      # => /projects/1/tasks/new
#  edit_resource_url     # => /projects/1/tasks/#{@task.to_param}/edit
#  collection_url        # => /projects/1/tasks
#  parent_url            # => /projects/1
#
#  # /users
#  resource_url          # => /users/#{@user.to_param}
#  resource_url(user)    # => /users/#{user.to_param}
#  new_resource_url      # => /users/new
#  edit_resource_url     # => /users/#{@user.to_param}/edit
#  collection_url        # => /users
#  parent_url            # => /
#
# The nice thing is that those urls are not guessed during runtime. They are
# all created when you inherit.
module InheritedResources::UrlHelpers
  protected

  # This method hard code url helpers in the class.
  #
  # We are doing this because is cheaper than guessing them when our action
  # is being processed (and even more cheaper when we are using nested
  # resources).
  #
  # When we are using polymorphic associations, those helpers rely on
  # polymorphic_url Rails helper.
  def create_resources_url_helpers!; end

  def define_helper_method(prefix, name, suffix, segments); end
  def define_params_helper(prefix, name, singleton, polymorphic, parent_index, ivars); end
  def generate_url_and_path_helpers(prefix, name, resource_segments, resource_ivars); end
  def handle_shallow_resource(prefix, name, segments, ivars); end
end

InheritedResources::VERSION = T.let(T.unsafe(nil), String)

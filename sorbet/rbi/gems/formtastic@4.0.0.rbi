# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `formtastic` gem.
# Please instead update this file by running `bin/tapioca gem formtastic`.

# Provides an intuitive way to build has_many associated records in the same form.
module Formtastic
  extend ::ActiveSupport::Autoload
end

# Uses the {NamespacedClassFinder} to look up action class names.
#
# See {Formtastic::Helpers::ActionHelper#namespaced_action_class} for details.
class Formtastic::ActionClassFinder < ::Formtastic::NamespacedClassFinder
  # @param builder [FormBuilder]
  # @return [ActionClassFinder] a new instance of ActionClassFinder
  def initialize(builder); end

  def class_name(as); end
end

module Formtastic::Actions
  extend ::ActiveSupport::Autoload
end

module Formtastic::Actions::Base
  include ::Formtastic::LocalizedString

  def initialize(builder, template, object, object_name, method, options); end

  def accesskey; end

  # Returns the value of attribute builder.
  def builder; end

  # Sets the attribute builder
  #
  # @param value the value to set the attribute builder to.
  def builder=(_arg0); end

  def button_html; end
  def button_html_from_options; end
  def default_button_html; end
  def default_wrapper_classes; end
  def default_wrapper_html_options; end
  def default_wrapper_id; end
  def extra_button_html_options; end

  # Returns the value of attribute method.
  def method; end

  # Sets the attribute method
  #
  # @param value the value to set the attribute method to.
  def method=(_arg0); end

  # Returns the value of attribute object.
  def object; end

  # Sets the attribute object
  #
  # @param value the value to set the attribute object to.
  def object=(_arg0); end

  # Returns the value of attribute object_name.
  def object_name; end

  # Sets the attribute object_name
  #
  # @param value the value to set the attribute object_name to.
  def object_name=(_arg0); end

  # Returns the value of attribute options.
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  def options=(_arg0); end

  # @raise [NotImplementedError]
  def supported_methods; end

  # Returns the value of attribute template.
  def template; end

  # Sets the attribute template
  #
  # @param value the value to set the attribute template to.
  def template=(_arg0); end

  def text; end

  # @raise [NotImplementedError]
  def to_html; end

  def wrapper(&block); end
  def wrapper_class; end
  def wrapper_classes_from_options; end
  def wrapper_html_options; end
  def wrapper_html_options_from_options; end
  def wrapper_id; end
  def wrapper_id_from_options; end

  protected

  # @raise [Formtastic::UnsupportedMethodForAction]
  def check_supported_methods!; end

  def i18n_key; end

  # @return [Boolean]
  def new_or_persisted_object?; end

  def sanitized_object_name; end
  def submit_i18n_key; end
end

# Outputs a `<button type="submit">` or `<button type="reset">` wrapped in the standard `<li>`
# wrapper. This is an alternative choice for `:submit` and `:reset` actions, which render with
# `<input type="submit">` and `<input type="reset">` by default.
#
# @example Full form context and output
#
#   <%= semantic_form_for(@post) do |f| %>
#   <%= f.actions do %>
#   <%= f.action :reset, :as => :button %>
#   <%= f.action :submit, :as => :button %>
#   <% end %>
#   <% end %>
#
#   <form...>
#   <fieldset class="actions">
#   <ol>
#   <li class="action button_action" id="post_reset_action">
#   <button type="reset" value="Reset">
#   </li>
#   <li class="action button_action" id="post_submit_action">
#   <button type="submit" value="Create Post">
#   </li>
#   </ol>
#   </fieldset>
#   </form>
# @example Specifying a label with a String
#   <%= f.action :submit, :as => :button, :label => "Go" %>
# @example Pass HTML attributes down to the `<button>`
#   <%= f.action :submit, :as => :button, :button_html => { :class => 'pretty', :accesskey => 'g', :disable_with => "Wait..." } %>
# @example Access key can also be set as a top-level option
#   <%= f.action :submit, :as => :button, :accesskey => 'g' %>
# @example Pass HTML attributes down to the `<li>` wrapper (classes are appended to the existing classes)
#   <%= f.action :submit, :as => :button, :wrapper_html => { :class => 'special', :id => 'whatever' } %>
#   <%= f.action :submit, :as => :button, :wrapper_html => { :class => ['extra', 'special'], :id => 'whatever' } %>
# @todo document i18n keys
# @todo document i18n translation with :label (?)
class Formtastic::Actions::ButtonAction
  include ::Formtastic::LocalizedString
  include ::Formtastic::Actions::Base
  include ::Formtastic::Actions::Buttonish

  # TODO reset_action class?
  def to_html; end
end

module Formtastic::Actions::Buttonish
  def extra_button_html_options; end
  def supported_methods; end
end

# Outputs an `<input type="submit">` or `<input type="reset">` wrapped in the standard `<li>`
# wrapper. This the default for `:submit` and `:reset` actions, but `:as => :button` is also
# available as an alternative.
#
# @example The `:as` can be ommitted, these are functionally equivalent
#   <%= f.action :submit, :as => :input %>
#   <%= f.action :submit %>
# @example Full form context and output
#
#   <%= semantic_form_for(@post) do |f| %>
#   <%= f.actions do %>
#   <%= f.action :reset, :as => :input %>
#   <%= f.action :submit, :as => :input %>
#   <% end %>
#   <% end %>
#
#   <form...>
#   <fieldset class="actions">
#   <ol>
#   <li class="action input_action" id="post_reset_action">
#   <input type="reset" value="Reset">
#   </li>
#   <li class="action input_action" id="post_submit_action">
#   <input type="submit" value="Create Post">
#   </li>
#   </ol>
#   </fieldset>
#   </form>
# @example Specifying a label with a String
#   <%= f.action :submit, :as => :input, :label => "Go" %>
# @example Pass HTML attributes down to the `<input>`
#   <%= f.action :submit, :as => :input, :button_html => { :class => 'pretty', :accesskey => 'g', :disable_with => "Wait..." } %>
# @example Access key can also be set as a top-level option
#   <%= f.action :submit, :as => :input, :accesskey => 'g' %>
# @example Pass HTML attributes down to the `<li>` wrapper (classes are appended to the existing classes)
#   <%= f.action :submit, :as => :input, :wrapper_html => { :class => 'special', :id => 'whatever' } %>
#   <%= f.action :submit, :as => :input, :wrapper_html => { :class => ['extra', 'special'], :id => 'whatever' } %>
# @todo document i18n keys
# @todo document i18n translation with :label (?)
class Formtastic::Actions::InputAction
  include ::Formtastic::LocalizedString
  include ::Formtastic::Actions::Base
  include ::Formtastic::Actions::Buttonish

  # @option *args
  # @option *args
  # @option *args
  # @param *args [Hash] a customizable set of options
  # @see Formtastic::Helpers::ActionHelper#action
  def to_html; end
end

# Outputs a link wrapped in the standard `<li>` wrapper. This the default for `:cancel` actions.
# The link's URL defaults to Rails' built-in `:back` macro (the HTTP referrer, or Javascript for the
# browser's history), but can be altered with the `:url` option.
#
# @example The `:as` can be ommitted, these are functionally equivalent
#   <%= f.action :cancel, :as => :link %>
#   <%= f.action :cancel %>
# @example Full form context and output
#
#   <%= semantic_form_for(@post) do |f| %>
#   <%= f.actions do %>
#   <%= f.action :submit, :as => :input %>
#   <%= f.action :cancel, :as => :link %>
#   <% end %>
#   <% end %>
#
#   <form...>
#   <fieldset class="actions">
#   <ol>
#   <li class="action input_action" id="post_submit_action">
#   <input type="submit" value="Create Post">
#   </li>
#   <li class="action link_action" id="post_cancel_action">
#   <a href="javascript:history.back()">Cancel</a>
#   </li>
#   </ol>
#   </fieldset>
#   </form>
# @example Modifying the URL for the link
#   <%= f.action :cancel, :as => :link, :url => "http://example.com/path" %>
#   <%= f.action :cancel, :as => :link, :url => "/path" %>
#   <%= f.action :cancel, :as => :link, :url => posts_path %>
#   <%= f.action :cancel, :as => :link, :url => url_for(...) %>
#   <%= f.action :cancel, :as => :link, :url => { :controller => "posts", :action => "index" } %>
# @example Specifying a label with a String
#   <%= f.action :cancel, :as => :link, :label => "Stop" %>
# @example Pass HTML attributes down to the `<a>`
#   <%= f.action :cancel, :as => :link, :button_html => { :class => 'pretty', :accesskey => 'x' } %>
# @example Access key can also be set as a top-level option
#   <%= f.action :cancel, :as => :link, :accesskey => 'x' %>
# @example Pass HTML attributes down to the `<li>` wrapper (classes are appended to the existing classes)
#   <%= f.action :cancel, :as => :link, :wrapper_html => { :class => 'special', :id => 'whatever' } %>
#   <%= f.action :cancel, :as => :link, :wrapper_html => { :class => ['extra', 'special'], :id => 'whatever' } %>
# @todo document i18n keys
# @todo document i18n translation with :label (?)
# @todo :prefix and :suffix options? (can also be done with CSS or subclassing for custom Actions)
class Formtastic::Actions::LinkAction
  include ::Formtastic::LocalizedString
  include ::Formtastic::Actions::Base

  # @option *args
  # @option *args
  # @option *args
  # @param *args [Hash] a customizable set of options
  # @see Formtastic::Helpers::ActionHelper#action
  def supported_methods; end

  # TODO reset_action class?
  def to_html; end

  def url; end
end

Formtastic::Deprecation = ActiveSupport::Deprecation

# Required for formtastic.css to be discoverable in the asset pipeline
#
# @private
class Formtastic::Engine < ::Rails::Engine; end

class Formtastic::FormBuilder < ::ActionView::Helpers::FormBuilder
  include ::Formtastic::HtmlAttributes
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Helpers::Enum
  include ::Formtastic::Helpers::FileColumnDetection
  include ::Formtastic::Helpers::InputHelper
  include ::Formtastic::Helpers::FieldsetWrapper
  include ::Formtastic::LocalizedString
  include ::Formtastic::Helpers::InputsHelper
  include ::Formtastic::Helpers::ActionHelper
  include ::Formtastic::Helpers::ActionsHelper
  include ::Formtastic::Helpers::ErrorsHelper

  def initialize(object_name, object, template, options); end

  def action_class_finder; end
  def action_class_finder=(_arg0); end
  def action_class_finder?; end
  def action_namespaces; end
  def action_namespaces=(_arg0); end
  def action_namespaces?; end
  def all_fields_required_by_default; end
  def all_fields_required_by_default=(_arg0); end
  def all_fields_required_by_default?; end
  def auto_index; end
  def collection_label_methods; end
  def collection_label_methods=(_arg0); end
  def collection_label_methods?; end
  def collection_value_methods; end
  def collection_value_methods=(_arg0); end
  def collection_value_methods?; end
  def custom_namespace; end
  def custom_namespace=(_arg0); end
  def custom_namespace?; end
  def default_commit_button_accesskey; end
  def default_commit_button_accesskey=(_arg0); end
  def default_commit_button_accesskey?; end
  def default_error_list_class; end
  def default_error_list_class=(_arg0); end
  def default_error_list_class?; end
  def default_hint_class; end
  def default_hint_class=(_arg0); end
  def default_hint_class?; end
  def default_inline_error_class; end
  def default_inline_error_class=(_arg0); end
  def default_inline_error_class?; end
  def default_text_area_height; end
  def default_text_area_height=(_arg0); end
  def default_text_area_height?; end
  def default_text_area_width; end
  def default_text_area_width=(_arg0); end
  def default_text_area_width?; end
  def default_text_field_size; end
  def default_text_field_size=(_arg0); end
  def default_text_field_size?; end
  def escape_html_entities_in_hints_and_labels; end
  def escape_html_entities_in_hints_and_labels=(_arg0); end
  def escape_html_entities_in_hints_and_labels?; end
  def file_metadata_suffixes; end
  def file_metadata_suffixes=(_arg0); end
  def file_metadata_suffixes?; end
  def file_methods; end
  def file_methods=(_arg0); end
  def file_methods?; end
  def i18n_cache_lookups; end
  def i18n_cache_lookups=(_arg0); end
  def i18n_cache_lookups?; end
  def i18n_localizer; end
  def i18n_localizer=(_arg0); end
  def i18n_localizer?; end
  def i18n_lookups_by_default; end
  def i18n_lookups_by_default=(_arg0); end
  def i18n_lookups_by_default?; end
  def include_blank_for_select_by_default; end
  def include_blank_for_select_by_default=(_arg0); end
  def include_blank_for_select_by_default?; end
  def inline_errors; end
  def inline_errors=(_arg0); end
  def inline_errors?; end
  def input_class_finder; end
  def input_class_finder=(_arg0); end
  def input_class_finder?; end
  def input_namespaces; end
  def input_namespaces=(_arg0); end
  def input_namespaces?; end
  def label_str_method; end
  def label_str_method=(_arg0); end
  def label_str_method?; end
  def optional_string; end
  def optional_string=(_arg0); end
  def optional_string?; end
  def perform_browser_validations; end
  def perform_browser_validations=(_arg0); end
  def perform_browser_validations?; end
  def priority_countries; end
  def priority_countries=(_arg0); end
  def priority_countries?; end
  def priority_time_zones; end
  def priority_time_zones=(_arg0); end
  def priority_time_zones?; end
  def required_string; end
  def required_string=(_arg0); end
  def required_string?; end
  def semantic_fields_for(record_or_name_or_array, *args, &block); end
  def skipped_columns; end
  def skipped_columns=(_arg0); end
  def skipped_columns?; end
  def template; end
  def use_required_attribute; end
  def use_required_attribute=(_arg0); end
  def use_required_attribute?; end

  class << self
    # @api public
    def action_class_finder; end

    # @api public
    def action_class_finder=(value); end

    def action_class_finder?; end

    # Check {Formtastic::ActionClassFinder} to see how are inputs resolved.
    #
    # @api public
    def action_namespaces; end

    # Check {Formtastic::ActionClassFinder} to see how are inputs resolved.
    #
    # @api public
    def action_namespaces=(value); end

    def action_namespaces?; end

    # @api public
    def all_fields_required_by_default; end

    # @api public
    def all_fields_required_by_default=(value); end

    def all_fields_required_by_default?; end

    # @api public
    def collection_label_methods; end

    # @api public
    def collection_label_methods=(value); end

    def collection_label_methods?; end

    # @api public
    def collection_value_methods; end

    # @api public
    def collection_value_methods=(value); end

    def collection_value_methods?; end

    # Defines a new configurable option
    #
    # @param name [Symbol] the configuration name
    # @param default [Object] the configuration default value
    # @private
    def configure(name, default = T.unsafe(nil)); end

    # @api public
    def custom_namespace; end

    # @api public
    def custom_namespace=(value); end

    def custom_namespace?; end

    # @api public
    def default_commit_button_accesskey; end

    # @api public
    def default_commit_button_accesskey=(value); end

    def default_commit_button_accesskey?; end

    # @api public
    def default_error_list_class; end

    # @api public
    def default_error_list_class=(value); end

    def default_error_list_class?; end

    # @api public
    def default_hint_class; end

    # @api public
    def default_hint_class=(value); end

    def default_hint_class?; end

    # @api public
    def default_inline_error_class; end

    # @api public
    def default_inline_error_class=(value); end

    def default_inline_error_class?; end

    # @api public
    def default_text_area_height; end

    # @api public
    def default_text_area_height=(value); end

    def default_text_area_height?; end

    # @api public
    def default_text_area_width; end

    # @api public
    def default_text_area_width=(value); end

    def default_text_area_width?; end

    # @api public
    def default_text_field_size; end

    # @api public
    def default_text_field_size=(value); end

    def default_text_field_size?; end

    # @api public
    def escape_html_entities_in_hints_and_labels; end

    # @api public
    def escape_html_entities_in_hints_and_labels=(value); end

    def escape_html_entities_in_hints_and_labels?; end

    # @api public
    def file_metadata_suffixes; end

    # @api public
    def file_metadata_suffixes=(value); end

    def file_metadata_suffixes?; end

    # @api public
    def file_methods; end

    # @api public
    def file_methods=(value); end

    def file_methods?; end

    # @api public
    def i18n_cache_lookups; end

    # @api public
    def i18n_cache_lookups=(value); end

    def i18n_cache_lookups?; end

    # @api public
    def i18n_localizer; end

    # @api public
    def i18n_localizer=(value); end

    def i18n_localizer?; end

    # @api public
    def i18n_lookups_by_default; end

    # @api public
    def i18n_lookups_by_default=(value); end

    def i18n_lookups_by_default?; end

    # @api public
    def include_blank_for_select_by_default; end

    # @api public
    def include_blank_for_select_by_default=(value); end

    def include_blank_for_select_by_default?; end

    # @api public
    def inline_errors; end

    # @api public
    def inline_errors=(value); end

    def inline_errors?; end

    # @api public
    def input_class_finder; end

    # @api public
    def input_class_finder=(value); end

    def input_class_finder?; end

    # Check {Formtastic::InputClassFinder} to see how are inputs resolved.
    #
    # @api public
    def input_namespaces; end

    # Check {Formtastic::InputClassFinder} to see how are inputs resolved.
    #
    # @api public
    def input_namespaces=(value); end

    def input_namespaces?; end

    # @api public
    def label_str_method; end

    # @api public
    def label_str_method=(value); end

    def label_str_method?; end

    # @api public
    def optional_string; end

    # @api public
    def optional_string=(value); end

    def optional_string?; end

    # @api public
    def perform_browser_validations; end

    # @api public
    def perform_browser_validations=(value); end

    def perform_browser_validations?; end

    # @api public
    def priority_countries; end

    # @api public
    def priority_countries=(value); end

    def priority_countries?; end

    # @api public
    def priority_time_zones; end

    # @api public
    def priority_time_zones=(value); end

    def priority_time_zones?; end

    # @api public
    def required_string; end

    # @api public
    def required_string=(value); end

    def required_string?; end

    # @api public
    def skipped_columns; end

    # @api public
    def skipped_columns=(value); end

    def skipped_columns?; end

    # @api public
    def use_required_attribute; end

    # @api public
    def use_required_attribute=(value); end

    def use_required_attribute?; end
  end
end

module Formtastic::Helpers; end

module Formtastic::Helpers::ActionHelper
  # Renders an action for the form (such as a subit/reset button, or a cancel link).
  #
  # Each action is wrapped in an `<li class="action">` tag with other classes added based on the
  # type of action being rendered, and is intended to be rendered inside a {#buttons}
  # block which wraps the button in a `fieldset` and `ol`.
  #
  # The textual value of the label can be changed from the default through the `:label`
  # argument or through i18n.
  #
  # If using i18n, you'll need to provide the following translations:
  #
  #   en:
  #     formtastic:
  #       actions:
  #         create: "Create new %{model}"
  #         update: "Save %{model}"
  #         cancel: "Cancel"
  #         reset: "Reset form"
  #         submit: "Submit"
  #
  # For forms with an object present, the `update` key will be used if calling `persisted?` on
  # the object returns true (saving changes to a record), otherwise the `create` key will be
  # used. The `submit` key is used as a fallback when there is no object or we cannot determine
  # if `create` or `update` is appropriate.
  #
  # @example Basic usage
  #   # form
  #   <%= semantic_form_for @post do |f| %>
  #   ...
  #   <%= f.actions do %>
  #   <%= f.action :submit %>
  #   <%= f.action :reset %>
  #   <%= f.action :cancel %>
  #   <% end %>
  #   <% end %>
  #
  #   # output
  #   <form ...>
  #   ...
  #   <fieldset class="buttons">
  #   <ol>
  #   <li class="action input_action">
  #   <input name="commit" type="submit" value="Create Post">
  #   </li>
  #   <li class="action input_action">
  #   <input name="commit" type="reset" value="Reset Post">
  #   </li>
  #   <li class="action link_action">
  #   <a href="/posts">Cancel Post</a>
  #   </li>
  #   </ol>
  #   </fieldset>
  #   </form>
  # @example Set the value through the `:label` option
  #   <%= f.action :submit, :label => "Go" %>
  # @example Pass HTML attributes down to the tag inside the wrapper
  #   <%= f.action :submit, :button_html => { :class => 'pretty', :accesskey => 'g', :disable_with => "Wait..." } %>
  # @example Pass HTML attributes down to the `<li>` wrapper
  #   <%= f.action :submit, :wrapper_html => { :class => 'special', :id => 'whatever' } %>
  # @option *args
  # @option *args
  # @option *args
  # @param *args [Hash] a customizable set of options
  # @todo document i18n keys
  def action(method, options = T.unsafe(nil)); end

  protected

  # @private
  def default_action_type(method, options = T.unsafe(nil)); end

  # Takes the `:as` option and attempts to return the corresponding action
  # class. In the case of `:as => :awesome` it will first attempt to find a
  # top level `AwesomeAction` class (to allow the application to subclass
  # and modify to suit), falling back to `Formtastic::Actions::AwesomeAction`.
  #
  # Custom action namespaces to look into can be configured via the
  # {Formtastic::FormBuilder.action_namespaces} configuration setting.
  #
  # @see Helpers::InputHelper#namespaced_input_class
  # @see Formtastic::ActionClassFinder
  def namespaced_action_class(as); end
end

# ActionsHelper encapsulates the responsibilties of the {#actions} DSL for acting on
# (submitting, cancelling, resetting) forms.
#
# {#actions} is a block helper used to wrap the form's actions (buttons, links) in a
# `<fieldset>` and `<ol>`, with each item in the list containing the markup representing a
# single action.
#
#     <%= semantic_form_for @post do |f| %>
#       ...
#       <%= f.actions do %>
#         <%= f.action :submit
#         <%= f.action :cancel
#       <% end %>
#     <% end %>
#
# The HTML output will be something like:
#
#     <form class="formtastic" method="post" action="...">
#       ...
#       <fieldset class="actions">
#         <ol>
#           <li class="action input_action">
#             <input type="submit" name="commit" value="Create Post">
#           </li>
#           <li class="action input_action">
#             <a href="/posts">Cancel Post</a>
#           </li>
#         </ol>
#       </fieldset>
#     </form>
#
# It's important to note that the `semantic_form_for` and {#actions} blocks wrap the
# standard Rails `form_for` helper and form builder, so you have full access to every standard
# Rails form helper, with any HTML markup and ERB syntax, allowing you to "break free" from
# Formtastic when it doesn't suit to create your own buttons, links and actions:
#
#     <%= semantic_form_for @post do |f| %>
#       ...
#       <%= f.actions do %>
#         <li class="save">
#           <%= f.submit "Save" %>
#         <li>
#         <li class="cancel-link">
#           Or <%= link_to "Cancel", posts_url %>
#         <li>
#       <% end %>
#     <% end %>
#
# There are many other syntax variations and arguments to customize your form. See the
# full documentation of {#actions} and {#action} for details.
module Formtastic::Helpers::ActionsHelper
  include ::Formtastic::Helpers::FieldsetWrapper

  # Creates a fieldset and ol tag wrapping for use around a set of buttons. It can be
  # called either with a block (in which you can do the usual Rails form stuff, HTML, ERB, etc),
  # or with a list of named actions. These two examples are functionally equivalent:
  #
  #     # With a block:
  #     <% semantic_form_for @post do |f| %>
  #       ...
  #       <% f.actions do %>
  #         <%= f.action :submit %>
  #         <%= f.action :cancel %>
  #       <% end %>
  #     <% end %>
  #
  #     # With a list of fields:
  #     <% semantic_form_for @post do |f| %>
  #       <%= f.actions :submit, :cancel %>
  #     <% end %>
  #
  #     # Output:
  #     <form ...>
  #       <fieldset class="buttons">
  #         <ol>
  #           <li class="action input_action">
  #             <input type="submit" ...>
  #           </li>
  #           <li class="action link_action">
  #             <a href="...">...</a>
  #           </li>
  #         </ol>
  #       </fieldset>
  #     </form>
  #
  # All options except `:name` and `:title` are passed down to the fieldset as HTML
  # attributes (`id`, `class`, `style`...). If provided, the `:name` or `:title` option is
  # passed into a `<legend>` inside the `<fieldset>` to name the set of buttons.
  #
  # @example Quickly add button(s) to the form, accepting all default values, options and behaviors
  #   <% semantic_form_for @post do |f| %>
  #   ...
  #   <%= f.actions %>
  #   <% end %>
  # @example Specify which named buttons you want, accepting all default values, options and behaviors
  #   <% semantic_form_for @post do |f| %>
  #   ...
  #   <%= f.actions :commit %>
  #   <% end %>
  # @example Specify which named buttons you want, and name the fieldset
  #   <% semantic_form_for @post do |f| %>
  #   ...
  #   <%= f.actions :commit, :name => "Actions" %>
  #   or
  #   <%= f.actions :commit, :label => "Actions" %>
  #   <% end %>
  # @example Get full control over the action options
  #   <% semantic_form_for @post do |f| %>
  #   ...
  #   <%= f.actions do %>
  #   <%= f.action :label => "Go", :button_html => { :class => "pretty" :disable_with => "Wait..." }, :wrapper_html => { ... }
  #   <% end %>
  #   <% end %>
  # @example Make your own actions with standard Rails helpers or HTML
  #   <% semantic_form_for @post do |f| %>
  #   <%= f.actions do %>
  #   <li>
  #   ...
  #   </li>
  #   <% end %>
  #   <% end %>
  # @example Add HTML attributes to the fieldset
  #   <% semantic_form_for @post do |f| %>
  #   ...
  #   <%= f.actions :commit, :style => "border:1px;" %>
  #   or
  #   <%= f.actions :style => "border:1px;" do %>
  #   ...
  #   <% end %>
  #   <% end %>
  # @option *args
  # @option *args
  # @param *args [Hash] a customizable set of options
  # @todo document i18n keys
  def actions(*args, &block); end

  protected

  def default_actions; end
end

# @private
module Formtastic::Helpers::Enum
  # Returns the enum (if defined) for the given method
  def enum_for(method); end
end

module Formtastic::Helpers::ErrorsHelper
  include ::Formtastic::Helpers::FileColumnDetection
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::LocalizedString

  # Generates an unordered list of error messages on the base object and optionally for a given
  # set of named attribute. This is idea for rendering a block of error messages at the top of
  # the form for hidden/special/virtual attributes (the Paperclip Rails plugin does this), or
  # errors on the base model.
  #
  # A hash can be used as the last set of arguments to pass HTML attributes to the `<ul>`
  # wrapper.
  #
  # @example A list of errors on the base model
  #   <%= semantic_form_for ... %>
  #   <%= f.semantic_errors %>
  #   ...
  #   <% end %>
  # @example A list of errors on the base and named attributes
  #   <%= semantic_form_for ... %>
  #   <%= f.semantic_errors :something_special %>
  #   ...
  #   <% end %>
  # @example A list of errors on the base model, with custom HTML attributes
  #   <%= semantic_form_for ... %>
  #   <%= f.semantic_errors :class => "awesome" %>
  #   ...
  #   <% end %>
  # @example A list of errors on the base model and named attributes, with custom HTML attributes
  #   <%= semantic_form_for ... %>
  #   <%= f.semantic_errors :something_special, :something_else, :class => "awesome", :onclick => "Awesome();" %>
  #   ...
  #   <% end %>
  def semantic_errors(*args); end

  protected

  def error_keys(method, options); end

  # @return [Boolean]
  def has_errors?(method, options); end

  # @return [Boolean]
  def render_inline_errors?; end
end

Formtastic::Helpers::ErrorsHelper::INLINE_ERROR_TYPES = T.let(T.unsafe(nil), Array)

# @private
module Formtastic::Helpers::FieldsetWrapper
  protected

  # Generates a fieldset and wraps the content in an ordered list. When working
  # with nested attributes, it allows %i as interpolation option in :name. So you can do:
  #
  #   f.inputs :name => 'Task #%i', :for => :tasks
  #
  # or the shorter equivalent:
  #
  #   f.inputs 'Task #%i', :for => :tasks
  #
  # And it will generate a fieldset for each task with legend 'Task #1', 'Task #2',
  # 'Task #3' and so on.
  #
  # Note: Special case for the inline inputs (non-block):
  #   f.inputs "My little legend", :title, :body, :author   # Explicit legend string => "My little legend"
  #   f.inputs :my_little_legend, :title, :body, :author    # Localized (118n) legend with I18n key => I18n.t(:my_little_legend, ...)
  #   f.inputs :title, :body, :author                       # First argument is a column => (no legend)
  def field_set_and_list_wrapping(*args, &block); end

  def field_set_legend(html_options); end

  # Gets the nested_child_index value from the parent builder. It returns a hash with each
  # association that the parent builds.
  def parent_child_index(parent); end
end

# @private
module Formtastic::Helpers::FileColumnDetection
  # @return [Boolean]
  def is_file?(method, options = T.unsafe(nil)); end
end

# FormHelper provides a handful of wrappers around Rails' built-in form helpers methods to set
# the `:builder` option to `Formtastic::FormBuilder` and apply some class names to the `<form>`
# tag.
#
# The following methods are wrapped:
#
# * `semantic_form_for` to `form_for`
# * `semantic_fields_for` to `fields_for`
# * `semantic_remote_form_for` and `semantic_form_remote_for` to `remote_form_for`
#
# The following two examples are effectively equivalent:
#
#     <%= form_for(@post, :builder => Formtastic::FormBuilder, :class => 'formtastic post') do |f| %>
#       #...
#     <% end %>
#
#     <%= semantic_form_for(@post) do |f| %>
#       #...
#     <% end %>
#
# This simple wrapping means that all arguments, options and variations supported by Rails' own
# helpers are also supported by Formtastic.
#
# Since `Formtastic::FormBuilder` subclasses Rails' own `FormBuilder`, you have access to all
# of Rails' built-in form helper methods such as `text_field`, `check_box`, `radio_button`,
# etc **in addition to** all of Formtastic's additional helpers like {InputsHelper#inputs inputs},
# {InputsHelper#input input}, {ButtonsHelper#buttons buttons}, etc:
#
#     <%= semantic_form_for(@post) do |f| %>
#
#       <!-- Formtastic -->
#       <%= f.input :title %>
#
#       <!-- Rails -->
#       <li class='something-custom'>
#         <%= f.label :title %>
#         <%= f.text_field :title %>
#         <p class='hints'>...</p>
#       </li>
#     <% end %>
#
# Formtastic is a superset of Rails' FormBuilder. It deliberately avoids overriding or modifying
# the behavior of Rails' own form helpers so that you can use Formtastic helpers when suited,
# and fall back to regular Rails helpers, ERB and HTML when needed. In other words, you're never
# fully committed to The Formtastic Way.
module Formtastic::Helpers::FormHelper
  def builder; end
  def builder=(val); end
  def default_form_class; end
  def default_form_class=(val); end
  def default_form_model_class_proc; end
  def default_form_model_class_proc=(val); end
  def formtastic_field_error_proc; end
  def formtastic_field_error_proc=(val); end

  # Wrapper around Rails' own `fields_for` helper to set the `:builder` option to
  # `Formtastic::FormBuilder`.
  #
  # @see #semantic_form_for
  def semantic_fields_for(record_name, record_object = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # Wrapper around Rails' own `form_for` helper to set the `:builder` option to
  # `Formtastic::FormBuilder` and to set some class names on the `<form>` tag such as
  # `formtastic` and the downcased and underscored model name (eg `post`).
  #
  # See Rails' `form_for` for full documentation of all supported arguments and options.
  #
  # Since `Formtastic::FormBuilder` subclasses Rails' own FormBuilder, you have access to all
  # of Rails' built-in form helper methods such as `text_field`, `check_box`, `radio_button`,
  # etc **in addition to** all of Formtastic's additional helpers like {InputsHelper#inputs inputs},
  # {InputsHelper#input input}, {ButtonsHelper#buttons buttons}, etc.
  #
  # Most of the examples below have been adapted from the examples found in the Rails `form_for`
  # documentation.
  #
  # @example Resource-oriented form generation
  #   <%= semantic_form_for @user do |f| %>
  #   <%= f.input :name %>
  #   <%= f.input :email %>
  #   <%= f.input :password %>
  #   <% end %>
  # @example Generic form generation
  #   <%= semantic_form_for :user do |f| %>
  #   <%= f.input :name %>
  #   <%= f.input :email %>
  #   <%= f.input :password %>
  #   <% end %>
  # @example Resource-oriented with custom URL
  #   <%= semantic_form_for(@post, :url => super_post_path(@post)) do |f| %>
  #   ...
  #   <% end %>
  # @example Resource-oriented with namespaced routes
  #   <%= semantic_form_for([:admin, @post]) do |f| %>
  #   ...
  #   <% end %>
  # @example Resource-oriented with nested routes
  #   <%= semantic_form_for([@user, @post]) do |f| %>
  #   ...
  #   <% end %>
  # @example Rename the resource
  #   <%= semantic_form_for(@post, :as => :article) do |f| %>
  #   ...
  #   <% end %>
  # @example Remote forms (unobtrusive JavaScript)
  #   <%= semantic_form_for(@post, :remote => true) do |f| %>
  #   ...
  #   <% end %>
  # @example Namespaced forms all multiple Formtastic forms to exist on the one page without DOM id clashes and invalid HTML documents.
  #   <%= semantic_form_for(@post, :namespace => 'first') do |f| %>
  #   ...
  #   <% end %>
  # @example Accessing a mixture of Formtastic helpers and Rails FormBuilder helpers.
  #   <%= semantic_form_for(@post) do |f| %>
  #   <%= f.input :title %>
  #   <%= f.input :body %>
  #   <li class="something-custom">
  #   <label><%= f.check_box :published %></label>
  #   </li>
  #   <% end %>
  # @option *args
  # @option *args
  # @option *args
  # @param record_or_name_or_array Same behavior as Rails' `form_for`
  # @param *args [Hash] a customizable set of options
  # @see http://api.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html Rails' FormHelper documentation (`form_for`, etc)
  # @see http://api.rubyonrails.org/classes/ActionView/Helpers/FormBuilder.html Rails' FormBuilder documentaion (`text_field`, etc)
  # @see FormHelper The overview of the FormBuilder module
  def semantic_form_for(record_or_name_or_array, *args, &proc); end

  protected

  def with_custom_field_error_proc(&block); end

  class << self
    def builder; end
    def builder=(val); end
    def default_form_class; end
    def default_form_class=(val); end
    def default_form_model_class_proc; end
    def default_form_model_class_proc=(val); end
    def formtastic_field_error_proc; end
    def formtastic_field_error_proc=(val); end
  end
end

# {#input} is used to render all content (labels, form widgets, error messages, hints, etc) for
# a single form input (or field), usually representing a single method or attribute on the
# form's object or model.
#
# The content is wrapped in an `<li>` tag, so it's usually called inside an {Formtastic::Helpers::InputsHelper#inputs inputs} block
# (which renders an `<ol>` inside a `<fieldset>`), which should be inside a {Formtastic::Helpers::FormHelper#semantic_form_for `semantic_form_for`}
# block:
#
#     <%= semantic_form_for @post do |f| %>
#       <%= f.inputs do %>
#         <%= f.input :title %>
#         <%= f.input :body %>
#       <% end %>
#     <% end %>
#
# The HTML output will be something like:
#
#     <form class="formtastic" method="post" action="...">
#       <fieldset>
#         <ol>
#           <li class="string required" id="post_title_input">
#             ...
#           </li>
#           <li class="text required" id="post_body_input">
#             ...
#           </li>
#         </ol>
#       </fieldset>
#     </form>
#
# @see #input
# @see Formtastic::Helpers::InputsHelper#inputs
# @see Formtastic::Helpers::FormHelper#semantic_form_for
module Formtastic::Helpers::InputHelper
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Helpers::Enum
  include ::Formtastic::Helpers::FileColumnDetection

  # Returns a chunk of HTML markup for a given `method` on the form object, wrapped in
  # an `<li>` wrapper tag with appropriate `class` and `id` attribute hooks for CSS and JS.
  # In many cases, the contents of the wrapper will be as simple as a `<label>` and an `<input>`:
  #
  #     <%= f.input :title, :as => :string, :required => true %>
  #
  #     <li class="string required" id="post_title_input">
  #       <label for="post_title">Title<abbr title="Required">*</abbr></label>
  #       <input type="text" name="post[title]" value="" id="post_title" required="required">
  #     </li>
  #
  # In other cases (like a series of checkboxes for a `has_many` relationship), the wrapper may
  # include more complex markup, like a nested `<fieldset>` with a `<legend>` and an `<ol>` of
  # checkbox/label pairs for each choice:
  #
  #     <%= f.input :categories, :as => :check_boxes, :collection => Category.active.ordered %>
  #
  #     <li class="check_boxes" id="post_categories_input">
  #       <fieldset>
  #         <legend>Categories</legend>
  #         <ol>
  #           <li>
  #             <label><input type="checkbox" name="post[categories][1]" value="1"> Ruby</label>
  #           </li>
  #           <li>
  #             <label><input type="checkbox" name="post[categories][2]" value="2"> Rails</label>
  #           </li>
  #           <li>
  #             <label><input type="checkbox" name="post[categories][2]" value="2"> Awesome</label>
  #           </li>
  #         </ol>
  #       </fieldset>
  #     </li>
  #
  # Sensible defaults for all options are guessed by looking at the method name, database column
  # information, association information, validation information, etc. For example, a `:string`
  # database column will map to a `:string` input, but if the method name contains 'email', will
  # map to an `:email` input instead. `belongs_to` associations will have a `:select` input, etc.
  #
  # Formtastic supports many different styles of inputs, and you can/should override the default
  # with the `:as` option. Internally, the symbol is used to map to a protected method
  # responsible for the details. For example, `:as => :string` will map to `string_input`,
  # defined in a module of the same name. Detailed documentation for each input style and it's
  # supported options is available on the `*_input` method in each module (links provided below).
  #
  # Available input styles:
  #
  # * `:boolean`          (see {Inputs::BooleanInput})
  # * `:check_boxes`      (see {Inputs::CheckBoxesInput})
  # * `:color`            (see {Inputs::ColorInput})
  # * `:country`          (see {Inputs::CountryInput})
  # * `:datetime_select`  (see {Inputs::DatetimeSelectInput})
  # * `:date_select`      (see {Inputs::DateSelectInput})
  # * `:email`            (see {Inputs::EmailInput})
  # * `:file`             (see {Inputs::FileInput})
  # * `:hidden`           (see {Inputs::HiddenInput})
  # * `:number`           (see {Inputs::NumberInput})
  # * `:password`         (see {Inputs::PasswordInput})
  # * `:phone`            (see {Inputs::PhoneInput})
  # * `:radio`            (see {Inputs::RadioInput})
  # * `:search`           (see {Inputs::SearchInput})
  # * `:select`           (see {Inputs::SelectInput})
  # * `:string`           (see {Inputs::StringInput})
  # * `:text`             (see {Inputs::TextInput})
  # * `:time_zone`        (see {Inputs::TimeZoneInput})
  # * `:time_select`      (see {Inputs::TimeSelectInput})
  # * `:url`              (see {Inputs::UrlInput})
  #
  # Calling `:as => :string` (for example) will call `#to_html` on a new instance of
  # `Formtastic::Inputs::StringInput`. Before this, Formtastic will try to instantiate a top-level
  # namespace StringInput, meaning you can subclass and modify `Formtastic::Inputs::StringInput`
  # in `app/inputs/`. This also means you can create your own new input types in `app/inputs/`.
  #
  # @example Accept all default options
  #   <%= f.input :title %>
  # @example Change the input type
  #   <%= f.input :title, :as => :string %>
  # @example Changing the label with a String
  #   <%= f.input :title, :label => "Post title" %>
  # @example Disabling the label with false, even if an i18n translation exists
  #   <%= f.input :title, :label => false  %>
  # @example Changing the hint with a String
  #   <%= f.input :title, :hint => "Every post needs a title!" %>
  # @example Disabling the hint with false, even if an i18n translation exists
  #   <%= f.input :title, :hint => false  %>
  # @example Marking a field as required or not (even if validations do not enforce it)
  #   <%= f.input :title, :required => true  %>
  #   <%= f.input :title, :required => false  %>
  # @example Changing or adding to HTML attributes in the main `<input>` or `<select>` tag
  #   <%= f.input :title, :input_html => { :onchange => "somethingAwesome();", :class => 'awesome' } %>
  # @example Changing or adding to HTML attributes in the wrapper `<li>` tag
  #   <%= f.input :title, :wrapper_html => { :class => "important-input" } %>
  # @example Changing the association choices with `:collection`
  #   <%= f.input :author,     :collection => User.active %>
  #   <%= f.input :categories, :collection => Category.where(...).order(...) %>
  #   <%= f.input :status,     :collection => ["Draft", "Published"] %>
  #   <%= f.input :status,     :collection => [:draft, :published] %>
  #   <%= f.input :status,     :collection => {"Draft" => 0, "Published" => 1} %>
  #   <%= f.input :status,     :collection => OrderedHash.new("Draft" => 0, "Published" => 1) %>
  #   <%= f.input :status,     :collection => [["Draft", 0], ["Published", 1]] %>
  #   <%= f.input :status,     :collection => grouped_options_for_select(...) %>
  #   <%= f.input :status,     :collection => options_for_select(...) %>
  # @example Specifying if a `:select` should allow multiple selections:
  #   <%= f.input :cateogies, :as => :select, :multiple => true %>
  #   <%= f.input :cateogies, :as => :select, :multiple => false %>
  # @example Specifying if a `:select` should have a 'blank' first option to prompt selection:
  #   <%= f.input :author, :as => :select, :include_blank => true %>
  #   <%= f.input :author, :as => :select, :include_blank => false %>
  # @example Specifying the text for a `:select` input's 'blank' first option to prompt selection:
  #   <%= f.input :author, :as => :select, :prompt => "Select an Author" %>
  # @example Modifying an input to suit your needs in `app/inputs`:
  #   class StringInput < Formtastic::Inputs::StringInput
  #   def to_html
  #   puts "this is my custom version of StringInput"
  #   super
  #   end
  #   end
  # @example Creating your own input to suit your needs in `app/inputs`:
  #   class DatePickerInput
  #   include Formtastic::Inputs::Base
  #   def to_html
  #   # ...
  #   end
  #   end
  # @example Providing HTML5 placeholder text through i18n:
  #   en:
  #   formtastic:
  #   placeholders:
  #   user:
  #   email: "you@yours.com"
  #   first_name: "Joe"
  #   last_name: "Smith"
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param method [Symbol] The database column or method name on the form object that this input represents
  # @param options [Hash] a customizable set of options
  # @see #namespaced_input_class
  # @todo document the "guessing" of input style
  # @todo Can we deprecate & kill `:label`, `:hint` & `:prompt`? All strings could be shifted to i18n!
  # @todo Many many more examples. Some of the detail probably needs to be pushed out to the relevant methods too.
  # @todo More i18n examples.
  def input(method, options = T.unsafe(nil)); end

  protected

  # Get a column object for a specified attribute method - if possible.
  #
  # @return [ActiveModel::Type::Value, #type] in case of rails 5 attributes api
  # @return [ActiveRecord::ConnectionAdapters::Column] in case of rails 4
  def column_for(method); end

  # First try if we can detect special things like :file. With CarrierWave the method does have
  # an underlying column so we don't want :string to get selected.
  #
  # For methods that have a database column, take a best guess as to what the input method
  # should be.  In most cases, it will just return the column type (eg :string), but for special
  # cases it will simplify (like the case of :integer, :float & :decimal to :number), or do
  # something different (like :password and :select).
  #
  # If there is no column for the method (eg "virtual columns" with an attr_accessor), the
  # default is a :string, a similar behaviour to Rails' scaffolding.
  def default_input_type(method, options = T.unsafe(nil)); end

  # Takes the `:as` option and attempts to return the corresponding input
  # class. In the case of `:as => :awesome` it will first attempt to find a
  # top level `AwesomeInput` class (to allow the application to subclass
  # and modify to suit), falling back to `Formtastic::Inputs::AwesomeInput`.
  #
  # Custom input namespaces to look into can be configured via the
  # {Formtastic::FormBuilder.input_namespaces} configuration setting.
  #
  # @example Normal use
  #   input_class(:string) #=> Formtastic::Inputs::StringInput
  #   input_class(:date) #=> Formtastic::Inputs::DateInput
  # @example When a top-level class is found
  #   input_class(:string) #=> StringInput
  #   input_class(:awesome) #=> AwesomeInput
  # @param as [Symbol] A symbol representing the type of input to render
  # @raise [Formtastic::UnknownInputError] An appropriate input class could not be found
  # @return [Class] An input class constant
  # @see NamespacedClassFinder#find
  def namespaced_input_class(as); end
end

# {#inputs} is used to wrap a series of form items in a `<fieldset>` and `<ol>`, with each item
# in the list containing the markup representing a single {#input}.
#
# {#inputs} is usually called with a block containing a series of {#input} methods:
#
#     <%= semantic_form_for @post do |f| %>
#       <%= f.inputs do %>
#         <%= f.input :title %>
#         <%= f.input :body %>
#       <% end %>
#     <% end %>
#
# The HTML output will be something like:
#
#     <form class="formtastic" method="post" action="...">
#       <fieldset>
#         <ol>
#           <li class="string required" id="post_title_input">
#             ...
#           </li>
#           <li class="text required" id="post_body_input">
#             ...
#           </li>
#         </ol>
#       </fieldset>
#     </form>
#
# It's important to note that the `semantic_form_for` and {#inputs} blocks wrap the
# standard Rails `form_for` helper and FormBuilder, so you have full access to every standard
# Rails form helper, with any HTML markup and ERB syntax, allowing you to "break free" from
# Formtastic when it doesn't suit:
#
#     <%= semantic_form_for @post do |f| %>
#       <%= f.inputs do %>
#         <%= f.input :title %>
#         <li>
#           <%= f.text_area :body %>
#         <li>
#       <% end %>
#     <% end %>
#
# @see Formtastic::Helpers::InputHelper#input
module Formtastic::Helpers::InputsHelper
  include ::Formtastic::Helpers::FieldsetWrapper
  include ::Formtastic::LocalizedString

  # {#inputs} creates an input fieldset and ol tag wrapping for use around a set of inputs.  It can be
  # called either with a block (in which you can do the usual Rails form stuff, HTML, ERB, etc),
  # or with a list of fields (accepting all default arguments and options). These two examples
  # are functionally equivalent:
  #
  #     # With a block:
  #     <% semantic_form_for @post do |form| %>
  #       <% f.inputs do %>
  #         <%= f.input :title %>
  #         <%= f.input :body %>
  #       <% end %>
  #     <% end %>
  #
  #     # With a list of fields (short hand syntax):
  #     <% semantic_form_for @post do |form| %>
  #       <%= f.inputs :title, :body %>
  #     <% end %>
  #
  #     # Output:
  #     <form ...>
  #       <fieldset class="inputs">
  #         <ol>
  #           <li class="string">...</li>
  #           <li class="text">...</li>
  #         </ol>
  #       </fieldset>
  #     </form>
  #
  # **Quick Forms**
  #
  # Quick, scaffolding-style forms can be easily rendered for rapid early development if called
  # without a block or a field list. In the case an input is rendered for **most** columns in
  # the model's database table (like Rails' scaffolding) plus inputs for some model associations.
  #
  # In this case, all inputs are rendered with default options and arguments. You'll want more
  # control than this in a production application, but it's a great way to get started, then
  # come back later to customise the form with a field list or a block of inputs.  Example:
  #
  #     <% semantic_form_for @post do |form| %>
  #       <%= f.inputs %>
  #     <% end %>
  #
  # **Nested Attributes**
  #
  # One of the most complicated parts of Rails forms comes when nesting the inputs for
  # attrinbutes on associated models. Formtastic can take the pain away for many (but not all)
  # situations.
  #
  # Given the following models:
  #
  #     # Models
  #     class User < ActiveRecord::Base
  #       has_one :profile
  #       accepts_nested_attributes_for :profile
  #     end
  #     class Profile < ActiveRecord::Base
  #       belongs_to :user
  #     end
  #
  # Formtastic provides a helper called `semantic_fields_for`, which wraps around Rails' built-in
  # `fields_for` helper for backwards compatibility with previous versions of Formtastic, and for
  # a consistent method naming API. The following examples are functionally equivalent:
  #
  #     <% semantic_form_for @user do |form| %>
  #       <%= f.inputs :name, :email %>
  #
  #       <% f.semantic_fields_for :profile do |profile| %>
  #         <% profile.inputs do %>
  #           <%= profile.input :biography %>
  #           <%= profile.input :twitter_name %>
  #         <% end %>
  #       <% end %>
  #     <% end %>
  #
  #     <% semantic_form_for @user do |form| %>
  #       <%= f.inputs :name, :email %>
  #
  #       <% f.fields_for :profile do |profile| %>
  #         <% profile.inputs do %>
  #           <%= profile.input :biography %>
  #           <%= profile.input :twitter_name %>
  #         <% end %>
  #       <% end %>
  #     <% end %>
  #
  # {#inputs} also provides a DSL similar to `fields_for` / `semantic_fields_for` to reduce the
  # lines of code a little:
  #
  #     <% semantic_form_for @user do |f| %>
  #       <%= f.inputs :name, :email %>
  #
  #       <% f.inputs :for => :profile do %>
  #         <%= profile.input :biography %>
  #         <%= profile.input :twitter_name %>
  #         <%= profile.input :shoe_size %>
  #       <% end %>
  #     <% end %>
  #
  # The `:for` option also works with short hand syntax:
  #
  #     <% semantic_form_for @post do |form| %>
  #       <%= f.inputs :name, :email %>
  #       <%= f.inputs :biography, :twitter_name, :shoe_size, :for => :profile %>
  #     <% end %>
  #
  # {#inputs} will always create a new `<fieldset>` wrapping, so only use it when it makes sense
  # in the document structure and semantics (using `semantic_fields_for` otherwise).
  #
  # All options except `:name`, `:title` and `:for` will be passed down to the fieldset as HTML
  # attributes (id, class, style, etc).
  #
  # When nesting `inputs()` inside another `inputs()` block, the nested content will
  # automatically be wrapped in an `<li>` tag to preserve the HTML validity (a `<fieldset>`
  # cannot be a direct descendant of an `<ol>`.
  #
  # @example Quick form: Render a scaffold-like set of inputs for automatically guessed attributes and simple associations on the model, with all default arguments and options
  #   <% semantic_form_for @post do |form| %>
  #   <%= f.inputs %>
  #   <% end %>
  # @example Quick form: Skip one or more fields
  #   <%= f.inputs :except => [:featured, :something_for_admin_only] %>
  #   <%= f.inputs :except => :featured %>
  # @example Short hand: Render inputs for a named set of attributes and simple associations on the model, with all default arguments and options
  #   <% semantic_form_for @post do |form| %>
  #   <%= f.inputs :title, :body, :user, :categories %>
  #   <% end %>
  # @example Block: Render inputs for attributes and simple associations with full control over arguments and options
  #   <% semantic_form_for @post do |form| %>
  #   <%= f.inputs do %>
  #   <%= f.input :title ... %>
  #   <%= f.input :body ... %>
  #   <%= f.input :user ... %>
  #   <%= f.input :categories ... %>
  #   <% end %>
  #   <% end %>
  # @example Multiple blocks: Render inputs in multiple fieldsets
  #   <% semantic_form_for @post do |form| %>
  #   <%= f.inputs do %>
  #   <%= f.input :title ... %>
  #   <%= f.input :body ... %>
  #   <% end %>
  #   <%= f.inputs do %>
  #   <%= f.input :user ... %>
  #   <%= f.input :categories ... %>
  #   <% end %>
  #   <% end %>
  # @example Provide text for the `<legend>` to name a fieldset (with a block)
  #   <% semantic_form_for @post do |form| %>
  #   <%= f.inputs :name => 'Write something:' do %>
  #   <%= f.input :title ... %>
  #   <%= f.input :body ... %>
  #   <% end %>
  #   <%= f.inputs :name => 'Advanced options:' do %>
  #   <%= f.input :user ... %>
  #   <%= f.input :categories ... %>
  #   <% end %>
  #   <% end %>
  # @example Provide text for the `<legend>` to name a fieldset (with short hand)
  #   <% semantic_form_for @post do |form| %>
  #   <%= f.inputs :title, :body, :name => 'Write something:'%>
  #   <%= f.inputs :user, :cateogies, :name => 'Advanced options:' %>
  #   <% end %>
  # @example Inputs for nested attributes (don't forget `accepts_nested_attributes_for` in your model, see Rails' `fields_for` documentation)
  #   <% semantic_form_for @user do |form| %>
  #   <%= f.inputs do %>
  #   <%= f.input :name ... %>
  #   <%= f.input :email ... %>
  #   <% end %>
  #   <%= f.inputs :for => :profile do |profile| %>
  #   <%= profile.input :user ... %>
  #   <%= profile.input :categories ... %>
  #   <% end %>
  #   <% end %>
  # @example Inputs for nested record (don't forget `accepts_nested_attributes_for` in your model, see Rails' `fields_for` documentation)
  #   <% semantic_form_for @user do |form| %>
  #   <%= f.inputs do %>
  #   <%= f.input :name ... %>
  #   <%= f.input :email ... %>
  #   <% end %>
  #   <%= f.inputs :for => @user.profile do |profile| %>
  #   <%= profile.input :user ... %>
  #   <%= profile.input :categories ... %>
  #   <% end %>
  #   <% end %>
  # @example Inputs for nested record with a different name (don't forget `accepts_nested_attributes_for` in your model, see Rails' `fields_for` documentation)
  #   <% semantic_form_for @user do |form| %>
  #   <%= f.inputs do %>
  #   <%= f.input :name ... %>
  #   <%= f.input :email ... %>
  #   <% end %>
  #   <%= f.inputs :for => [:user_profile, @user.profile] do |profile| %>
  #   <%= profile.input :user ... %>
  #   <%= profile.input :categories ... %>
  #   <% end %>
  #   <% end %>
  # @example Nesting {#inputs} blocks requires an extra `<li>` tag for valid markup
  #   <% semantic_form_for @user do |form| %>
  #   <%= f.inputs do %>
  #   <%= f.input :name ... %>
  #   <%= f.input :email ... %>
  #   <li>
  #   <%= f.inputs :for => [:user_profile, @user.profile] do |profile| %>
  #   <%= profile.input :user ... %>
  #   <%= profile.input :categories ... %>
  #   <% end %>
  #   </li>
  #   <% end %>
  #   <% end %>
  # @option *args
  # @option *args
  # @option *args
  # @param *args [Hash] a customizable set of options
  def inputs(*args, &block); end

  protected

  # Collects association columns (relation columns) for the current form object class. Skips
  # polymorphic associations because we can't guess which class to use for an automatically
  # generated input.
  def association_columns(*by_associations); end

  # Collects content columns (non-relation columns) for the current form object class.
  def content_columns; end

  def default_columns_for_object; end

  # @private
  def field_set_title_from_args(*args); end

  def fieldset_contents_from_column_list(columns); end

  # Collects all foreign key columns
  def foreign_key_columns; end

  # Deals with :for option when it's supplied to inputs methods. Additional
  # options to be passed down to :for should be supplied using :for_options
  # key.
  #
  # It should raise an error if a block with arity zero is given.
  def inputs_for_nested_attributes(*args, &block); end
end

# @private
module Formtastic::Helpers::Reflection
  # @private
  def association_macro_for_method(method); end

  # @private
  def association_primary_key_for_method(method); end

  # If an association method is passed in (f.input :author) try to find the
  # reflection object.
  def reflection_for(method); end
end

# @private
module Formtastic::HtmlAttributes
  # Returns a namespace passed by option or inherited from parent builders / class configuration
  def dom_id_namespace; end

  protected

  def humanized_attribute_name(method); end
end

# @private
module Formtastic::I18n
  class << self
    def t(*args); end
    def translate(*args); end
  end
end

Formtastic::I18n::DEFAULT_SCOPE = T.let(T.unsafe(nil), Array)
Formtastic::I18n::DEFAULT_VALUES = T.let(T.unsafe(nil), Hash)
Formtastic::I18n::SCOPES = T.let(T.unsafe(nil), Array)

# Uses the {Formtastic::NamespacedClassFinder} to look up input class names.
#
# See {Formtastic::FormBuilder#namespaced_input_class} for details.
class Formtastic::InputClassFinder < ::Formtastic::NamespacedClassFinder
  # @param builder [FormBuilder]
  # @return [InputClassFinder] a new instance of InputClassFinder
  def initialize(builder); end

  def class_name(as); end
end

module Formtastic::Inputs
  extend ::ActiveSupport::Autoload
end

module Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  extend ::ActiveSupport::Autoload

  def initialize(builder, template, object, object_name, method, options); end

  # Returns the value of attribute builder.
  def builder; end

  # Sets the attribute builder
  #
  # @param value the value to set the attribute builder to.
  def builder=(_arg0); end

  def input_wrapping(&block); end

  # Returns the value of attribute method.
  def method; end

  # Sets the attribute method
  #
  # @param value the value to set the attribute method to.
  def method=(_arg0); end

  # Returns the value of attribute object.
  def object; end

  # Sets the attribute object
  #
  # @param value the value to set the attribute object to.
  def object=(_arg0); end

  # Returns the value of attribute object_name.
  def object_name; end

  # Sets the attribute object_name
  #
  # @param value the value to set the attribute object_name to.
  def object_name=(_arg0); end

  # Returns the value of attribute options.
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  def options=(_arg0); end

  # Usefull for raising an error on previously supported option.
  #
  # @raise [ArgumentError]
  def removed_option!(old_option_name); end

  # Returns the value of attribute template.
  def template; end

  # Sets the attribute template
  #
  # @param value the value to set the attribute template to.
  def template=(_arg0); end

  # Usefull for deprecating options.
  def warn_and_correct_option!(old_option_name, new_option_name); end

  # Usefull for deprecating options.
  def warn_deprecated_option!(old_option_name, instructions); end
end

module Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection

  # :belongs_to, etc
  def association; end

  def association_primary_key; end

  # @return [Boolean]
  def belongs_to?; end

  # @return [Boolean]
  def has_many?; end

  def reflection; end
end

module Formtastic::Inputs::Base::Choices
  def choice_html(choice); end
  def choice_html_options(choice); end
  def choice_html_safe_value(choice); end
  def choice_input_dom_id(choice); end
  def choice_label(choice); end
  def choice_value(choice); end
  def choice_wrapping(html_options, &block); end
  def choice_wrapping_html_options(choice); end
  def choices_group_wrapping(&block); end
  def choices_group_wrapping_html_options; end
  def choices_wrapping(&block); end
  def choices_wrapping_html_options; end
  def custom_choice_html_options(choice); end
  def default_choice_html_options(choice); end

  # Override to remove the for attribute since this isn't associated with any element, as it's
  # nested inside the legend.
  def label_html_options; end

  def legend_html; end

  # @return [Boolean]
  def value_as_class?; end
end

module Formtastic::Inputs::Base::Collections
  def collection; end
  def collection_for_boolean; end
  def collection_from_association; end

  # Assuming the following model:
  #
  # class Post < ActiveRecord::Base
  #   enum :status => [ :active, :archived ]
  # end
  #
  # We would end up with a collection like this:
  #
  # [["Active", "active"], ["Archived", "archived"]
  #
  # The first element in each array uses String#humanize, but I18n
  # translations are available too. Set them with the following structure.
  #
  # en:
  #   activerecord:
  #     attributes:
  #       post:
  #         statuses:
  #           active: Custom Active Label Here
  #           archived: Custom Archived Label Here
  def collection_from_enum; end

  # @return [Boolean]
  def collection_from_enum?; end

  def collection_from_options; end
  def label_and_value_method; end
  def label_and_value_method_from_collection(_collection); end
  def label_method; end
  def label_method_from_options; end
  def raw_collection; end
  def send_or_call(duck, object); end

  # Avoids an issue where `send_or_call` can be a String and duck can be something simple like
  # `:first`, which obviously String responds to.
  def send_or_call_or_object(duck, object); end

  def value_method; end
  def value_method_from_options; end
end

module Formtastic::Inputs::Base::Database
  def column; end

  # @return [Boolean]
  def column?; end
end

module Formtastic::Inputs::Base::DatetimePickerish
  include ::Formtastic::Inputs::Base::Placeholder

  def default_maxlength; end

  # @raise [NotImplementedError]
  def default_size; end

  def default_step; end
  def extra_input_html_options; end

  # @raise [NotImplementedError]
  def html_input_type; end

  def input_html_options; end
  def maxlength; end
  def size; end
  def step; end

  # @raise [NotImplementedError]
  def value; end

  protected

  def step_from_macro(sym); end
end

module Formtastic::Inputs::Base::Errors
  def error_first_html; end
  def error_html; end
  def error_keys; end
  def error_list_html; end
  def error_none_html; end
  def error_sentence_html; end
  def errors; end

  # @return [Boolean]
  def errors?; end
end

module Formtastic::Inputs::Base::Fileish
  # @return [Boolean]
  def file?; end
end

module Formtastic::Inputs::Base::Hints
  # @return [Boolean]
  def hint?; end

  def hint_html; end
  def hint_text; end
  def hint_text_from_options; end
end

module Formtastic::Inputs::Base::Html
  def dom_id; end
  def dom_index; end
  def input_html_options; end

  # Defines how the instance of an input should be rendered to a HTML string.
  #
  # @abstract Implement this method in your input class to describe how the input should render itself.
  # @example A basic label and text field input inside a standard wrapping might look like this:
  #   def to_html
  #   input_wrapping do
  #   label_html <<
  #   builder.text_field(method, input_html_options)
  #   end
  #   end
  # @raise [NotImplementedError]
  def to_html; end
end

module Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString

  def label_from_options; end
  def label_html; end
  def label_html_options; end
  def label_text; end
  def localized_label; end

  # @return [Boolean]
  def render_label?; end

  def requirement_text; end

  # TODO: why does this need to be memoized in order to make the inputs_spec tests pass?
  def requirement_text_or_proc; end
end

module Formtastic::Inputs::Base::Naming
  def as; end
  def attributized_method_name; end
  def humanized_method_name; end
  def input_name; end
  def sanitized_method_name; end
  def sanitized_object_name; end
end

module Formtastic::Inputs::Base::Numeric
  def in_option; end
  def input_html_options; end
  def max_option; end
  def min_option; end
  def step_option; end
  def wrapper_html_options; end
end

module Formtastic::Inputs::Base::Options
  def formtastic_options; end
  def input_options; end
end

module Formtastic::Inputs::Base::Placeholder
  def input_html_options; end
  def placeholder_text; end
end

module Formtastic::Inputs::Base::Stringish
  # Overrides standard `input_html_options` to provide a `maxlength` and `size` attribute.
  def input_html_options; end

  def maxlength; end
  def size; end

  # @abstract Override this method in your input class to describe how the input should render itself.
  def to_html; end

  def wrapper_html_options; end
end

# Timeish inputs (`:date_select`, `:datetime_select`, `:time_select`) are similar to the Rails date and time
# helpers (`date_select`, `datetime_select`, `time_select`), rendering a series of `<select>`
# tags for each fragment (year, month, day, hour, minute, seconds). The fragments are then
# re-combined to a date by ActiveRecord through multi-parameter assignment.
#
# The mark-up produced by Rails is simple but far from ideal, with no way to label the
# individual fragments for accessibility, no fieldset to group the related fields, and no
# legend describing the group. Formtastic addresses this within the standard `<li>` wrapper
# with a `<fieldset>` with a `<legend>` as a label, followed by an ordered list (`<ol>`) of
# list items (`<li>`), one for each fragment (year, month, ...). Each `<li>` fragment contains
# a `<label>` (eg "Year") for the fragment, and a `<select>` containing `<option>`s (eg a
# range of years).
#
# In the supplied formtastic.css file, the resulting mark-up is styled to appear a lot like a
# standard Rails date time select by:
#
# * styling the legend to look like the other labels (to the left hand side of the selects)
# * floating the `<li>` fragments against each other as a single line
# * hiding the `<label>` of each fragment with `display:none`
#
# @example `:date_select` input with full form context and sample HTMl output
#
#   <%= semantic_form_for(@post) do |f| %>
#   <%= f.inputs do %>
#   ...
#   <%= f.input :publish_at, :as => :date_select %>
#   <% end %>
#   <% end %>
#
#   <form...>
#   <fieldset class="inputs">
#   <ol>
#   <li class="date">
#   <fieldset class="fragments">
#   <ol class="fragments-group">
#   <li class="fragment">
#   <label for="post_publish_at_1i">Year</label>
#   <select id="post_publish_at_1i" name="post[publish_at_1i]">...</select>
#   </li>
#   <li class="fragment">
#   <label for="post_publish_at_2i">Month</label>
#   <select id="post_publish_at_2i" name="post[publish_at_2i]">...</select>
#   </li>
#   <li class="fragment">
#   <label for="post_publish_at_3i">Day</label>
#   <select id="post_publish_at_3i" name="post[publish_at_3i]">...</select>
#   </li>
#   </ol>
#   </fieldset>
#   </li>
#   </ol>
#   </fieldset>
#   </form>
# @example `:time_select` input
#   <%= f.input :publish_at, :as => :time_select %>
# @example `:datetime_select` input
#   <%= f.input :publish_at, :as => :datetime_select %>
# @example Change the labels for each fragment
#   <%= f.input :publish_at, :as => :date_select, :labels => { :year => "Y", :month => "M", :day => "D" }  %>
# @example Suppress the labels for all fragments
#   <%= f.input :publish_at, :as => :date_select, :labels => false  %>
# @example Skip a fragment (defaults to 1, skips all following fragments)
#   <%= f.input :publish_at, :as => :datetime_select, :discard_minute => true  %>
#   <%= f.input :publish_at, :as => :datetime_select, :discard_hour => true  %>
#   <%= f.input :publish_at, :as => :datetime_select, :discard_day => true  %>
#   <%= f.input :publish_at, :as => :datetime_select, :discard_month => true  %>
#   <%= f.input :publish_at, :as => :datetime_select, :discard_year => true  %>
# @example Change the order
#   <%= f.input :publish_at, :as => :date_select, :order => [:month, :day, :year]  %>
# @example Include seconds with times (excluded by default)
#   <%= f.input :publish_at, :as => :time_select, :include_seconds => true %>
# @example Specify if there should be a blank option at the start of each select or not. Note that, unlike select inputs, :include_blank does not accept a string value.
#   <%= f.input :publish_at, :as => :time_select, :include_blank => true %>
#   <%= f.input :publish_at, :as => :time_select, :include_blank => false %>
# @example Provide a value for the field via selected
#   <%= f.input :publish_at, :as => :datetime_select, :selected => DateTime.new(2018, 10, 4, 12, 00)
# @todo Document i18n
# @todo Check what other Rails options are supported (`start_year`, `end_year`, `use_month_numbers`, `use_short_month`, `add_month_numbers`, `prompt`), write tests for them, and otherwise support them
# @todo Could we take the rendering from Rails' helpers and inject better HTML in and around it rather than re-inventing the whee?
module Formtastic::Inputs::Base::Timeish
  def date_fragments; end
  def default_date_fragments; end
  def fragment_id(fragment); end
  def fragment_input_html(fragment); end
  def fragment_label(fragment); end
  def fragment_label_html(fragment); end
  def fragment_name(fragment); end
  def fragment_prefix; end
  def fragment_wrapping(&block); end
  def fragment_wrapping_html_options; end
  def fragments; end
  def fragments_inner_wrapping(&block); end
  def fragments_label; end
  def fragments_wrapping(&block); end
  def fragments_wrapping_html_options; end
  def hidden_field_name(fragment); end
  def hidden_fragments; end
  def i18n_date_fragments; end

  # TODO extract to BlankOptions or similar -- Select uses similar code
  #
  # @return [Boolean]
  def include_blank?; end

  def position(fragment); end
  def positions; end
  def time_fragments; end
  def to_html; end
  def value; end
end

module Formtastic::Inputs::Base::Validations
  # @return [Boolean]
  def autofocus?; end

  def column_limit; end
  def limit; end
  def not_required_through_negated_validation!; end

  # @return [Boolean]
  def not_required_through_negated_validation?; end

  # @return [Boolean]
  def optional?; end

  # @return [Boolean]
  def readonly?; end

  # @return [Boolean]
  def readonly_attribute?; end

  # @return [Boolean]
  def readonly_from_options?; end

  # @return [Boolean]
  def required?; end

  # @return [Boolean]
  def required_attribute?; end

  # @return [Boolean]
  def responds_to_global_required?; end

  # @return [Boolean]
  def validation_integer_only?; end

  def validation_limit; end

  # Prefer :less_than_or_equal_to over :less_than, for no particular reason.
  def validation_max; end

  # Prefer :greater_than_or_equal_to over :greater_than, for no particular reason.
  def validation_min; end

  def validation_step; end
  def validations; end

  # @return [Boolean]
  def validations?; end

  # @return [Boolean]
  def validator_relevant?(validator); end

  private

  # Loosely based on
  # https://github.com/rails/rails/blob/5-2-stable/activemodel/lib/active_model/validations/numericality.rb#L54-L59
  def option_value(option, object); end
end

class Formtastic::Inputs::Base::Validations::IndeterminableMaximumAttributeError < ::ArgumentError
  def message; end
end

class Formtastic::Inputs::Base::Validations::IndeterminableMinimumAttributeError < ::ArgumentError
  def message; end
end

# @todo relies on `dom_id`, `required?`, `optional`, `errors?`, `association_primary_key` & `sanitized_method_name` methods from another module
module Formtastic::Inputs::Base::Wrapping
  # Override this method if you want to change the display order (for example, rendering the
  # errors before the body of the input).
  def input_wrapping(&block); end

  def wrapper_classes; end
  def wrapper_classes_raw; end
  def wrapper_dom_id; end
  def wrapper_html_options; end
  def wrapper_html_options_raw; end
end

# Boolean inputs are used to render an input for a single checkbox, typically for attributes
# with a simple yes/no or true/false value. Boolean inputs are used by default for boolean
# database columns.
#
# @example Full form context and markup
#   <%= semantic_form_for @post %>
#   <%= f.inputs do %>
#   <%= f.input :published, :as => :boolean %>
#   <% end %>
#   <% end %>
#
#   <form...>
#   <fieldset>
#   <ol>
#   <li class="boolean" id="post_published_input">
#   <input type="hidden" name="post[published]" id="post_published" value="0">
#   <label for="post_published">
#   <input type="checkbox" name="post[published]" id="post_published" value="1">
#   Published?
#   </label>
#   </li>
#   </ol>
#   </fieldset>
#   </form>
# @example Set the values for the checked and unchecked states
#   <%= f.input :published, :checked_value => "yes", :unchecked_value => "no" %>
# @see Formtastic::Helpers::InputsHelper#input InputsHelper#input for full documentation of all possible options.
class Formtastic::Inputs::BooleanInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base

  def check_box_html; end

  # @return [Boolean]
  def checked?; end

  def checked_value; end
  def hidden_field_html; end
  def input_html_options; end
  def input_html_options_name; end
  def label_html_options; end
  def label_text_with_embedded_checkbox; end
  def label_with_nested_checkbox; end

  # @return [Boolean]
  def responds_to_global_required?; end

  def to_html; end
  def unchecked_value; end

  private

  # @return [Boolean]
  def boolean_checked?(value, checked_value); end
end

# A CheckBoxes input is used to render a series of checkboxes. This is an alternative input choice
# for `has_many` or `has_and_belongs_to_many` associations like a `Post` belonging to many
# `categories` (by default, a {SelectInput `:select`} input is used, allowing multiple selections).
#
# Within the standard `<li>` wrapper, the output is a `<fieldset>` with a `<legend>` to
# represent the "label" for the input, and an `<ol>` containing `<li>`s for each choice in
# the association. Each `<li>` choice contains a hidden `<input>` tag for the "unchecked"
# value (like Rails), and a `<label>` containing the checkbox `<input>` and the label text
# for each choice.
#
# @example Basic example with full form context
#
#   <%= semantic_form_for @post do |f| %>
#   <%= f.inputs do %>
#   <%= f.input :categories, :as => :check_boxes %>
#   <% end %>
#   <% end %>
#
#   <li class='check_boxes'>
#   <fieldset>
#   <legend class="label"><label>Categories</label></legend>
#   <ol>
#   <li>
#   <input type="hidden" name="post[category_ids][1]" value="">
#   <label for="post_category_ids_1"><input id="post_category_ids_1" name="post[category_ids][1]" type="checkbox" value="1" /> Ruby</label>
#   </li>
#   <li>
#   <input type="hidden" name="post[category_ids][2]" value="">
#   <label for="post_category_ids_2"><input id="post_category_ids_2" name="post[category_ids][2]" type="checkbox" value="2" /> Rails</label>
#   </li>
#   </ol>
#   </fieldset>
#   </li>
# @example `:collection` can be used to customize the choices
#   <%= f.input :categories, :as => :check_boxes, :collection => @categories %>
#   <%= f.input :categories, :as => :check_boxes, :collection => Category.all %>
#   <%= f.input :categories, :as => :check_boxes, :collection => Category.some_named_scope %>
#   <%= f.input :categories, :as => :check_boxes, :collection => Category.pluck(:label, :id) %>
#   <%= f.input :categories, :as => :check_boxes, :collection => [Category.find_by_name("Ruby"), Category.find_by_name("Rails")] %>
#   <%= f.input :categories, :as => :check_boxes, :collection => ["Ruby", "Rails"] %>
#   <%= f.input :categories, :as => :check_boxes, :collection => [["Ruby", "ruby"], ["Rails", "rails"]] %>
#   <%= f.input :categories, :as => :check_boxes, :collection => [["Ruby", "1"], ["Rails", "2"]] %>
#   <%= f.input :categories, :as => :check_boxes, :collection => [["Ruby", 1], ["Rails", 2]] %>
#   <%= f.input :categories, :as => :check_boxes, :collection => [["Ruby", 1, {'data-attr' => 'attr-value'}]] %>
#   <%= f.input :categories, :as => :check_boxes, :collection => 1..5 %>
#   <%= f.input :categories, :as => :check_boxes, :collection => [:ruby, :rails] %>
#   <%= f.input :categories, :as => :check_boxes, :collection => [["Ruby", :ruby], ["Rails", :rails]] %>
#   <%= f.input :categories, :as => :check_boxes, :collection => Set.new([:ruby, :rails]) %>
# @example `:hidden_fields` can be used to skip Rails' rendering of a hidden field before every checkbox
#   <%= f.input :categories, :as => :check_boxes, :hidden_fields => false %>
# @example `:disabled` can be used to disable any checkboxes with a value found in the given Array
#   <%= f.input :categories, :as => :check_boxes, :collection => ["a", "b"], :disabled => ["a"] %>
# @example `:value_as_class` can be used to add a class to the `<li>` wrapped around each choice using the checkbox value for custom styling of each choice
#   <%= f.input :categories, :as => :check_boxes, :value_as_class => true %>
# @see Formtastic::Helpers::InputsHelper#input InputsHelper#input for full documentation of all possible options.
# @see Formtastic::Inputs::BooleanInput BooleanInput for a single checkbox for boolean (checked = true) inputs
# @todo Do/can we support the per-item HTML options like RadioInput?
class Formtastic::Inputs::CheckBoxesInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Collections
  include ::Formtastic::Inputs::Base::Choices

  # @raise [Formtastic::UnsupportedEnumCollection]
  # @return [CheckBoxesInput] a new instance of CheckBoxesInput
  def initialize(*args); end

  def check_box_with_hidden_input(choice); end
  def check_box_without_hidden_input(choice); end

  # @return [Boolean]
  def checked?(value); end

  def choice_html(choice); end

  # @return [Boolean]
  def disabled?(value); end

  def disabled_values; end
  def extra_html_options(choice); end
  def hidden_field_for_all; end

  # @return [Boolean]
  def hidden_fields_for_every?; end

  def input_name; end
  def selected_values; end
  def to_html; end
  def unchecked_value; end

  protected

  def checkbox_input(choice); end
  def make_selected_values; end
end

# Outputs a simple `<label>` with a HTML5 `<input type="color">` wrapped in the standard
# `<li>` wrapper. This is the default input choice for attributes with a name matching
# `/color/`, but can be applied to any text-like input with `:as => :color`.
#
# @example Full form context and output
#
#   <%= semantic_form_for(@user) do |f| %>
#   <%= f.inputs do %>
#   <%= f.input :color, :as => :color %>
#   <% end %>
#   <% end %>
#
#   <form...>
#   <fieldset>
#   <ol>
#   <li class="color">
#   <label for="user_color">Color</label>
#   <input type="color" id="user_color" name="user[color]">
#   </li>
#   </ol>
#   </fieldset>
#   </form>
# @see Formtastic::Helpers::InputsHelper#input InputsHelper#input for full documentation of all possible options.
class Formtastic::Inputs::ColorInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Stringish
  include ::Formtastic::Inputs::Base::Placeholder

  def to_html; end
end

# Outputs a country select input, wrapping around a regular country_select helper.
# Rails doesn't come with a `country_select` helper by default any more, so you'll need to do
# one of the following:
#
# * install the [country_select](https://github.com/stefanpenner/country_select) gem
# * install any other country_select plugin that behaves in a similar way
# * roll your own `country_select` helper with the same args and options as the Rails one
#
# Formtastic supports both 1.x and 2.x of stefanpenner/country_select, but if you're upgrading
# from 1.x, they behave quite differently, so please see their [upgrade instructions](https://github.com/stefanpenner/country_select/blob/master/UPGRADING.md).
#
# By default, Formtastic includes a handful of English-speaking countries as "priority
# countries", which can be set in the `priority_countries` configuration array in the
# formtastic.rb initializer to suit your market and user base (see README for more info on
# configuration). Additionally, it is possible to set the :priority_countries on a per-input
# basis through the `:priority_countries` option. These priority countries will be passed down
# to the `country_select` helper of your choice, and may or may not be used by the helper.
#
# @example Basic example with full form context using `priority_countries` from config
#
#   <%= semantic_form_for @user do |f| %>
#   <%= f.inputs do %>
#   <%= f.input :nationality, :as => :country %>
#   <% end %>
#   <% end %>
#
#   <li class='country'>
#   <label for="user_nationality">Country</label>
#   <select id="user_nationality" name="user[nationality]">
#   <option value="...">...</option>
#   # ...
#   </li>
# @example `:priority_countries` set on a specific input (country_select 1.x)
#
#   <%= semantic_form_for @user do |f| %>
#   <%= f.inputs do %>
#   <%= f.input :nationality, :as => :country, :priority_countries => ["Australia", "New Zealand"] %>
#   <% end %>
#   <% end %>
#
#   <li class='country'>
#   <label for="user_nationality">Country</label>
#   <select id="user_nationality" name="user[nationality]">
#   <option value="...">...</option>
#   # ...
#   </li>
# @example `:priority_countries` set on a specific input (country_select 2.x)
#
#   <%= semantic_form_for @user do |f| %>
#   <%= f.inputs do %>
#   <%= f.input :nationality, :as => :country, :priority_countries => ["AU", "NZ"] %>
#   <% end %>
#   <% end %>
#
#   <li class='country'>
#   <label for="user_nationality">Country</label>
#   <select id="user_nationality" name="user[nationality]">
#   <option value="...">...</option>
#   # ...
#   </li>
# @see Formtastic::Helpers::InputsHelper#input InputsHelper#input for full documentation of all possible options.
class Formtastic::Inputs::CountryInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base

  def priority_countries; end

  # @raise [CountrySelectPluginMissing]
  def to_html; end
end

class Formtastic::Inputs::CountryInput::CountrySelectPluginMissing < ::StandardError; end

# Outputs a label and a text field, along with a datalist tag
# datalist tag provides a list of options which drives a simple autocomplete
# on the text field. This is a HTML5 feature, more info can be found at
# {https://developer.mozilla.org/en/docs/Web/HTML/Element/datalist <datalist> at MDN}
# This input accepts a :collection option which takes data in all the usual formats accepted by
# {http://apidock.com/rails/ActionView/Helpers/FormOptionsHelper/options_for_select options_for_select}
#
# @example Input is used as follows
#   f.input :fav_book, :as => :datalist, :collection => Book.pluck(:name)
class Formtastic::Inputs::DatalistInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Stringish
  include ::Formtastic::Inputs::Base::Collections

  def data_list_html; end
  def html_id_of_datalist; end
  def input_html_options; end
  def to_html; end
end

# Outputs a simple `<label>` with a HTML5 `<input type="date">` wrapped in the standard
# `<li>` wrapper. This is an alternative to `:date_select` for `:date`, `:time`, `:datetime`
# database columns. You can use this input with `:as => :date_picker`.
#
# *Please note:* Formtastic only provides suitable markup for a date picker, but does not supply
# any additional CSS or Javascript to render calendar-style date pickers. Browsers that support
# this input type (such as Mobile Webkit and Opera on the desktop) will render a native widget.
# Browsers that don't will default to a plain text field`<input type="text">` and can be
# poly-filled with some Javascript and a UI library of your choice.
#
# @example Full form context and output
#
#   <%= semantic_form_for(@post) do |f| %>
#   <%= f.inputs do %>
#   <%= f.input :publish_at, :as => :date_picker %>
#   <% end %>
#   <% end %>
#
#   <form...>
#   <fieldset>
#   <ol>
#   <li class="string">
#   <label for="post_publish_at">First name</label>
#   <input type="date" id="post_publish_at" name="post[publish_at]">
#   </li>
#   </ol>
#   </fieldset>
#   </form>
# @example Setting the size (defaults to 10 for YYYY-MM-DD)
#   <%= f.input :publish_at, :as => :date_picker, :size => 20 %>
#   <%= f.input :publish_at, :as => :date_picker, :input_html => { :size => 20 } %>
# @example Setting the maxlength (defaults to 10 for YYYY-MM-DD)
#   <%= f.input :publish_at, :as => :date_picker, :maxlength => 20 %>
#   <%= f.input :publish_at, :as => :date_picker, :input_html => { :maxlength => 20 } %>
# @example Setting the value (defaults to YYYY-MM-DD for Date and Time objects, otherwise renders string)
#   <%= f.input :publish_at, :as => :date_picker, :input_html => { :value => "1970-01-01" } %>
# @example Setting the step attribute (defaults to 1)
#   <%= f.input :publish_at, :as => :date_picker, :step => 7 %>
#   <%= f.input :publish_at, :as => :date_picker, :input_html => { :step => 7 } %>
# @example Setting the step attribute with a macro
#   <%= f.input :publish_at, :as => :date_picker, :step => :day %>
#   <%= f.input :publish_at, :as => :date_picker, :step => :week %>
#   <%= f.input :publish_at, :as => :date_picker, :step => :seven_days %>
#   <%= f.input :publish_at, :as => :date_picker, :step => :fortnight %>
#   <%= f.input :publish_at, :as => :date_picker, :step => :two_weeks %>
#   <%= f.input :publish_at, :as => :date_picker, :step => :four_weeks %>
#   <%= f.input :publish_at, :as => :date_picker, :step => :thirty_days %>
# @example Setting the min attribute
#   <%= f.input :publish_at, :as => :date_picker, :min => "2012-01-01" %>
#   <%= f.input :publish_at, :as => :date_picker, :input_html => { :min => "2012-01-01" } %>
# @example Setting the max attribute
#   <%= f.input :publish_at, :as => :date_picker, :max => "2012-12-31" %>
#   <%= f.input :publish_at, :as => :date_picker, :input_html => { :max => "2012-12-31" } %>
# @example Setting the placeholder attribute
#   <%= f.input :publish_at, :as => :date_picker, :placeholder => 20 %>
#   <%= f.input :publish_at, :as => :date_picker, :input_html => { :placeholder => "YYYY-MM-DD" } %>
# @see Formtastic::Helpers::InputsHelper#input InputsHelper#input for full documentation of all possible options.
class Formtastic::Inputs::DatePickerInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Stringish
  include ::Formtastic::Inputs::Base::Placeholder
  include ::Formtastic::Inputs::Base::DatetimePickerish

  def default_size; end
  def html_input_type; end
  def value; end
end

# Outputs a series of select boxes for the fragments that make up a date (year, month, day).
#
# @see Formtastic::Inputs::Base::Timeish Timeish module for documentation of date, time and datetime input options.
class Formtastic::Inputs::DateSelectInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Timeish

  def fragment_value(fragment); end
  def hidden_date_fragments; end
  def hidden_fragments; end

  # We don't want hour and minute fragments on a date input
  def time_fragments; end
end

# Outputs a simple `<label>` with a HTML5 `<input type="datetime-local">` (or
# `<input type="datetime">`) wrapped in the standard `<li>` wrapper. This is an alternative to
# `:date_select` for `:date`, `:time`, `:datetime` database columns. You can use this input with
# `:as => :datetime_picker`.
#
# *Please note:* Formtastic only provides suitable markup for a date picker, but does not supply
# any additional CSS or Javascript to render calendar-style date pickers. Browsers that support
# this input type (such as Mobile Webkit and Opera on the desktop) will render a native widget.
# Browsers that don't will default to a plain text field`<input type="text">` and can be
# poly-filled with some Javascript and a UI library of your choice.
#
# @example Full form context and output
#
#   <%= semantic_form_for(@post) do |f| %>
#   <%= f.inputs do %>
#   <%= f.input :publish_at, :as => :datetime_picker %>
#   <% end %>
#   <% end %>
#
#   <form...>
#   <fieldset>
#   <ol>
#   <li class="string">
#   <label for="post_publish_at">First name</label>
#   <input type="date" id="post_publish_at" name="post[publish_at]">
#   </li>
#   </ol>
#   </fieldset>
#   </form>
# @example Setting the size (defaults to 16 for YYYY-MM-DD HH:MM)
#   <%= f.input :publish_at, :as => :datetime_picker, :size => 20 %>
#   <%= f.input :publish_at, :as => :datetime_picker, :input_html => { :size => 20 } %>
# @example Setting the maxlength (defaults to 16 for YYYY-MM-DD HH:MM)
#   <%= f.input :publish_at, :as => :datetime_picker, :maxlength => 20 %>
#   <%= f.input :publish_at, :as => :datetime_picker, :input_html => { :maxlength => 20 } %>
# @example Setting the value (defaults to YYYY-MM-DD HH:MM for Date and Time objects, otherwise renders string)
#   <%= f.input :publish_at, :as => :datetime_picker, :input_html => { :value => "1970-01-01 00:00" } %>
# @example Setting the step attribute (defaults to 1)
#   <%= f.input :publish_at, :as => :datetime_picker, :step => 60 %>
#   <%= f.input :publish_at, :as => :datetime_picker, :input_html => { :step => 60 } %>
# @example Setting the step attribute with a macro
#   <%= f.input :publish_at, :as => :datetime_picker, :step => :second %>
#   <%= f.input :publish_at, :as => :datetime_picker, :step => :minute %>
#   <%= f.input :publish_at, :as => :datetime_picker, :step => :quarter_hour %>
#   <%= f.input :publish_at, :as => :datetime_picker, :step => :fifteen_minutes %>
#   <%= f.input :publish_at, :as => :datetime_picker, :step => :half_hour %>
#   <%= f.input :publish_at, :as => :datetime_picker, :step => :thirty_minutes %>
#   <%= f.input :publish_at, :as => :datetime_picker, :step => :hour %>
#   <%= f.input :publish_at, :as => :datetime_picker, :step => :sixty_minutes %>
# @example Setting the min attribute
#   <%= f.input :publish_at, :as => :datetime_picker, :min => "2012-01-01 09:00" %>
#   <%= f.input :publish_at, :as => :datetime_picker, :input_html => { :min => "2012-01-01 09:00" } %>
# @example Setting the max attribute
#   <%= f.input :publish_at, :as => :datetime_picker, :max => "2012-12-31 16:00" %>
#   <%= f.input :publish_at, :as => :datetime_picker, :input_html => { :max => "2012-12-31 16:00" } %>
# @example Setting the placeholder attribute
#   <%= f.input :publish_at, :as => :datetime_picker, :placeholder => "YYYY-MM-DD HH:MM" %>
#   <%= f.input :publish_at, :as => :datetime_picker, :input_html => { :placeholder => "YYYY-MM-DD HH:MM" } %>
# @example Using `type=datetime-local` with `:local` option (this is the default, and recommended for browser support on iOS7 and Chrome)
#   <%= f.input :publish_at, :as => :datetime_picker, :local => true %>
# @example Using `type=datetime` with `:local` option (not recommended)
#   <%= f.input :publish_at, :as => :datetime_picker, :local => false %>
# @see Formtastic::Helpers::InputsHelper#input InputsHelper#input for full documentation of all possible options.
class Formtastic::Inputs::DatetimePickerInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Stringish
  include ::Formtastic::Inputs::Base::Placeholder
  include ::Formtastic::Inputs::Base::DatetimePickerish

  def default_size; end
  def html_input_type; end
  def value; end
end

# Outputs a series of select boxes for the fragments that make up a date and time (year, month, day, hour, minute, second).
#
# @see Formtastic::Inputs::Base::Timeish Timeish module for documentation of date, time and datetime input options.
class Formtastic::Inputs::DatetimeSelectInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Timeish
end

# Outputs a simple `<label>` with a HTML5 `<input type="email">` wrapped in the standard
# `<li>` wrapper. This is the default input choice for attributes with a name matching
# `/email/`, but can be applied to any text-like input with `:as => :email`.
#
# @example Full form context and output
#
#   <%= semantic_form_for(@user) do |f| %>
#   <%= f.inputs do %>
#   <%= f.input :email_address, :as => :email %>
#   <% end %>
#   <% end %>
#
#   <form...>
#   <fieldset>
#   <ol>
#   <li class="email">
#   <label for="user_email_address">Email address</label>
#   <input type="email" id="user_email_address" name="user[email_address]">
#   </li>
#   </ol>
#   </fieldset>
#   </form>
# @see Formtastic::Helpers::InputsHelper#input InputsHelper#input for full documentation of all possible options.
class Formtastic::Inputs::EmailInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Stringish
  include ::Formtastic::Inputs::Base::Placeholder

  def to_html; end
end

# Outputs a simple `<label>` with a `<input type="file">` wrapped in the standard
# `<li>` wrapper. This is the default input choice for objects with attributes that appear
# to be for file uploads, by detecting some common method names used by popular file upload
# libraries such as Paperclip and CarrierWave. You can add to or alter these method names
# through the `file_methods` config, but can be applied to any input with `:as => :file`.
#
# Don't forget to set the multipart attribute in your `<form>` tag!
#
# @example Full form context and output
#
#   <%= semantic_form_for(@user, :html => { :multipart => true }) do |f| %>
#   <%= f.inputs do %>
#   <%= f.input :avatar, :as => :file %>
#   <% end %>
#   <% end %>
#
#   <form...>
#   <fieldset>
#   <ol>
#   <li class="file">
#   <label for="user_avatar">Avatar</label>
#   <input type="file" id="user_avatar" name="user[avatar]">
#   </li>
#   </ol>
#   </fieldset>
#   </form>
# @see Formtastic::Helpers::InputsHelper#input InputsHelper#input for full documentation of all possible options.
class Formtastic::Inputs::FileInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base

  def to_html; end
end

# Outputs a simple `<input type="hidden">` wrapped in the standard `<li>` wrapper. This is
# provided for situations where a hidden field needs to be rendered in the flow of a form with
# many inputs that form an `<ol>`. Wrapping the hidden input inside the `<li>` maintains the
# HTML validity. The `<li>` is marked with a `class` of `hidden` so that stylesheet authors can
# hide these list items with CSS (formtastic.css does this out of the box).
#
# @example Full form context, output and CSS
#
#   <%= semantic_form_for(@something) do |f| %>
#   <%= f.inputs do %>
#   <%= f.input :secret, :as => :hidden %>
#   <% end %>
#   <% end %>
#
#   <form...>
#   <fieldset>
#   <ol>
#   <li class="hidden">
#   <input type="hidden" id="something_secret" name="something[secret]">
#   </li>
#   </ol>
#   </fieldset>
#   </form>
#
#   form.formtastic li.hidden { display:none; }
# @see Formtastic::Helpers::InputsHelper#input InputsHelper#input for full documentation of all possible options.
class Formtastic::Inputs::HiddenInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base

  def error_html; end

  # @return [Boolean]
  def errors?; end

  # @return [Boolean]
  def hint?; end

  def hint_html; end
  def input_html_options; end
  def to_html; end
end

# Outputs a simple `<label>` with a HTML5 `<input type="number">` wrapped in the standard
# `<li>` wrapper. This is the default input choice for all database columns of the type `:float`
# and `:decimal`, as well as `:integer` columns that aren't used for `belongs_to` associations,
# but can be applied to any text-like input with `:as => :number`.
#
# Sensible default values for the `min`, `max` and `step` attributes are found by reflecting on
# the model's validations (when provided). An `IndeterminableMinimumAttributeError` exception
# will be raised when the following conditions are all true:
#
# * you haven't specified a `:min` or `:max` for the input
# * the model's database column type is a `:float` or `:decimal`
# * the validation uses `:less_than` or `:greater_than`
#
# The solution is to either:
#
# * manually specify the `:min` or `:max` for the input
# * change the database column type to an `:integer` (if appropriate)
# * change the validations to use `:less_than_or_equal_to` or `:greater_than_or_equal_to`
#
# @example Full form context and output
#
#   <%= semantic_form_for(@user) do |f| %>
#   <%= f.inputs do %>
#   <%= f.input :shoe_size, :as => :number %>
#   <% end %>
#   <% end %>
#
#   <form...>
#   <fieldset>
#   <ol>
#   <li class="numeric">
#   <label for="user_shoe_size">Shoe size</label>
#   <input type="number" id="user_shoe_size" name="user[shoe_size]">
#   </li>
#   </ol>
#   </fieldset>
#   </form>
# @example Default HTML5 min/max/step attributes are detected from the numericality validations
#
#   class Person < ActiveRecord::Base
#   validates_numericality_of :age,
#   :less_than_or_equal_to => 100,
#   :greater_than_or_equal_to => 18,
#   :only_integer => true
#   end
#
#   <%= f.input :age, :as => :number %>
#
#   <li class="numeric">
#   <label for="persom_age">Age</label>
#   <input type="number" id="person_age" name="person[age]" min="18" max="100" step="1">
#   </li>
# @example Pass attributes down to the `<input>` tag with :input_html
#   <%= f.input :shoe_size, :as => :number, :input_html => { :min => 3, :max => 15, :step => 1, :class => "special" } %>
# @example Min/max/step also work as options
#   <%= f.input :shoe_size, :as => :number, :min => 3, :max => 15, :step => 1, :input_html => { :class => "special" } %>
# @example Use :in with a Range as a shortcut for :min/:max
#   <%= f.input :shoe_size, :as => :number, :in => 3..15, :step => 1 %>
#   <%= f.input :shoe_size, :as => :number, :input_html => { :in => 3..15, :step => 1 } %>
# @see Formtastic::Helpers::InputsHelper#input InputsHelper#input for full documentation of all possible options.
# @see http://api.rubyonrails.org/classes/ActiveModel/Validations/HelperMethods.html#method-i-validates_numericality_of Rails' Numericality validation documentation
class Formtastic::Inputs::NumberInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Numeric
  include ::Formtastic::Inputs::Base::Placeholder

  def step_option; end
  def to_html; end
end

# Outputs a simple `<label>` with a `<input type="password">` wrapped in the standard
# `<li>` wrapper. This is the default input choice for all attributes matching `/password/`, but
# can be applied to any text-like input with `:as => :password`.
#
# @example Full form context and output
#
#   <%= semantic_form_for(@user) do |f| %>
#   <%= f.inputs do %>
#   <%= f.input :password, :as => :password %>
#   <% end %>
#   <% end %>
#
#   <form...>
#   <fieldset>
#   <ol>
#   <li class="password">
#   <label for="user_password">Password</label>
#   <input type="password" id="user_password" name="user[password]">
#   </li>
#   </ol>
#   </fieldset>
#   </form>
# @see Formtastic::Helpers::InputsHelper#input InputsHelper#input for full documentation of all possible options.
class Formtastic::Inputs::PasswordInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Stringish
  include ::Formtastic::Inputs::Base::Placeholder

  def to_html; end
end

# Outputs a simple `<label>` with a HTML5 `<input type="phone">` wrapped in the standard
# `<li>` wrapper. This is the default input choice for attributes with a name matching
# `/(phone|fax)/`, but can be applied to any text-like input with `:as => :phone`.
#
# @example Full form context and output
#
#   <%= semantic_form_for(@user) do |f| %>
#   <%= f.inputs do %>
#   <%= f.input :mobile, :as => :phone %>
#   <% end %>
#   <% end %>
#
#   <form...>
#   <fieldset>
#   <ol>
#   <li class="phone">
#   <label for="user_mobile">Mobile</label>
#   <input type="tel" id="user_mobile" name="user[mobile]">
#   </li>
#   </ol>
#   </fieldset>
#   </form>
# @see Formtastic::Helpers::InputsHelper#input InputsHelper#input for full documentation of all possible options.
class Formtastic::Inputs::PhoneInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Stringish
  include ::Formtastic::Inputs::Base::Placeholder

  def to_html; end
end

# A radio input is used to render a series of radio inputs. This is an alternative input choice
# for `belongs_to` associations like a `Post` belonging to a `Section` or an `Author`, or any
# case where the user needs to make a single selection from a pre-defined collectioon of choices.
#
# Within the standard `<li>` wrapper, the output is a `<fieldset>` with a `<legend>` to
# represent the "label" for the input, and an `<ol>` containing `<li>`s for each choice in
# the association. Each `<li>` choice has a `<label>` containing an `<input type="radio">` and
# the label text to describe each choice.
#
# Radio inputs can be considered as an alternative where a (non-multi) select input is used,
# especially in cases where there are only a few choices, however they are not used by default
# for any type of association or model attribute. You can choose to use a radio input instead of
# a select with `:as => :radio`.
#
# Like a select input, the flexibility of the `:collection` option (see examples) makes the
# :radio input viable as an alternative for many other input types. For example, instead of...
#
# * a `:string` input (where you want to force the user to choose from a few specific strings rather than entering anything)
# * a `:boolean` checkbox input (where the user could choose yes or no, rather than checking a box)
# * a `:date_select`, `:time_select` or `:datetime_select` input (where the user could choose from a small set of pre-determined dates)
# * a `:number` input (where the user could choose from a small set of pre-defined numbers)
# * a `:time_zone` input (where you want to provide your own small set of choices instead of relying on Rails)
# * a `:country` input (where you want to provide a small set of choices, no need for a plugin really)
#
# For radio inputs that map to associations on the object model, Formtastic will automatically
# load in a collection of objects on the association as options to choose from. This might be an
# `Author.all` on a `Post` form with an input for a `belongs_to :user` association, or a
# `Section.all` for a `Post` form with an input for a `belongs_to :section` association.
# You can override or customise this collection through the `:collection` option (see examples).
#
# For radio inputs that map to ActiveRecord `enum` attributes, Formtastic will automatically
# load in your enum options to be used as the radio button choices. This can be overridden with
# the `:collection` option, or augmented with I18n translations. See examples below.
#
# The way on which Formtastic renders the `value` attribute and label for each choice in the `:collection` is
# customisable (see examples below). When not provided, we fall back to a list of methods to try on each
# object such as `:to_label`, `:name` and `:to_s`, which are defined in the configurations
# `collection_label_methods` and `collection_value_methods`.
#
# @example Basic `belongs_to` example with full form context
#
#   <%= semantic_form_for @post do |f| %>
#   <%= f.inputs do %>
#   <%= f.input :author, :as => :radio %>
#   <% end %>
#   <% end %>
#
#   <form...>
#   <fieldset>
#   <ol>
#   <li class='radio'>
#   <fieldset>
#   <legend class="label"><label>Categories</label></legend>
#   <ol>
#   <li>
#   <label for="post_author_id_1">
#   <input type="radio" id="post_author_id_1" value="1"> Justin
#   </label>
#   </li>
#   <li>
#   <label for="post_author_id_3">
#   <input type="radio" id="post_author_id_3" value="3"> Kate
#   </label>
#   </li>
#   <li>
#   <label for="post_author_id_2">
#   <input type="radio" id="post_author_id_2" value="2"> Amelia
#   </label>
#   </li>
#   </ol>
#   </fieldset>
#   </li>
#   </ol>
#   </fieldset>
#   </form>
# @example The `:collection` option can be used to customize the choices
#   <%= f.input :author, :as => :radio, :collection => @authors %>
#   <%= f.input :author, :as => :radio, :collection => Author.all %>
#   <%= f.input :author, :as => :radio, :collection => Author.some_named_scope %>
#   <%= f.input :author, :as => :radio, :collection => Author.pluck(:full_name, :id) %>
#   <%= f.input :author, :as => :radio, :collection => Author.pluck(Arel.sql("CONCAT(`first_name`, ' ', `last_name`)"), :id)) %>
#   <%= f.input :author, :as => :radio, :collection => [Author.find_by_login("justin"), Category.find_by_name("kate")] %>
#   <%= f.input :author, :as => :radio, :collection => ["Justin", "Kate"] %>
#   <%= f.input :author, :as => :radio, :collection => [["Justin", "justin"], ["Kate", "kate"]] %>
#   <%= f.input :author, :as => :radio, :collection => [["Justin", "1"], ["Kate", "3"]] %>
#   <%= f.input :author, :as => :radio, :collection => [["Justin", 1], ["Kate", 3]] %>
#   <%= f.input :author, :as => :radio, :collection => [["Justin", :justin], ["Kate", :kate]] %>
#   <%= f.input :author, :as => :radio, :collection => [:justin, :kate] %>
#   <%= f.input :author, :as => :radio, :collection => 1..5 %>
# @example Set HTML attributes on each `<input type="radio">` tag with `:input_html`
#   <%= f.input :author, :as => :radio, :input_html => { :size => 20, :multiple => true, :class => "special" } %>
# @example Set HTML attributes on the `<li>` wrapper with `:wrapper_html`
#   <%= f.input :author, :as => :radio, :wrapper_html => { :class => "special" } %>
# @example `:value_as_class` can be used to add a class to the `<li>` wrapped around each choice using the radio value for custom styling of each choice
#   <%= f.input :author, :as => :radio, :value_as_class => true %>
# @example Set HTML options on a specific radio input option with a 3rd element in the array for a collection member
#   <%= f.input :author, :as => :radio, :collection => [["Test", 'test'], ["Try", "try", {:disabled => true}]]
# @example Using ActiveRecord enum attribute with i18n translation:
#   # post.rb
#   class Post < ActiveRecord::Base
#   enum :status => [ :active, :archived ]
#   end
#   # en.yml
#   en:
#   activerecord:
#   attributes:
#   post:
#   statuses:
#   active: I am active!
#   archived: I am archived!
#   # form
#   <%= f.input :status, :as => :radio %>
# @see Formtastic::Helpers::InputsHelper#input InputsHelper#input for full documentation of all possible options.
# @see Formtastic::Inputs::RadioInput as an alternative for `belongs_to` associations
# @todo :disabled like CheckBoxes?
class Formtastic::Inputs::RadioInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Collections
  include ::Formtastic::Inputs::Base::Choices

  def choice_html(choice); end

  # Override to remove the for attribute since this isn't associated with any element, as it's
  # nested inside the legend.
  def label_html_options; end

  def to_html; end
end

# Outputs a simple `<label>` with a HTML5 `<input type="range">` wrapped in the standard
# `<li>` wrapper. This is an alternative input choice to a number input.
#
# Sensible default for the `min`, `max` and `step` attributes are found by reflecting on
# the model's validations. When validations are not provided, the `min` and `step` default to
# `1` and the `max` default to `100`. An `IndeterminableMinimumAttributeError` exception
# will be raised when the following conditions are all true:
#
# * you haven't specified a `:min` or `:max` for the input
# * the model's database column type is a `:float` or `:decimal`
# * the validation uses `:less_than` or `:greater_than`
#
# The solution is to either:
#
# * manually specify the `:min` or `:max` for the input
# * change the database column type to an `:integer` (if appropriate)
# * change the validations to use `:less_than_or_equal_to` or `:greater_than_or_equal_to`
#
# @example Full form context and output
#
#   <%= semantic_form_for(@user) do |f| %>
#   <%= f.inputs do %>
#   <%= f.input :shoe_size, :as => :range %>
#   <% end %>
#   <% end %>
#
#   <form...>
#   <fieldset>
#   <ol>
#   <li class="numeric">
#   <label for="user_shoe_size">Shoe size</label>
#   <input type="range" id="user_shoe_size" name="user[shoe_size]" min="1" max="100" step="1">
#   </li>
#   </ol>
#   </fieldset>
#   </form>
# @example Default HTML5 min/max/step attributes are detected from the numericality validations
#
#   class Person < ActiveRecord::Base
#   validates_numericality_of :age,
#   :less_than_or_equal_to => 100,
#   :greater_than_or_equal_to => 18,
#   :only_integer => true
#   end
#
#   <%= f.input :age, :as => :number %>
#
#   <li class="numeric">
#   <label for="persom_age">Age</label>
#   <input type="range" id="person_age" name="person[age]" min="18" max="100" step="1">
#   </li>
# @example Pass attributes down to the `<input>` tag with :input_html
#   <%= f.input :shoe_size, :as => :range, :input_html => { :min => 3, :max => 15, :step => 1, :class => "special" } %>
# @example Min/max/step also work as options
#   <%= f.input :shoe_size, :as => :range, :min => 3, :max => 15, :step => 1, :input_html => { :class => "special" } %>
# @example Use :in with a Range as a shortcut for :min/:max
#   <%= f.input :shoe_size, :as => :range, :in => 3..15, :step => 1 %>
#   <%= f.input :shoe_size, :as => :range, :input_html => { :in => 3..15, :step => 1 } %>
# @see Formtastic::Helpers::InputsHelper#input InputsHelper#input for full documentation of all possible options.
# @see http://api.rubyonrails.org/classes/ActiveModel/Validations/HelperMethods.html#method-i-validates_numericality_of Rails' Numericality validation documentation
class Formtastic::Inputs::RangeInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Numeric

  def max_option; end
  def min_option; end
  def step_option; end
  def to_html; end
end

# Outputs a simple `<label>` with a HTML5 `<input type="search">` wrapped in the standard
# `<li>` wrapper. This is the default input choice for attributes with a name matching
# `/^search$/`, but can be applied to any text-like input with `:as => :search`.
#
# @example Full form context and output
#
#   <%= semantic_form_for(@search, :html => { :method => :get }) do |f| %>
#   <%= f.inputs do %>
#   <%= f.input :q, :as => :search, :label => false, :input_html => { :name => "q" } %>
#   <% end %>
#   <% end %>
#
#   <form...>
#   <fieldset>
#   <ol>
#   <li class="search">
#   <input type="search" id="search_q" name="q">
#   </li>
#   </ol>
#   </fieldset>
#   </form>
# @see Formtastic::Helpers::InputsHelper#input InputsHelper#input for full documentation of all possible options.
class Formtastic::Inputs::SearchInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Stringish
  include ::Formtastic::Inputs::Base::Placeholder

  def to_html; end
end

# A select input is used to render a `<select>` tag with a series of options to choose from.
# It works for both single selections (like a `belongs_to` relationship, or "yes/no" boolean),
# as well as multiple selections (like a `has_and_belongs_to_many`/`has_many` relationship,
# for assigning many genres to a song, for example).
#
# This is the default input choice when:
#
# * the database column type is an `:integer` and there is an association (`belongs_to`)
# * the database column type is an `:integer` and there is an enum defined (`enum`)
# * the database column type is a `:string` and the `:collection` option is used
# * there an object with an association, but no database column on the object (`has_many`, etc)
# * there is no object and the `:collection` option is used
#
# The flexibility of the `:collection` option (see examples) makes the :select input viable as
# an alternative for many other input types. For example, instead of...
#
# * a `:string` input (where you want to force the user to choose from a few specific strings rather than entering anything)
# * a `:boolean` checkbox input (where the user could choose yes or no, rather than checking a box)
# * a `:date_select`, `:time_select` or `:datetime_select` input (where the user could choose from pre-selected dates)
# * a `:number` input (where the user could choose from a set of pre-defined numbers)
# * a `:time_zone` input (where you want to provide your own set of choices instead of relying on Rails)
# * a `:country` input (no need for a plugin really)
#
# Within the standard `<li>` wrapper, the output is a `<label>` tag followed by a `<select>`
# tag containing `<option>` tags.
#
# For inputs that map to associations on the object model, Formtastic will automatically load
# in a collection of objects on the association as options to choose from. This might be an
# `Author.all` on a `Post` form with an input for a `belongs_to :user` association, or a
# `Tag.all` for a `Post` form with an input for a `has_and_belongs_to_many :tags` association.
# You can override or customise this collection and the `<option>` tags it will render through
# the `:collection` option (see examples).
#
# The way on which Formtastic renders the `value` attribute and content of each `<option>` tag
# is customisable through the `:member_label` and `:member_value` options. When not provided,
# we fall back to a list of methods to try on each object such as `:to_label`, `:name` and
# `:to_s`, which are defined in the configurations `collection_label_methods` and
# `collection_value_methods` (see examples below).
#
# For select inputs that map to ActiveRecord `enum` attributes, Formtastic will automatically
# load in your enum options to be used as the select's options. This can be overridden with
# the `:collection` option, or augmented with I18n translations. See examples below.
# An error is raised if you try to render a multi-select with an enum, as ActiveRecord can
# only store one choice in the database.
#
# @example Basic `belongs_to` example with full form context
#
#   <%= semantic_form_for @post do |f| %>
#   <%= f.inputs do %>
#   <%= f.input :author, :as => :select %>
#   <% end %>
#   <% end %>
#
#   <form...>
#   <fieldset>
#   <ol>
#   <li class='select'>
#   <label for="post_author_id">Author</label>
#   <select id="post_author_id" name="post[post_author_id]">
#   <option value=""></option>
#   <option value="1">Justin</option>
#   <option value="3">Kate</option>
#   <option value="2">Amelia</option>
#   </select>
#   </li>
#   </ol>
#   </fieldset>
#   </form>
# @example Basic `has_many` or `has_and_belongs_to_many` example with full form context
#
#   <%= semantic_form_for @post do |f| %>
#   <%= f.inputs do %>
#   <%= f.input :tags, :as => :select %>
#   <% end %>
#   <% end %>
#
#   <form...>
#   <fieldset>
#   <ol>
#   <li class='select'>
#   <label for="post_tag_ids">Author</label>
#   <select id="post_tag_ids" name="post[tag_ids]" multiple="true">
#   <option value="1">Ruby</option>
#   <option value="6">Rails</option>
#   <option value="3">Forms</option>
#   <option value="4">Awesome</option>
#   </select>
#   </li>
#   </ol>
#   </fieldset>
#   </form>
# @example Override Formtastic's assumption on when you need a multi select
#   <%= f.input :authors, :as => :select, :input_html => { :multiple => true } %>
#   <%= f.input :authors, :as => :select, :input_html => { :multiple => false } %>
# @example The `:collection` option can be used to customize the choices
#   <%= f.input :author, :as => :select, :collection => @authors %>
#   <%= f.input :author, :as => :select, :collection => Author.all %>
#   <%= f.input :author, :as => :select, :collection => Author.some_named_scope %>
#   <%= f.input :author, :as => :select, :collection => Author.pluck(:full_name, :id) %>
#   <%= f.input :author, :as => :select, :collection => Author.pluck(Arel.sql("CONCAT(`first_name`, ' ', `last_name`)"), :id)) %>
#   <%= f.input :author, :as => :select, :collection => [Author.find_by_login("justin"), Category.find_by_name("kate")] %>
#   <%= f.input :author, :as => :select, :collection => ["Justin", "Kate"] %>
#   <%= f.input :author, :as => :select, :collection => [["Justin", "justin"], ["Kate", "kate"]] %>
#   <%= f.input :author, :as => :select, :collection => [["Justin", "1"], ["Kate", "3"]] %>
#   <%= f.input :author, :as => :select, :collection => [["Justin", 1], ["Kate", 3]] %>
#   <%= f.input :author, :as => :select, :collection => 1..5 %>
#   <%= f.input :author, :as => :select, :collection => "<option>your own options HTML string</option>" %>
#   <%= f.input :author, :as => :select, :collection => options_for_select(...) %>
#   <%= f.input :author, :as => :select, :collection => options_from_collection_for_select(...) %>
#   <%= f.input :author, :as => :select, :collection => grouped_options_for_select(...) %>
#   <%= f.input :author, :as => :select, :collection => time_zone_options_for_select(...) %>
# @example Set HTML attributes on the `<select>` tag with `:input_html`
#   <%= f.input :authors, :as => :select, :input_html => { :size => 20, :multiple => true, :class => "special" } %>
# @example Set HTML attributes on the `<li>` wrapper with `:wrapper_html`
#   <%= f.input :authors, :as => :select, :wrapper_html => { :class => "special" } %>
# @example Exclude, include, or customize the blank option at the top of the select. Always shown, even if the field already has a value. Suitable for optional inputs.
#   <%= f.input :author, :as => :select, :include_blank => false %>
#   <%= f.input :author, :as => :select, :include_blank => true %>   =>   <option value=""></option>
#   <%= f.input :author, :as => :select, :include_blank => "No author" %>
# @example Exclude, include, or customize the prompt at the top of the select. Only shown if the field does not have a value. Suitable for required inputs.
#   <%= f.input :author, :as => :select, :prompt => false %>
#   <%= f.input :author, :as => :select, :prompt => true %>   =>   <option value="">Please select</option>
#   <%= f.input :author, :as => :select, :prompt => "Please select an author" %>
# @example Using ActiveRecord enum attribute with i18n translation:
#   # post.rb
#   class Post < ActiveRecord::Base
#   enum :status => [ :active, :archived ]
#   end
#   # en.yml
#   en:
#   activerecord:
#   attributes:
#   post:
#   statuses:
#   active: I am active!
#   archived: I am archived!
#   # form
#   <%= f.input :status, :as => :select %>
# @see Formtastic::Helpers::InputsHelper#input InputsHelper#input for full documentation of all possible options.
# @see Formtastic::Inputs::CheckBoxesInput CheckBoxesInput as an alternative for `has_many` and `has_and_belongs_to_many` associations
# @see Formtastic::Inputs::RadioInput RadioInput as an alternative for `belongs_to` associations
# @todo Do/can we support the per-item HTML options like RadioInput?
class Formtastic::Inputs::SelectInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Collections

  # @raise [Formtastic::UnsupportedEnumCollection]
  # @return [SelectInput] a new instance of SelectInput
  def initialize(*args); end

  def extra_input_html_options; end
  def include_blank; end
  def input_html_options; end
  def input_html_options_name; end
  def input_html_options_name_multiple; end
  def input_options; end
  def label_html_options; end

  # @return [Boolean]
  def multiple?; end

  # @return [Boolean]
  def multiple_by_association?; end

  # @return [Boolean]
  def multiple_by_options?; end

  # @return [Boolean]
  def prompt?; end

  def select_html; end

  # @return [Boolean]
  def single?; end

  def to_html; end
end

# Outputs a simple `<label>` with a `<input type="text">` wrapped in the standard
# `<li>` wrapper. This is the default input choice for database columns of the `:string` type,
# and is the default choice for all inputs when no other logical input type can be inferred.
# You can force any input to be a string input with `:as => :string`.
#
# @example Full form context and output
#
#   <%= semantic_form_for(@user) do |f| %>
#   <%= f.inputs do %>
#   <%= f.input :first_name, :as => :string %>
#   <% end %>
#   <% end %>
#
#   <form...>
#   <fieldset>
#   <ol>
#   <li class="string">
#   <label for="user_first_name">First name</label>
#   <input type="text" id="user_first_name" name="user[first_name]">
#   </li>
#   </ol>
#   </fieldset>
#   </form>
# @see Formtastic::Helpers::InputsHelper#input InputsHelper#input for full documentation of all possible options.
class Formtastic::Inputs::StringInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Stringish
  include ::Formtastic::Inputs::Base::Placeholder
end

# Outputs a simple `<label>` with a `<textarea>` wrapped in the standard
# `<li>` wrapper. This is the default input choice for database columns of the `:text` type,
# but can forced on any text-like input with `:as => :text`.
#
# @example Full form context and output
#
#   <%= semantic_form_for(@user) do |f| %>
#   <%= f.inputs do %>
#   <%= f.input :first_name, :as => :text %>
#   <% end %>
#   <% end %>
#
#   <form...>
#   <fieldset>
#   <ol>
#   <li class="text">
#   <label for="user_first_name">First name</label>
#   <textarea cols="30" id="user_first_name" name="user[first_name]" rows="20"></textarea>
#   </li>
#   </ol>
#   </fieldset>
#   </form>
# @see Formtastic::Helpers::InputsHelper#input InputsHelper#input for full documentation of all possible options.
class Formtastic::Inputs::TextInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Placeholder

  def input_html_options; end
  def to_html; end
end

# Outputs a simple `<label>` with a HTML5 `<input type="time">` wrapped in the standard
# `<li>` wrapper. This is an alternative to `:time_select` for `:date`, `:time`, `:datetime`
# database columns. You can use this input with `:as => :time_picker`.
#
# *Please note:* Formtastic only provides suitable markup for a date picker, but does not supply
# any additional CSS or Javascript to render calendar-style date pickers. Browsers that support
# this input type (such as Mobile Webkit and Opera on the desktop) will render a native widget.
# Browsers that don't will default to a plain text field`<input type="text">` and can be
# poly-filled with some Javascript and a UI library of your choice.
#
# @example Full form context and output
#
#   <%= semantic_form_for(@post) do |f| %>
#   <%= f.inputs do %>
#   <%= f.input :publish_at, :as => :time_picker %>
#   <% end %>
#   <% end %>
#
#   <form...>
#   <fieldset>
#   <ol>
#   <li class="string">
#   <label for="post_publish_at">First name</label>
#   <input type="date" id="post_publish_at" name="post[publish_at]">
#   </li>
#   </ol>
#   </fieldset>
#   </form>
# @example Setting the size (defaults to 5 for HH:MM)
#   <%= f.input :publish_at, :as => :time_picker, :size => 20 %>
#   <%= f.input :publish_at, :as => :time_picker, :input_html => { :size => 20 } %>
# @example Setting the maxlength (defaults to 5 for HH:MM)
#   <%= f.input :publish_at, :as => :time_picker, :maxlength => 20 %>
#   <%= f.input :publish_at, :as => :time_picker, :input_html => { :maxlength => 20 } %>
# @example Setting the value (defaults to HH:MM for Date and Time objects, otherwise renders string)
#   <%= f.input :publish_at, :as => :time_picker, :input_html => { :value => "14:14" } %>
# @example Setting the step attribute (defaults to 60)
#   <%= f.input :publish_at, :as => :time_picker, :step => 120 %>
#   <%= f.input :publish_at, :as => :time_picker, :input_html => { :step => 120 } %>
# @example Setting the step attribute with a macro
#   <%= f.input :publish_at, :as => :time_picker, :step => :second %>
#   <%= f.input :publish_at, :as => :time_picker, :step => :minute %>
#   <%= f.input :publish_at, :as => :time_picker, :step => :quarter_hour %>
#   <%= f.input :publish_at, :as => :time_picker, :step => :fifteen_minutes %>
#   <%= f.input :publish_at, :as => :time_picker, :step => :half_hour %>
#   <%= f.input :publish_at, :as => :time_picker, :step => :thirty_minutes %>
#   <%= f.input :publish_at, :as => :time_picker, :step => :hour %>
#   <%= f.input :publish_at, :as => :time_picker, :step => :sixty_minutes %>
# @example Setting the min attribute
#   <%= f.input :publish_at, :as => :time_picker, :min => "09:00" %>
#   <%= f.input :publish_at, :as => :time_picker, :input_html => { :min => "01:00" } %>
# @example Setting the max attribute
#   <%= f.input :publish_at, :as => :time_picker, :max => "18:00" %>
#   <%= f.input :publish_at, :as => :time_picker, :input_html => { :max => "18:00" } %>
# @example Setting the placeholder attribute
#   <%= f.input :publish_at, :as => :time_picker, :placeholder => "HH:MM" %>
#   <%= f.input :publish_at, :as => :time_picker, :input_html => { :placeholder => "HH:MM" } %>
# @see Formtastic::Helpers::InputsHelper#input InputsHelper#input for full documentation of all possible options.
class Formtastic::Inputs::TimePickerInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Stringish
  include ::Formtastic::Inputs::Base::Placeholder
  include ::Formtastic::Inputs::Base::DatetimePickerish

  def default_size; end
  def default_step; end
  def html_input_type; end
  def value; end
end

# Outputs a series of select boxes for the fragments that make up a time (hour, minute, second).
# Unless `:ignore_date` is true, it will render hidden inputs for the year, month and day as
# well, defaulting to `Time.current` if the form object doesn't have a value, much like Rails'
# own `time_select`.
#
# @see Formtastic::Inputs::Base::Timeish Timeish module for documentation of date, time and datetime input options.
class Formtastic::Inputs::TimeSelectInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Timeish

  def fragment_value(fragment); end

  # we don't want year / month / day fragments if :ignore_date => true
  def fragments; end

  def hidden_fragments; end
  def value_or_default_value; end
end

# This is the default input choice for attributes matching /time_zone/, but can be applied to
# any text-like input with `:as => :time_zone`.
#
# The priority_zones option:
#   Since this input actually uses Rails' `time_zone_select` helper, the :priority_zones
#   option needs to be an array of ActiveSupport::TimeZone objects.
#
#   And you can configure default value using
#
#   ```
#     Formtastic::FormBuilder.priority_time_zones = [timezone1, timezone2]
#   ```
#
#   See http://apidock.com/rails/ActionView/Helpers/FormOptionsHelper/time_zone_select for more information.
#
# @example Full form context and output
#
#   <%= semantic_form_for(@user) do |f| %>
#   <%= f.inputs do %>
#   <%= f.input :time_zone, :as => :time_zone %>
#   <% end %>
#   <% end %>
#
#   <form...>
#   <fieldset>
#   <ol>
#   <li class="time_zone">
#   <label for="user_time_zone">Time zone</label>
#   <input type="text" id="user_time_zone" name="user[time_zone]">
#   </li>
#   </ol>
#   </fieldset>
#   </form>
# @see Formtastic::Helpers::InputsHelper#input InputsHelper#input for full documentation of all possible options.
class Formtastic::Inputs::TimeZoneInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base

  def priority_zones; end
  def to_html; end
end

# Outputs a simple `<label>` with a HTML5 `<input type="url">` wrapped in the standard
# `<li>` wrapper. This is the default input choice for all attributes matching
# `/^url$|^website$|_url$/`, but can be applied to any text-like input with `:as => :url`.
#
# @example Full form context and output
#
#   <%= semantic_form_for(@user) do |f| %>
#   <%= f.inputs do %>
#   <%= f.input :home_page, :as => :url %>
#   <% end %>
#   <% end %>
#
#   <form...>
#   <fieldset>
#   <ol>
#   <li class="url">
#   <label for="user_home_page">Home page</label>
#   <input type="number" id="user_home_page" name="user[home_page]">
#   </li>
#   </ol>
#   </fieldset>
#   </form>
# @see Formtastic::Helpers::InputsHelper#input InputsHelper#input for full documentation of all possible options.
class Formtastic::Inputs::UrlInput
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Stringish
  include ::Formtastic::Inputs::Base::Placeholder

  def to_html; end
end

module Formtastic::LocalizedString
  def model_name; end

  protected

  # @private
  def localized_string(key, value, type, options = T.unsafe(nil)); end
end

# Implementation for looking up localized values within Formtastic using I18n, if no
# explicit value (like the `:label` option) is set and I18n-lookups are enabled in the
# configuration.
#
# You can subclass this to implement your own Localizer, and configure Formtastic to use this
# localizer with:
#
#   Formtastic::FormBuilder.i18n_localizer
#
# Enabled/disable i18n lookups completely with:
#
#   Formtastic::FormBuilder.i18n_lookups_by_default = true/false
#
# Lookup priority:
#
#   'formtastic.%{type}.%{model}.%{action}.%{attribute}'
#   'formtastic.%{type}.%{model}.%{attribute}'
#   'formtastic.%{type}.%{attribute}'
#
# Example:
#
#   'formtastic.labels.post.edit.title'
#   'formtastic.labels.post.title'
#   'formtastic.labels.title'
class Formtastic::Localizer
  # @return [Localizer] a new instance of Localizer
  def initialize(current_builder); end

  # Returns the value of attribute builder.
  def builder; end

  # Sets the attribute builder
  #
  # @param value the value to set the attribute builder to.
  def builder=(_arg0); end

  # @private
  def localize(key, value, type, options = T.unsafe(nil)); end

  protected

  # @private
  def escape_html_entities(string); end

  def i18n_cache_lookups; end
  def i18n_lookups_by_default; end
  def normalize_model_name(name); end

  class << self
    def cache; end
  end
end

class Formtastic::Localizer::Cache
  def cache; end
  def clear!; end
  def get(key); end

  # @return [Boolean]
  def has_key?(key); end

  def set(key, result); end
end

# This class implements class resolution in a namespace chain. It
# is used both by Formtastic::Helpers::InputHelper and
# Formtastic::Helpers::ActionHelper to look up action and input classes.
#
# @example Implementing own class finder
#   # You can implement own class finder that for example prefixes the class name or uses custom module.
#   class MyInputClassFinder < Formtastic::NamespacedClassFinder
#   def initialize(namespaces)
#   super [MyNamespace] + namespaces # first lookup in MyNamespace then the defaults
#   end
#
#   private
#
#   def class_name(as)
#   "My#{super}Input" # for example MyStringInput
#   end
#   end
#
#   # in config/initializers/formtastic.rb
#   Formtastic::FormBuilder.input_class_finder = MyInputClassFinder
class Formtastic::NamespacedClassFinder
  # @param namespaces [Array<Module>]
  # @return [NamespacedClassFinder] a new instance of NamespacedClassFinder
  def initialize(namespaces); end

  # Converts symbol to class name
  # Overridden in subclasses to create `StringInput` and `ButtonAction`
  #
  # @example
  #   class_name(:string) == "String"
  def class_name(as); end

  # Looks up the given reference in the configured namespaces.
  #
  # Two finder methods are provided, one for development tries to
  # reference the constant directly, triggering Rails' autoloading
  # const_missing machinery; the second one instead for production
  # checks with .const_defined before referencing the constant.
  def find(as); end

  # @private
  def namespaces; end

  def resolve(as); end

  private

  # Use auto-loading in development environment
  def find_by_trying(class_name); end

  # Looks up the given class name in the configured namespaces in order,
  # returning the first one that has the class name constant defined.
  def find_with_const_defined(class_name); end

  # @private
  def finder(class_name); end

  class << self
    # @return [Boolean]
    def use_const_defined?; end
  end
end

# @private
class Formtastic::NamespacedClassFinder::NotFoundError < ::NameError; end

# @private
class Formtastic::PolymorphicInputWithoutCollectionError < ::ArgumentError; end

# @private
class Formtastic::UnknownActionError < ::NameError; end

class Formtastic::UnknownInputError < ::NameError; end

# @private
class Formtastic::UnsupportedEnumCollection < ::NameError; end

# @private
class Formtastic::UnsupportedMethodForAction < ::ArgumentError; end

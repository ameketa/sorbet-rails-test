# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `ransack` gem.
# Please instead update this file by running `bin/tapioca gem ransack`.

module ActionView::Helpers::Tags
  extend ::ActiveSupport::Autoload
end

# TODO: Find a better way to solve this issue!
# This patch is needed since this Rails commit:
# https://github.com/rails/rails/commit/c1a118a
class ActionView::Helpers::Tags::Base
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::UrlHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::FormTagHelper
  include ::ActionView::Helpers::ActiveModelInstanceTag
  include ::ActionView::Helpers::FormOptionsHelper
  extend ::ActionView::Helpers::UrlHelper::ClassMethods
  extend ::ActionView::Helpers::SanitizeHelper::ClassMethods

  def initialize(object_name, method_name, template_object, options = T.unsafe(nil)); end

  def object; end
  def render; end

  private

  def add_default_name_and_id(options); end
  def add_default_name_and_id_for_value(tag_value, options); end
  def add_options(option_tags, options, value = T.unsafe(nil)); end
  def generate_ids?; end
  def name_and_id_index(options); end
  def placeholder_required?(html_options); end
  def retrieve_autoindex(pre_match); end
  def retrieve_object(object); end
  def sanitized_method_name; end
  def sanitized_value(value); end
  def select_content_tag(option_tags, options, html_options); end
  def tag_id(index = T.unsafe(nil), namespace = T.unsafe(nil)); end
  def tag_name(multiple = T.unsafe(nil), index = T.unsafe(nil)); end
  def value; end
  def value_before_type_cast; end
  def value_came_from_user?; end
end

module Polyamorous; end
Polyamorous::InnerJoin = Arel::Nodes::InnerJoin

class Polyamorous::Join
  include ::Polyamorous::TreeNode

  # @return [Join] a new instance of Join
  def initialize(name, type = T.unsafe(nil), klass = T.unsafe(nil)); end

  # @return [Boolean]
  def ==(other); end

  def add_to_tree(hash); end

  # @return [Boolean]
  def eql?(other); end

  def hash; end

  # Returns the value of attribute klass.
  def klass; end

  def klass=(klass); end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end

  # Returns the value of attribute type.
  def type; end

  def type=(type); end

  private

  def convert_to_arel_join_type(type); end
  def convert_to_class(value); end
end

Polyamorous::JoinAssociation = ActiveRecord::Associations::JoinDependency::JoinAssociation

module Polyamorous::JoinAssociationExtensions
  include ::Polyamorous::SwappingReflectionClass

  def initialize(reflection, children, polymorphic_class = T.unsafe(nil), join_type = T.unsafe(nil)); end

  # Same as #join_constraints, but instead of constructing tables from the
  # given block, uses the ones passed
  def join_constraints_with_tables(foreign_table, foreign_klass, join_type, alias_tracker, tables); end

  class << self
    def prepended(base); end
  end
end

Polyamorous::JoinDependency = ActiveRecord::Associations::JoinDependency

module Polyamorous::JoinDependencyExtensions
  # Replaces ActiveRecord::Associations::JoinDependency#build
  def build(associations, base_klass); end

  def construct_tables_for_association!(join_root, association); end
  def join_constraints(joins_to_add, alias_tracker, references); end

  private

  def table_aliases_for(parent, node); end
end

module Polyamorous::JoinDependencyExtensions::ClassMethods
  # Prepended before ActiveRecord::Associations::JoinDependency#walk_tree
  def walk_tree(associations, hash); end
end

Polyamorous::OuterJoin = Arel::Nodes::OuterJoin

module Polyamorous::ReflectionExtensions
  def join_scope(table, foreign_table, foreign_klass); end
end

module Polyamorous::SwappingReflectionClass
  # @yield [new_reflection]
  def swapping_reflection_klass(reflection, klass); end
end

module Polyamorous::TreeNode
  # @raise [NotImplementedError]
  def add_to_tree(hash); end
end

RANSACK_FORM_BUILDER = T.let(T.unsafe(nil), String)

module Ransack
  extend ::Ransack::Configuration
end

module Ransack::Adapters
  class << self
    def instantiate_object_mapper; end
    def object_mapper; end
  end
end

module Ransack::Adapters::ActiveRecord; end

module Ransack::Adapters::ActiveRecord::Base
  def ransack(params = T.unsafe(nil), options = T.unsafe(nil)); end
  def ransack!(params = T.unsafe(nil), options = T.unsafe(nil)); end
  def ransack_alias(new_name, old_name); end

  # Ransackable_associations, by default, returns the names
  # of all associations as an array of strings.
  # For overriding with a whitelist array of strings.
  def ransackable_associations(auth_object = T.unsafe(nil)); end

  # Ransackable_attributes, by default, returns all column names
  # and any defined ransackers as an array of strings.
  # For overriding with a whitelist array of strings.
  def ransackable_attributes(auth_object = T.unsafe(nil)); end

  # Ransackable_scopes, by default, returns an empty array
  # i.e. no class methods/scopes are authorized.
  # For overriding with a whitelist array of *symbols*.
  def ransackable_scopes(auth_object = T.unsafe(nil)); end

  # ransack_scope_skip_sanitize_args, by default, returns an empty array.
  # i.e. use the sanitize_scope_args setting to determine if args should be converted.
  # For overriding with a list of scopes which should be passed the args as-is.
  def ransackable_scopes_skip_sanitize_args; end

  def ransacker(name, opts = T.unsafe(nil), &block); end

  # Ransortable_attributes, by default, returns the names
  # of all attributes available for sorting as an array of strings.
  # For overriding with a whitelist array of strings.
  def ransortable_attributes(auth_object = T.unsafe(nil)); end

  class << self
    # @private
    def extended(base); end
  end
end

class Ransack::Adapters::ActiveRecord::Context < ::Ransack::Context
  def alias_tracker; end

  # @return [Boolean]
  def attribute_method?(str, klass = T.unsafe(nil)); end

  # Build an Arel subquery that selects keys for the top query,
  # drawn from the first join association's foreign_key.
  #
  # Example: for an Article that has_and_belongs_to_many Tags
  #
  #   context = Article.search.context
  #   attribute = Attribute.new(context, "tags_name").tap do |a|
  #     context.bind(a, a.name)
  #   end
  #   context.build_correlated_subquery(attribute.parent).to_sql
  #
  #   # SELECT "articles_tags"."article_id" FROM "articles_tags"
  #   # INNER JOIN "tags" ON "tags"."id" = "articles_tags"."tag_id"
  #   # WHERE "articles_tags"."article_id" = "articles"."id"
  #
  # The WHERE condition on this query makes it invalid by itself,
  # because it is correlated to the primary key on the outer query.
  def build_correlated_subquery(association); end

  def evaluate(search, opts = T.unsafe(nil)); end

  # All dependent Arel::Join nodes used in the search query.
  #
  # This could otherwise be done as `@object.arel.join_sources`, except
  # that ActiveRecord's build_joins sets up its own JoinDependency.
  # This extracts what we need to access the joins using our existing
  # JoinDependency to track table aliases.
  def join_sources; end

  def klassify(obj); end
  def lock_association(association); end
  def primary_key; end
  def relation_for(object); end
  def remove_association(association); end
  def table_for(parent); end
  def type_for(attr); end

  private

  def build_association(name, parent = T.unsafe(nil), klass = T.unsafe(nil)); end

  # Checkout active_record/relation/query_methods.rb +build_joins+ for
  # reference. Lots of duplicated code maybe we can avoid it
  def build_joins(relation); end

  def build_or_find_association(name, parent = T.unsafe(nil), klass = T.unsafe(nil)); end
  def convert_join_strings_to_ast(table, joins); end
  def extract_correlated_key(join_root); end
  def extract_joins(association); end
  def find_association(name, parent = T.unsafe(nil), klass = T.unsafe(nil)); end
  def get_association(str, parent = T.unsafe(nil)); end
  def get_parent_and_attribute_name(str, parent = T.unsafe(nil)); end
  def join_dependency(relation); end
end

class Ransack::Adapters::ActiveRecordAdapter
  def require_adapter; end
  def require_constants; end
  def require_context; end
  def require_nodes; end
  def require_search; end
end

class Ransack::Adapters::MongoidAdapter
  def require_adapter; end
  def require_constants; end
  def require_context; end
  def require_nodes; end
  def require_search; end
end

module Ransack::ClassMethods
  def i18n_scope; end
  def model_name; end
end

module Ransack::Configuration
  def add_predicate(name, opts = T.unsafe(nil)); end
  def arel_predicate_with_suffix(arel_predicate, suffix); end

  # @yield [_self]
  # @yieldparam _self [Ransack::Configuration] the object that the method was called on
  def configure; end

  # By default, Ransack displays sort order indicator arrows with HTML codes:
  #
  #   up_arrow:   '&#9660;'
  #   down_arrow: '&#9650;'
  #
  # There is also a default arrow which is displayed if a column is not sorted.
  # By default this is nil so nothing will be displayed.
  #
  # Any of the defaults may be globally overridden in an initializer file
  # like `config/initializers/ransack.rb` as follows:
  #
  # Ransack.configure do |config|
  #   # Globally set the up arrow to an icon, and the down and default arrows to unicode.
  #   config.custom_arrows = {
  #     up_arrow:   '<i class="fa fa-long-arrow-up"></i>',
  #     down_arrow: 'U+02193',
  #     default_arrow: 'U+11047'
  #   }
  # end
  def custom_arrows=(opts = T.unsafe(nil)); end

  # By default, Ransack displays sort order indicator arrows in sort links.
  # The default may be globally overridden in an initializer file like
  # `config/initializers/ransack.rb` as follows:
  #
  # Ransack.configure do |config|
  #   # Hide sort link order indicators globally across the application
  #   config.hide_sort_order_indicators = true
  # end
  def hide_sort_order_indicators=(boolean); end

  # By default Ransack ignores errors if an unknown predicate, condition or
  # attribute is passed into a search. The default may be overridden in an
  # initializer file like `config/initializers/ransack.rb` as follows:
  #
  # Ransack.configure do |config|
  #   # Raise if an unknown predicate, condition or attribute is passed
  #   config.ignore_unknown_conditions = false
  # end
  def ignore_unknown_conditions=(boolean); end

  def options; end
  def options=(val); end

  # The `NULLS FIRST` and `NULLS LAST` options can be used to determine
  # whether nulls appear before or after non-null values in the sort ordering.
  #
  # User may want to configure it like this:
  #
  # Ransack.configure do |c|
  #   c.postgres_fields_sort_option = :nulls_first # or e.g. :nulls_always_last
  # end
  #
  # See this feature: https://www.postgresql.org/docs/13/queries-order.html
  def postgres_fields_sort_option=(setting); end

  def predicates; end
  def predicates=(val); end

  # Ransack sanitizes many values in your custom scopes into booleans.
  # [1, '1', 't', 'T', 'true', 'TRUE'] all evaluate to true.
  # [0, '0', 'f', 'F', 'false', 'FALSE'] all evaluate to false.
  #
  # This default may be globally overridden in an initializer file like
  # `config/initializers/ransack.rb` as follows:
  #
  # Ransack.configure do |config|
  #   # Accept my custom scope values as what they are.
  #   config.sanitize_custom_scope_booleans = false
  # end
  def sanitize_custom_scope_booleans=(boolean); end

  # The default `search_key` name is `:q`. The default key may be overridden
  # in an initializer file like `config/initializers/ransack.rb` as follows:
  #
  # Ransack.configure do |config|
  #   # Name the search_key `:query` instead of the default `:q`
  #   config.search_key = :query
  # end
  #
  # Sometimes there are situations when the default search parameter name
  # cannot be used, for instance if there were two searches on one page.
  # Another name can be set using the `search_key` option with Ransack
  # `ransack`, `search` and `@search_form_for` methods in controllers & views.
  #
  # In the controller:
  # In the view:
  # <%= f.search_form_for @search, as: :log_search %>
  def search_key=(name); end

  # By default, Ransack displays strips all whitespace when searching for a string.
  # The default may be globally changed in an initializer file like
  # `config/initializers/ransack.rb` as follows:
  #
  # Ransack.configure do |config|
  #   # Enable whitespace stripping for string searches
  #   config.strip_whitespace = true
  # end
  def strip_whitespace=(boolean); end

  class << self
    def options; end
    def options=(val); end
    def predicates; end
    def predicates=(val); end
  end
end

class Ransack::Configuration::PredicateCollection
  # @return [PredicateCollection] a new instance of PredicateCollection
  def initialize; end

  def [](*_arg0, **_arg1, &_arg2); end
  def []=(key, value); end
  def has_key?(*_arg0, **_arg1, &_arg2); end
  def keys(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute sorted_names_with_underscores.
  def sorted_names_with_underscores; end
end

module Ransack::Constants
  private

  # replace % \ to \% \\
  def escape_wildcards(unescaped); end

  class << self
    # replace % \ to \% \\
    def escape_wildcards(unescaped); end
  end
end

Ransack::Constants::AND = T.let(T.unsafe(nil), String)
Ransack::Constants::AND_OR = T.let(T.unsafe(nil), Array)
Ransack::Constants::AREL_PREDICATES = T.let(T.unsafe(nil), Array)
Ransack::Constants::ASSOCIATION_JOIN = T.let(T.unsafe(nil), String)
Ransack::Constants::ATTRIBUTE = T.let(T.unsafe(nil), String)
Ransack::Constants::ATTRIBUTES = T.let(T.unsafe(nil), String)
Ransack::Constants::A_S_I = T.let(T.unsafe(nil), Array)
Ransack::Constants::BOOLEAN_VALUES = T.let(T.unsafe(nil), Set)
Ransack::Constants::CAP_SEARCH = T.let(T.unsafe(nil), String)
Ransack::Constants::COMBINATOR = T.let(T.unsafe(nil), String)
Ransack::Constants::CONT = T.let(T.unsafe(nil), String)
Ransack::Constants::DERIVED_PREDICATES = T.let(T.unsafe(nil), Array)
Ransack::Constants::DISTINCT = T.let(T.unsafe(nil), String)
Ransack::Constants::DOT_ASTERIX = T.let(T.unsafe(nil), String)
Ransack::Constants::EQ = T.let(T.unsafe(nil), String)
Ransack::Constants::EQ_ANY = T.let(T.unsafe(nil), String)
Ransack::Constants::FALSE_VALUES = T.let(T.unsafe(nil), Set)
Ransack::Constants::I = T.let(T.unsafe(nil), String)
Ransack::Constants::IN_NOT_IN = T.let(T.unsafe(nil), Array)
Ransack::Constants::JOIN_NODE = T.let(T.unsafe(nil), String)
Ransack::Constants::LEFT_PARENTHESIS = T.let(T.unsafe(nil), String)
Ransack::Constants::NOT_EQ = T.let(T.unsafe(nil), String)
Ransack::Constants::NOT_EQ_ALL = T.let(T.unsafe(nil), String)
Ransack::Constants::OR = T.let(T.unsafe(nil), String)
Ransack::Constants::Q = T.let(T.unsafe(nil), String)
Ransack::Constants::RANSACK_SLASH_SEARCHES = T.let(T.unsafe(nil), String)
Ransack::Constants::RANSACK_SLASH_SEARCHES_SLASH_SEARCH = T.let(T.unsafe(nil), String)
Ransack::Constants::SEARCH = T.let(T.unsafe(nil), String)
Ransack::Constants::SEARCHES = T.let(T.unsafe(nil), String)
Ransack::Constants::STASHED_JOIN = T.let(T.unsafe(nil), String)
Ransack::Constants::STRING_JOIN = T.let(T.unsafe(nil), String)
Ransack::Constants::SUFFIXES = T.let(T.unsafe(nil), Array)
Ransack::Constants::TRUE_VALUES = T.let(T.unsafe(nil), Set)
Ransack::Constants::TWO_COLONS = T.let(T.unsafe(nil), String)
Ransack::Constants::UNDERSCORE = T.let(T.unsafe(nil), String)

class Ransack::Context
  # << self
  #
  # @return [Context] a new instance of Context
  def initialize(object, options = T.unsafe(nil)); end

  # Returns the value of attribute arel_visitor.
  def arel_visitor; end

  def association_path(str, base = T.unsafe(nil)); end

  # Returns the value of attribute auth_object.
  def auth_object; end

  # Sets the attribute auth_object
  #
  # @param value the value to set the attribute auth_object to.
  def auth_object=(_arg0); end

  # Returns the value of attribute base.
  def base; end

  def bind(object, str); end
  def bind_pair_for(key); end
  def chain_scope(scope, args); end

  # Convert a string representing a chain of associations and an attribute
  # into the attribute itself
  def contextualize(str); end

  # Returns the value of attribute engine.
  def engine; end

  # Returns the value of attribute klass.
  def klass; end

  def klassify(obj); end

  # Returns the value of attribute object.
  def object; end

  def ransackable_alias(str); end

  # @return [Boolean]
  def ransackable_association?(str, klass); end

  # @return [Boolean]
  def ransackable_attribute?(str, klass); end

  # @return [Boolean]
  def ransackable_scope?(str, klass); end

  # @return [Boolean]
  def ransackable_scope_skip_sanitize_args?(str, klass); end

  def scope_arity(scope); end

  # Returns the value of attribute search.
  def search; end

  # Returns the value of attribute search_key.
  def search_key; end

  # Sets the attribute search_key
  #
  # @param value the value to set the attribute search_key to.
  def search_key=(_arg0); end

  def searchable_associations(str = T.unsafe(nil)); end
  def searchable_attributes(str = T.unsafe(nil)); end
  def sortable_attributes(str = T.unsafe(nil)); end
  def traverse(str, base = T.unsafe(nil)); end
  def unpolymorphize_association(str); end

  class << self
    def for(object, options = T.unsafe(nil)); end
    def for_class(klass, options = T.unsafe(nil)); end
    def for_object(object, options = T.unsafe(nil)); end
  end
end

module Ransack::Helpers; end

class Ransack::Helpers::FormBuilder < ::ActionView::Helpers::FormBuilder
  def attribute_fields(*args, &block); end

  # @raise [ArgumentError]
  def attribute_select(options = T.unsafe(nil), html_options = T.unsafe(nil), action = T.unsafe(nil)); end

  def combinator_select(options = T.unsafe(nil), html_options = T.unsafe(nil)); end
  def condition_fields(*args, &block); end
  def grouping_fields(*args, &block); end
  def label(method, *args, &block); end
  def predicate_fields(*args, &block); end
  def predicate_select(options = T.unsafe(nil), html_options = T.unsafe(nil)); end
  def search_fields(name, args, block); end
  def sort_direction_select(options = T.unsafe(nil), html_options = T.unsafe(nil)); end
  def sort_fields(*args, &block); end
  def sort_link(attribute, *args); end
  def sort_select(options = T.unsafe(nil), html_options = T.unsafe(nil)); end
  def sort_url(attribute, *args); end
  def submit(value = T.unsafe(nil), options = T.unsafe(nil)); end
  def value_fields(*args, &block); end

  private

  def association_array(obj, prefix = T.unsafe(nil)); end
  def association_hash(obj); end
  def association_object(obj); end
  def attr_from_base_and_column(base, column); end
  def attribute_collection_for_base(attributes, base = T.unsafe(nil)); end
  def attribute_collection_for_bases(action, bases); end

  # @return [Boolean]
  def can_use_default?(default, attribute, values); end

  def collection_for_base(action, base); end
  def combinator_choices; end
  def formbuilder_error_message(action); end
  def get_attribute_element(action, base); end
  def mapped_values(values); end
  def sort_array; end
  def template_collection_select(name, collection, options, html_options); end
  def template_grouped_collection_select(collection, options, html_options); end
end

module Ransack::Helpers::FormHelper
  # +search_form_for+
  #
  #   <%= search_form_for(@q) do |f| %>
  def search_form_for(record, options = T.unsafe(nil), &proc); end

  # +sort_link+
  #
  #   <%= sort_link(@q, :name, [:name, 'kind ASC'], 'Player Name') %>
  #
  #   You can also use a block:
  #
  #   <%= sort_link(@q, :name, [:name, 'kind ASC']) do %>
  #     <strong>Player Name</strong>
  #   <% end %>
  def sort_link(search_object, attribute, *args, &block); end

  # +sort_url+
  # <%= sort_url(@q, :created_at, default_order: :desc) %>
  def sort_url(search_object, attribute, *args); end

  private

  def extract_search_and_routing_proxy(search); end
  def html_option_for(option, search); end
  def options_for(record); end
  def parse_record(object); end
  def url(routing_proxy, options_for_url); end
end

class Ransack::Helpers::FormHelper::SortLink
  # @return [SortLink] a new instance of SortLink
  def initialize(search, attribute, args, params); end

  def default_arrow; end
  def down_arrow; end
  def html_options(args); end
  def name; end
  def up_arrow; end
  def url_options; end

  private

  def default_sort_order(attr_name); end
  def detect_previous_sort_direction_and_invert_it(attr_name); end
  def direction_text(dir); end
  def existing_sort_direction(f = T.unsafe(nil)); end
  def extract_label_and_mutate_args!(args); end
  def extract_options_and_mutate_args!(args); end
  def extract_sort_fields_and_mutate_args!(args); end

  # @return [Boolean]
  def no_sort_direction_specified?(dir = T.unsafe(nil)); end

  def order_indicator; end
  def parameters_hash(params); end
  def parse_sort(field); end
  def recursive_sort_params_build(fields); end
  def search_and_sort_params; end
  def search_params; end
  def sort_params; end
end

class Ransack::Name < ::String
  # @return [Name] a new instance of Name
  def initialize; end

  # Returns the value of attribute collection.
  def cache_key; end

  # Returns the value of attribute collection.
  def collection; end

  # Returns the value of attribute element.
  def element; end

  # Returns the value of attribute human.
  def human; end

  # Returns the value of attribute i18n_key.
  def i18n_key; end

  # Returns the value of attribute param_key.
  def param_key; end

  # Returns the value of attribute partial_path.
  def partial_path; end

  # Returns the value of attribute plural.
  def plural; end

  # Returns the value of attribute route_key.
  def route_key; end

  # Returns the value of attribute singular.
  def singular; end
end

module Ransack::Naming
  mixes_in_class_methods ::Ransack::ClassMethods

  def model_name; end

  # @return [Boolean]
  def persisted?; end

  def to_key; end
  def to_model; end
  def to_param; end

  class << self
    # @private
    def included(base); end
  end
end

module Ransack::Nodes; end

class Ransack::Nodes::Attribute < ::Ransack::Nodes::Node
  include ::Ransack::Nodes::Bindable

  # @return [Attribute] a new instance of Attribute
  def initialize(context, name = T.unsafe(nil), ransacker_args = T.unsafe(nil)); end

  # @return [Boolean]
  def ==(other); end

  # @return [Boolean]
  def associated_collection?; end

  def blank?(*_arg0, **_arg1, &_arg2); end
  def engine(*_arg0, **_arg1, &_arg2); end

  # @return [Boolean]
  def eql?(other); end

  def hash; end
  def inspect; end

  # Returns the value of attribute name.
  def name; end

  def name=(name); end

  # @return [Boolean]
  def persisted?; end

  def present?(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute ransacker_args.
  def ransacker_args; end

  def type; end

  # @return [Boolean]
  def valid?; end
end

module Ransack::Nodes::Bindable
  def arel_attribute; end
  def attr; end

  # Returns the value of attribute attr_name.
  def attr_name; end

  # Sets the attribute attr_name
  #
  # @param value the value to set the attribute attr_name to.
  def attr_name=(_arg0); end

  # @return [Boolean]
  def bound?; end

  def klass; end

  # Returns the value of attribute parent.
  def parent; end

  # Sets the attribute parent
  #
  # @param value the value to set the attribute parent to.
  def parent=(_arg0); end

  def ransacker; end
  def reset_binding!; end

  private

  def get_arel_attribute; end
  def get_attribute; end

  # @return [Boolean]
  def is_alias_attribute?; end
end

class Ransack::Nodes::Condition < ::Ransack::Nodes::Node
  # @return [Boolean]
  def ==(other); end

  def a; end
  def a=(args); end
  def arel_predicate; end
  def arel_predicate_for_attribute(attr); end
  def attr_value_for_attribute(attr); end
  def attributes; end
  def attributes=(args); end
  def build(params); end

  # == build_attribute
  #
  #  This method was originally called from Nodes::Grouping#new_condition
  #  only, without arguments, without #valid? checking, to build a new
  #  grouping condition.
  #
  #  After refactoring in 235eae3, it is now called from 2 places:
  #
  #  1. Nodes::Condition#attributes=, with +name+ argument passed or +name+
  #     and +ransacker_args+. Attributes are included only if #valid?.
  #
  #  2. Nodes::Grouping#new_condition without arguments. In this case, the
  #     #valid? conditional needs to be bypassed, otherwise nothing is
  #     built. The `name.nil?` conditional below currently does this.
  #
  #  TODO: Add test coverage for this behavior and ensure that `name.nil?`
  #  isn't fixing issue #701 by introducing untested regressions.
  def build_attribute(name = T.unsafe(nil), ransacker_args = T.unsafe(nil)); end

  def build_value(val = T.unsafe(nil)); end
  def casted_values_for_attribute(attr); end
  def combinator; end
  def combinator=(val); end
  def default_type; end

  # @return [Boolean]
  def eql?(other); end

  def formatted_values_for_attribute(attr); end
  def hash; end
  def inspect; end
  def key; end
  def m; end
  def m=(val); end

  # @return [Boolean]
  def negative?; end

  def p; end
  def p=(name); end

  # @return [Boolean]
  def persisted?; end

  # Returns the value of attribute predicate.
  def predicate; end

  # Sets the attribute predicate
  #
  # @param value the value to set the attribute predicate to.
  def predicate=(_arg0); end

  def predicate_name; end
  def predicate_name=(name); end
  def v; end
  def v=(args); end

  # @return [Boolean]
  def valid?; end

  # @return [Boolean]
  def valid_arity?; end

  def validated_values; end
  def value; end
  def values; end
  def values=(args); end

  private

  # @return [Boolean]
  def casted_array?(predicate); end

  def combinator_method; end
  def format_predicate(attribute); end
  def format_values_for(predicate); end

  # @return [Boolean]
  def in_predicate?(predicate); end

  # @return [Boolean]
  def valid_combinator?; end

  class << self
    def extract(context, key, values); end
    def i18n_words; end

    private

    def extract_values_for_condition(key, context = T.unsafe(nil)); end
  end
end

class Ransack::Nodes::Grouping < ::Ransack::Nodes::Node
  # @return [Grouping] a new instance of Grouping
  def initialize(context, combinator = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end

  # @return [Boolean]
  def attribute_method?(name); end

  def build(params); end
  def build_condition(opts = T.unsafe(nil)); end
  def build_grouping(params = T.unsafe(nil)); end

  # Returns the value of attribute conditions.
  def c; end

  def c=(conditions); end

  # Returns the value of attribute combinator.
  def combinator; end

  # Sets the attribute combinator
  #
  # @param value the value to set the attribute combinator to.
  def combinator=(_arg0); end

  # Returns the value of attribute conditions.
  def conditions; end

  def conditions=(conditions); end
  def each(*_arg0, **_arg1, &_arg2); end
  def g; end
  def g=(groupings); end
  def groupings; end
  def groupings=(groupings); end
  def inspect; end

  # Returns the value of attribute combinator.
  def m; end

  # Sets the attribute combinator
  #
  # @param value the value to set the attribute combinator to.
  def m=(_arg0); end

  def method_missing(method_id, *args); end
  def new_condition(opts = T.unsafe(nil)); end
  def new_grouping(params = T.unsafe(nil)); end

  # @return [Boolean]
  def persisted?; end

  # @return [Boolean]
  def respond_to?(method_id); end

  def translate(key, options = T.unsafe(nil)); end
  def values; end

  private

  def read_attribute(name); end
  def remove_duplicate_conditions!; end
  def strip_predicate_and_index(str); end
  def write_attribute(name, val); end

  class << self
    def i18n_words; end
  end
end

class Ransack::Nodes::Node
  # @return [Node] a new instance of Node
  def initialize(context); end

  # Returns the value of attribute context.
  def context; end

  def contextualize(*_arg0, **_arg1, &_arg2); end
  def i18n_aliases; end
  def i18n_aliases=(_arg0); end
  def i18n_aliases?; end
  def i18n_words; end
  def i18n_words=(_arg0); end
  def i18n_words?; end
  def translate(key, options = T.unsafe(nil)); end

  class << self
    def i18n_alias(opts = T.unsafe(nil)); end
    def i18n_aliases; end
    def i18n_aliases=(value); end
    def i18n_aliases?; end
    def i18n_word(*args); end
    def i18n_words; end
    def i18n_words=(value); end
    def i18n_words?; end
  end
end

class Ransack::Nodes::Sort < ::Ransack::Nodes::Node
  include ::Ransack::Nodes::Bindable

  def build(params); end

  # Returns the value of attribute dir.
  def dir; end

  def dir=(dir); end

  # Returns the value of attribute name.
  def name; end

  def name=(name); end

  # Returns the value of attribute ransacker_args.
  def ransacker_args; end

  def ransacker_args=(ransack_args); end

  # @return [Boolean]
  def valid?; end

  class << self
    def extract(context, str); end
    def i18n_words; end
  end
end

class Ransack::Nodes::Value < ::Ransack::Nodes::Node
  # @return [Value] a new instance of Value
  def initialize(context, value = T.unsafe(nil)); end

  # @return [Boolean]
  def ==(other); end

  # @return [Boolean]
  def array_of_arrays?(val); end

  def blank?(*_arg0, **_arg1, &_arg2); end
  def cast(type); end
  def cast_to_boolean(val); end
  def cast_to_date(val); end
  def cast_to_decimal(val); end
  def cast_to_float(val); end
  def cast_to_integer(val); end
  def cast_to_money(val); end
  def cast_to_string(val); end
  def cast_to_time(val); end

  # @return [Boolean]
  def eql?(other); end

  def hash; end
  def inspect; end

  # @return [Boolean]
  def persisted?; end

  def present?(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute value.
  def value; end

  # Sets the attribute value
  #
  # @param value the value to set the attribute value to.
  def value=(_arg0); end
end

class Ransack::Predicate
  # @return [Predicate] a new instance of Predicate
  def initialize(opts = T.unsafe(nil)); end

  # @return [Boolean]
  def ==(other); end

  # Returns the value of attribute arel_predicate.
  def arel_predicate; end

  # Returns the value of attribute case_insensitive.
  def case_insensitive; end

  # Returns the value of attribute compound.
  def compound; end

  # @return [Boolean]
  def eql?(other); end

  def format(val); end

  # Returns the value of attribute formatter.
  def formatter; end

  def hash; end

  # Returns the value of attribute name.
  def name; end

  # @return [Boolean]
  def negative?; end

  # Returns the value of attribute type.
  def type; end

  def validate(vals, type = T.unsafe(nil)); end

  # Returns the value of attribute validator.
  def validator; end

  # Returns the value of attribute wants_array.
  def wants_array; end

  class << self
    def detect_and_strip_from_string!(str); end
    def detect_from_string(str, chomp: T.unsafe(nil)); end
    def named(name); end
    def names; end
  end
end

class Ransack::Ransacker
  # @return [Ransacker] a new instance of Ransacker
  def initialize(klass, name, opts = T.unsafe(nil), &block); end

  # Returns the value of attribute args.
  def args; end

  def attr_from(bindable); end
  def call(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute formatter.
  def formatter; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute type.
  def type; end
end

Ransack::SUPPORTS_ATTRIBUTE_ALIAS = T.let(T.unsafe(nil), TrueClass)

class Ransack::Search
  include ::Ransack::Naming
  extend ::Ransack::ClassMethods

  # @return [Search] a new instance of Search
  def initialize(object, params = T.unsafe(nil), options = T.unsafe(nil)); end

  # Returns the value of attribute base.
  def base; end

  def build(params); end
  def build_condition(*_arg0, **_arg1, &_arg2); end
  def build_grouping(*_arg0, **_arg1, &_arg2); end
  def build_sort(opts = T.unsafe(nil)); end

  # Returns the value of attribute context.
  def context; end

  def inspect; end
  def klass(*_arg0, **_arg1, &_arg2); end
  def method_missing(method_id, *args); end
  def new_condition(*_arg0, **_arg1, &_arg2); end
  def new_grouping(*_arg0, **_arg1, &_arg2); end
  def new_sort(opts = T.unsafe(nil)); end
  def object(*_arg0, **_arg1, &_arg2); end
  def result(opts = T.unsafe(nil)); end
  def s; end
  def s=(args); end
  def sorts; end
  def sorts=(args); end
  def translate(*_arg0, **_arg1, &_arg2); end

  private

  def add_scope(key, args); end
  def collapse_multiparameter_attributes!(attrs); end
  def sanitized_scope_args(args); end
end

module Ransack::Translate
  class << self
    def association(key, options = T.unsafe(nil)); end
    def attribute(key, options = T.unsafe(nil)); end
    def i18n_key(klass); end
    def predicate(key, options = T.unsafe(nil)); end
    def word(key, options = T.unsafe(nil)); end

    private

    def associated_attribute(associated_class); end
    def association_name; end
    def attr_fallback_name(associated_class); end
    def attribute_name(context, name, include_associations = T.unsafe(nil)); end
    def build_interpolations(associated_class); end
    def default_attribute_name; end
    def default_interpolation(associated_class); end
    def fallback_args; end
    def fallback_class(associated_class); end
    def translated_ancestor_attributes; end
    def translated_attribute(associated_class); end
  end
end

class Ransack::UntraversableAssociationError < ::StandardError; end

class Ransack::Visitor
  def accept(object); end

  # @return [Boolean]
  def can_accept?(object); end

  # @return [Boolean]
  def quoted?(object); end

  def visit(object); end
  def visit_Array(object); end
  def visit_Ransack_Nodes_Condition(object); end
  def visit_Ransack_Nodes_Grouping(object); end
  def visit_Ransack_Nodes_Sort(object); end
  def visit_and(object); end
  def visit_or(object); end

  private

  def ordered(object); end
end

Ransack::Visitor::DISPATCH = T.let(T.unsafe(nil), Hash)

# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `activeadmin` gem.
# Please instead update this file by running `bin/tapioca gem activeadmin`.

# This is a common set of Formtastic overrides needed to build a filter form
# that lets you select from a set of search methods for a given attribute.
#
# Your class must declare available filters for this module to work.
# Those filters must be recognizable by Ransack. For example:
#
#   class NumericInput < ::Formtastic::Inputs::NumberInput
#     include Base
#     include Base::SearchMethodSelect
#
#     filter :equals, :greater_than, :less_than
#   end
module ActiveAdmin
  class << self
    # A callback is triggered each time (after) Active Admin loads the configuration files. This
    # is an opportunity to hook into Resources after they've been loaded.
    #
    # The block takes the current instance of [ActiveAdmin::Application]
    #
    # Example:
    #
    #     ActiveAdmin.after_load do |app|
    #       app.namespaces.each do |name, namespace|
    #         puts "Namespace: #{name} loaded!"
    #       end
    #     end
    #
    # @param block [Block] A block to call each time (after) AA loads resources
    def after_load(&block); end

    # Returns the value of attribute application.
    def application; end

    # Sets the attribute application
    #
    # @param value the value to set the attribute application to.
    def application=(_arg0); end

    # A callback is triggered each time (before) Active Admin loads the configuration files.
    # In development mode, this will happen whenever the user changes files. In production
    # it only happens on boot.
    #
    # The block takes the current instance of [ActiveAdmin::Application]
    #
    # Example:
    #
    #     ActiveAdmin.before_load do |app|
    #       # Do some stuff before AA loads
    #     end
    #
    # @param block [Block] A block to call each time (before) AA loads resources
    def before_load(&block); end

    def load!(*_arg0, **_arg1, &_arg2); end
    def register(*_arg0, **_arg1, &_arg2); end
    def register_page(*_arg0, **_arg1, &_arg2); end
    def routes(*_arg0, **_arg1, &_arg2); end

    # Gets called within the initializer
    #
    # @yield [application]
    def setup; end

    def unload!(*_arg0, **_arg1, &_arg2); end

    private

    def wrap_block_for_active_support_notifications(block); end
  end
end

class ActiveAdmin::AbstractViewFactory < ::ActiveAdmin::SettingsNode
  def [](key); end
  def []=(key, value); end
  def default_for(key); end

  # Register a new view key with the view factory
  #
  # eg:
  #
  #   factory = AbstractViewFactory.new
  #   factory.register my_view: SomeViewClass
  #
  # You can setup many at the same time:
  #
  #   factory.register  my_view: SomeClass,
  #                     another_view: OtherViewClass
  def register(view_hash); end

  class << self
    def add_writer(name); end
    def register(view_hash); end
  end
end

# Exception class to raise when there is an authorized access
# exception thrown. The exception has a few goodies that may
# be useful for capturing / recognizing security issues.
class ActiveAdmin::AccessDenied < ::StandardError
  # @return [AccessDenied] a new instance of AccessDenied
  def initialize(user, action, subject = T.unsafe(nil)); end

  # Returns the value of attribute action.
  def action; end

  def message; end

  # Returns the value of attribute subject.
  def subject; end

  # Returns the value of attribute user.
  def user; end
end

# Model class to store the data for ActionItems
class ActiveAdmin::ActionItem
  include ::ActiveAdmin::OptionalDisplay

  # @return [ActionItem] a new instance of ActionItem
  def initialize(name, options = T.unsafe(nil), &block); end

  # Returns the value of attribute block.
  def block; end

  # Sets the attribute block
  #
  # @param value the value to set the attribute block to.
  def block=(_arg0); end

  def html_class; end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end

  def priority; end
end

class ActiveAdmin::Application
  include ::ActiveAdmin::AssetRegistration

  # @return [Application] a new instance of Application
  def initialize; end

  def after_action(*args, &block); end
  def append_after_action(*args, &block); end
  def append_around_action(*args, &block); end
  def append_before_action(*args, &block); end
  def around_action(*args, &block); end
  def before_action(*args, &block); end
  def controllers_for_filters; end

  # Returns ALL the files to be loaded
  def files; end

  def load(file); end

  # Loads all ruby files that are within the load_paths setting.
  # To reload everything simply call `ActiveAdmin.unload!`
  def load!; end

  # Whether all configuration files have been loaded
  #
  # @return [Boolean]
  def loaded?; end

  def method_missing(method, *args); end

  # Creates a namespace for the given name
  #
  # Yields the namespace if a block is given
  #
  # @return [Namespace] the new or existing namespace
  # @yield [namespace]
  def namespace(name); end

  def namespace_settings; end

  # Returns the value of attribute namespaces.
  def namespaces; end

  # Runs after the app's AA initializer
  def prepare!; end

  def prepend_after_action(*args, &block); end
  def prepend_around_action(*args, &block); end
  def prepend_before_action(*args, &block); end

  # Registers a brand new configuration for the given resource.
  def register(resource, options = T.unsafe(nil), &block); end

  # Register a page
  #
  # @&block The registration block.
  #
  # @option [Hash]
  # @param name [String] The page name
  # @param [Hash] [Hash] a customizable set of options
  def register_page(name, options = T.unsafe(nil), &block); end

  # Creates all the necessary routes for the ActiveAdmin configurations
  #
  # Use this within the routes.rb file:
  #
  #   Application.routes.draw do |map|
  #     ActiveAdmin.routes(self)
  #   end
  #
  # @param rails_router [ActionDispatch::Routing::Mapper]
  def routes(rails_router); end

  def settings; end

  # Runs before the app's AA initializer
  def setup!; end

  def skip_after_action(*args, &block); end
  def skip_around_action(*args, &block); end
  def skip_before_action(*args, &block); end

  # Removes all defined controllers from memory. Useful in
  # development, where they are reloaded on each request.
  def unload!; end

  private

  # Hook into the Rails code reloading mechanism so that things are reloaded
  # properly in development mode.
  #
  # If any of the app files (e.g. models) has changed, we need to reload all
  # the admin files. If the admin files themselves has changed, we need to
  # regenerate the routes as well.
  def attach_reloader; end

  def register_default_assets; end

  # Since app/admin is alphabetically before app/models, we have to remove it
  # from the host app's +autoload_paths+ to prevent missing constant errors.
  #
  # As well, we have to remove it from +eager_load_paths+ to prevent the
  # files from being loaded twice in production.
  def remove_active_admin_load_paths_from_rails_autoload_and_eager_load; end

  # @return [Boolean]
  def respond_to_missing?(method, include_private = T.unsafe(nil)); end

  class << self
    def inheritable_setting(name, default); end
    def setting(name, default); end
  end
end

ActiveAdmin::Application::AfterLoadEvent = T.let(T.unsafe(nil), String)

# Event that gets triggered on load of Active Admin
ActiveAdmin::Application::BeforeLoadEvent = T.let(T.unsafe(nil), String)

class ActiveAdmin::ApplicationSettings < ::ActiveAdmin::SettingsNode
  def app_path; end
  def app_path=(_arg0); end
  def app_path?; end
  def default_namespace; end
  def default_namespace=(_arg0); end
  def default_namespace?; end
  def disable_streaming_in; end
  def disable_streaming_in=(_arg0); end
  def disable_streaming_in?; end
  def display_name_methods; end
  def display_name_methods=(_arg0); end
  def display_name_methods?; end
  def filter_attributes; end
  def filter_attributes=(_arg0); end
  def filter_attributes?; end
  def load_paths; end
  def load_paths=(_arg0); end
  def load_paths?; end
  def localize_format; end
  def localize_format=(_arg0); end
  def localize_format?; end

  class << self
    def app_path; end
    def app_path=(value); end
    def app_path?; end
    def default_namespace; end
    def default_namespace=(value); end
    def default_namespace?; end
    def disable_streaming_in; end
    def disable_streaming_in=(value); end
    def disable_streaming_in?; end
    def display_name_methods; end
    def display_name_methods=(value); end
    def display_name_methods?; end
    def filter_attributes; end
    def filter_attributes=(value); end
    def filter_attributes?; end
    def load_paths; end
    def load_paths=(value); end
    def load_paths?; end
    def localize_format; end
    def localize_format=(value); end
    def localize_format?; end
  end
end

module ActiveAdmin::AssetRegistration
  def clear_javascripts!; end
  def clear_stylesheets!; end
  def javascripts; end
  def register_javascript(name); end
  def register_stylesheet(path, options = T.unsafe(nil)); end
  def stylesheets; end
end

ActiveAdmin::Auth = ActiveAdmin::Authorization

# Default Authorization permissions for Active Admin
module ActiveAdmin::Authorization; end

ActiveAdmin::Authorization::CREATE = T.let(T.unsafe(nil), Symbol)
ActiveAdmin::Authorization::DESTROY = T.let(T.unsafe(nil), Symbol)
ActiveAdmin::Authorization::READ = T.let(T.unsafe(nil), Symbol)
ActiveAdmin::Authorization::UPDATE = T.let(T.unsafe(nil), Symbol)

# Active Admin's default authorization adapter. This adapter returns true
# for all requests to `#authorized?`. It should be the starting point for
# implementing your own authorization adapter.
#
# To view an example subclass, check out `ActiveAdmin::CanCanAdapter`
class ActiveAdmin::AuthorizationAdapter
  # Initialize a new authorization adapter. This happens on each and
  # every request to a controller.
  #
  # @param resource [ActiveAdmin::Resource, ActiveAdmin::Page] The resource
  #   that the user is currently on. Note, we may be authorizing access
  #   to a different subject, so don't rely on this other than to
  #   pull configuration information from.
  # @param user [any] The current user. The user is set to whatever is returned
  #   from `#current_active_admin_user` in the controller.
  # @return [AuthorizationAdapter] a new instance of AuthorizationAdapter
  def initialize(resource, user); end

  # Returns true of false depending on if the user is authorized to perform
  # the action on the subject.
  #
  # @param action [Symbol] The name of the action to perform. Usually this will be
  #   one of the `ActiveAdmin::Auth::*` symbols.
  # @param subject [any] The subject the action is being performed on usually this
  #   is a model object. Note, that this is NOT always in instance, it can be
  #   the class of the subject also. For example, Active Admin uses the class
  #   of the resource to decide if the resource should be displayed in the
  #   global navigation. To deal with this nicely in a case statement, take
  #   a look at `#normalized(klass)`
  # @return [Boolean]
  def authorized?(action, subject = T.unsafe(nil)); end

  # Returns the value of attribute resource.
  def resource; end

  # A hook method for authorization libraries to scope the collection. By
  # default, we just return the same collection. The returned scope is used
  # as the starting point for all queries to the db in the controller.
  #
  # @param collection [ActiveRecord::Relation] The collection the user is
  #   attempting to view.
  # @param action [Symbol] The name of the action to perform. Usually this will be
  #   one of the `ActiveAdmin::Auth::*` symbols. Defaults to `Auth::READ` if
  #   no action passed in.
  # @return [ActiveRecord::Relation] A new collection, scoped to the
  #   objects that the current user has access to.
  def scope_collection(collection, action = T.unsafe(nil)); end

  # Returns the value of attribute user.
  def user; end

  private

  # The `#authorized?` method's subject can be set to both instances as well
  # as classes of objects. This can make it much difficult to create simple
  # case statements for authorization since you have to handle both the
  # class level match and the instance level match.
  #
  # For example:
  #
  #     class MyAuthAdapter < ActiveAdmin::AuthorizationAdapter
  #
  #       def authorized?(action, subject = nil)
  #         case subject
  #         when Post
  #           true
  #         when Class
  #           if subject == Post
  #             true
  #           end
  #         end
  #       end
  #
  #     end
  #
  # To handle this, the normalized method takes care of returning a object
  # which implements `===` to be matched in a case statement.
  #
  # The above now becomes:
  #
  #     class MyAuthAdapter < ActiveAdmin::AuthorizationAdapter
  #
  #       def authorized?(action, subject = nil)
  #         case subject
  #         when normalized(Post)
  #           true
  #         end
  #       end
  #
  #     end
  def normalized(klass); end
end

class ActiveAdmin::AuthorizationAdapter::NormalizedMatcher
  # @return [NormalizedMatcher] a new instance of NormalizedMatcher
  def initialize(klass); end

  def ===(other); end
end

# CSVBuilder stores CSV configuration
#
# Usage example:
#
#   csv_builder = CSVBuilder.new
#   csv_builder.column :id
#   csv_builder.column("Name") { |resource| resource.full_name }
#   csv_builder.column(:name, humanize_name: false)
#   csv_builder.column("name", humanize_name: false) { |resource| resource.full_name }
#
#   csv_builder = CSVBuilder.new col_sep: ";"
#   csv_builder = CSVBuilder.new humanize_name: false
#   csv_builder.column :id
class ActiveAdmin::CSVBuilder
  # @return [CSVBuilder] a new instance of CSVBuilder
  def initialize(options = T.unsafe(nil), &block); end

  def build(controller, csv); end
  def build_row(resource, columns, options); end
  def column(name, options = T.unsafe(nil), &block); end

  # Returns the value of attribute columns.
  def columns; end

  def encode(content, options); end
  def exec_columns(view_context = T.unsafe(nil)); end
  def method_missing(method, *args, &block); end

  # Returns the value of attribute options.
  def options; end

  # Returns the value of attribute view_context.
  def view_context; end

  private

  def column_transitive_options; end

  class << self
    # Return a default CSVBuilder for a resource
    # The CSVBuilder's columns would be Id followed by this
    # resource's content columns
    def default_for_resource(resource); end
  end
end

ActiveAdmin::CSVBuilder::COLUMN_TRANSITIVE_OPTIONS = T.let(T.unsafe(nil), Array)

class ActiveAdmin::CSVBuilder::Column
  # @return [Column] a new instance of Column
  def initialize(name, resource = T.unsafe(nil), options = T.unsafe(nil), block = T.unsafe(nil)); end

  # Returns the value of attribute data.
  def data; end

  def humanize_name(name, resource, humanize_name_option); end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute options.
  def options; end
end

ActiveAdmin::CSVBuilder::Column::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

module ActiveAdmin::Callbacks
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveAdmin::Callbacks::ClassMethods

  private

  # Simple callback system. Implements before and after callbacks for
  # use within the controllers.
  #
  # We didn't use the ActiveSupport callbacks because they do not support
  # passing in any arbitrary object into the callback method (which we
  # need to do)
  def run_callback(method, *args); end
end

module ActiveAdmin::Callbacks::ClassMethods
  private

  # Define a new callback.
  #
  # Example:
  #
  #   class MyClassWithCallbacks
  #     include ActiveAdmin::Callbacks
  #
  #     define_active_admin_callbacks :save
  #
  #     before_save do |arg1, arg2|
  #       # runs before save
  #     end
  #
  #     after_save :call_after_save
  #
  #     def save
  #       # Will run before, yield, then after
  #       run_save_callbacks :arg1, :arg2 do
  #         save!
  #       end
  #     end
  #
  #     protected
  #
  #     def call_after_save(arg1, arg2)
  #       # runs after save
  #     end
  #   end
  def define_active_admin_callbacks(*names); end
end

# This class decorates a collection of objects delegating
# mehods to behave like an Array. It's used to decouple ActiveAdmin
# from Draper and thus being able to use PORO decorators as well.
#
# It's implementation is heavily based on the Draper::CollectionDecorator
# https://github.com/drapergem/draper/blob/aaa06bd2f1e219838b241a5534e7ca513edd1fe2/lib/draper/collection_decorator.rb
class ActiveAdmin::CollectionDecorator
  # @return [CollectionDecorator] a new instance of CollectionDecorator
  def initialize(object, with:); end

  def &(*_arg0, **_arg1, &_arg2); end
  def *(*_arg0, **_arg1, &_arg2); end
  def +(*_arg0, **_arg1, &_arg2); end
  def -(*_arg0, **_arg1, &_arg2); end
  def <<(*_arg0, **_arg1, &_arg2); end
  def ==(arg); end
  def [](*_arg0, **_arg1, &_arg2); end
  def []=(*_arg0, **_arg1, &_arg2); end
  def all?(*_arg0, **_arg1, &_arg2); end
  def any?(*_arg0, **_arg1, &_arg2); end
  def append(*_arg0, **_arg1, &_arg2); end
  def as_json(*_arg0, **_arg1, &_arg2); end
  def assoc(*_arg0, **_arg1, &_arg2); end
  def at(*_arg0, **_arg1, &_arg2); end
  def bsearch(*_arg0, **_arg1, &_arg2); end
  def bsearch_index(*_arg0, **_arg1, &_arg2); end
  def chain(*_arg0, **_arg1, &_arg2); end
  def chunk(*_arg0, **_arg1, &_arg2); end
  def chunk_while(*_arg0, **_arg1, &_arg2); end
  def clear(*_arg0, **_arg1, &_arg2); end
  def collect(*_arg0, **_arg1, &_arg2); end
  def collect!(*_arg0, **_arg1, &_arg2); end
  def collect_concat(*_arg0, **_arg1, &_arg2); end
  def combination(*_arg0, **_arg1, &_arg2); end
  def compact(*_arg0, **_arg1, &_arg2); end
  def compact!(*_arg0, **_arg1, &_arg2); end
  def compact_blank(*_arg0, **_arg1, &_arg2); end
  def compact_blank!(*_arg0, **_arg1, &_arg2); end
  def concat(*_arg0, **_arg1, &_arg2); end
  def count(*_arg0, **_arg1, &_arg2); end
  def cycle(*_arg0, **_arg1, &_arg2); end
  def deconstruct(*_arg0, **_arg1, &_arg2); end
  def decorated_collection; end

  # @return [Class] the decorator class used to decorate each item, as set by {#initialize}.
  def decorator_class; end

  def delete(*_arg0, **_arg1, &_arg2); end
  def delete_at(*_arg0, **_arg1, &_arg2); end
  def delete_if(*_arg0, **_arg1, &_arg2); end
  def detect(*_arg0, **_arg1, &_arg2); end
  def difference(*_arg0, **_arg1, &_arg2); end
  def dig(*_arg0, **_arg1, &_arg2); end
  def drop(*_arg0, **_arg1, &_arg2); end
  def drop_while(*_arg0, **_arg1, &_arg2); end
  def each(*_arg0, **_arg1, &_arg2); end
  def each_cons(*_arg0, **_arg1, &_arg2); end
  def each_entry(*_arg0, **_arg1, &_arg2); end
  def each_index(*_arg0, **_arg1, &_arg2); end
  def each_slice(*_arg0, **_arg1, &_arg2); end
  def each_with_index(*_arg0, **_arg1, &_arg2); end
  def each_with_object(*_arg0, **_arg1, &_arg2); end
  def empty?(*_arg0, **_arg1, &_arg2); end
  def entries(*_arg0, **_arg1, &_arg2); end
  def exclude?(*_arg0, **_arg1, &_arg2); end
  def excluding(*_arg0, **_arg1, &_arg2); end
  def extract!(*_arg0, **_arg1, &_arg2); end
  def extract_options!(*_arg0, **_arg1, &_arg2); end
  def fetch(*_arg0, **_arg1, &_arg2); end
  def fifth(*_arg0, **_arg1, &_arg2); end
  def fill(*_arg0, **_arg1, &_arg2); end
  def filter(*_arg0, **_arg1, &_arg2); end
  def filter!(*_arg0, **_arg1, &_arg2); end
  def filter_map(*_arg0, **_arg1, &_arg2); end
  def find(*_arg0, **_arg1, &_arg2); end
  def find_all(*_arg0, **_arg1, &_arg2); end
  def find_index(*_arg0, **_arg1, &_arg2); end
  def first(*_arg0, **_arg1, &_arg2); end
  def flat_map(*_arg0, **_arg1, &_arg2); end
  def flatten(*_arg0, **_arg1, &_arg2); end
  def flatten!(*_arg0, **_arg1, &_arg2); end
  def forty_two(*_arg0, **_arg1, &_arg2); end
  def fourth(*_arg0, **_arg1, &_arg2); end
  def from(*_arg0, **_arg1, &_arg2); end
  def grep(*_arg0, **_arg1, &_arg2); end
  def grep_v(*_arg0, **_arg1, &_arg2); end
  def group_by(*_arg0, **_arg1, &_arg2); end
  def in_groups(*_arg0, **_arg1, &_arg2); end
  def in_groups_of(*_arg0, **_arg1, &_arg2); end
  def in_order_of(*_arg0, **_arg1, &_arg2); end
  def include?(*_arg0, **_arg1, &_arg2); end
  def including(*_arg0, **_arg1, &_arg2); end
  def index(*_arg0, **_arg1, &_arg2); end
  def index_by(*_arg0, **_arg1, &_arg2); end
  def index_with(*_arg0, **_arg1, &_arg2); end
  def inject(*_arg0, **_arg1, &_arg2); end
  def inquiry(*_arg0, **_arg1, &_arg2); end
  def insert(*_arg0, **_arg1, &_arg2); end
  def intersect?(*_arg0, **_arg1, &_arg2); end
  def intersection(*_arg0, **_arg1, &_arg2); end
  def join(*_arg0, **_arg1, &_arg2); end
  def keep_if(*_arg0, **_arg1, &_arg2); end
  def last(*_arg0, **_arg1, &_arg2); end
  def lazy(*_arg0, **_arg1, &_arg2); end
  def length(*_arg0, **_arg1, &_arg2); end
  def many?(*_arg0, **_arg1, &_arg2); end
  def map(*_arg0, **_arg1, &_arg2); end
  def map!(*_arg0, **_arg1, &_arg2); end
  def max(*_arg0, **_arg1, &_arg2); end
  def max_by(*_arg0, **_arg1, &_arg2); end
  def maximum(*_arg0, **_arg1, &_arg2); end
  def member?(*_arg0, **_arg1, &_arg2); end
  def min(*_arg0, **_arg1, &_arg2); end
  def min_by(*_arg0, **_arg1, &_arg2); end
  def minimum(*_arg0, **_arg1, &_arg2); end
  def minmax(*_arg0, **_arg1, &_arg2); end
  def minmax_by(*_arg0, **_arg1, &_arg2); end
  def none?(*_arg0, **_arg1, &_arg2); end

  # @return the collection being decorated.
  def object; end

  def one?(*_arg0, **_arg1, &_arg2); end
  def pack(*_arg0, **_arg1, &_arg2); end
  def partition(*_arg0, **_arg1, &_arg2); end
  def permutation(*_arg0, **_arg1, &_arg2); end
  def pick(*_arg0, **_arg1, &_arg2); end
  def place(*_arg0, **_arg1, &_arg2); end
  def pluck(*_arg0, **_arg1, &_arg2); end
  def pop(*_arg0, **_arg1, &_arg2); end
  def prepend(*_arg0, **_arg1, &_arg2); end
  def product(*_arg0, **_arg1, &_arg2); end
  def push(*_arg0, **_arg1, &_arg2); end
  def rassoc(*_arg0, **_arg1, &_arg2); end
  def reduce(*_arg0, **_arg1, &_arg2); end
  def reject(*_arg0, **_arg1, &_arg2); end
  def reject!(*_arg0, **_arg1, &_arg2); end
  def repeated_combination(*_arg0, **_arg1, &_arg2); end
  def repeated_permutation(*_arg0, **_arg1, &_arg2); end
  def replace(*_arg0, **_arg1, &_arg2); end
  def reverse(*_arg0, **_arg1, &_arg2); end
  def reverse!(*_arg0, **_arg1, &_arg2); end
  def reverse_each(*_arg0, **_arg1, &_arg2); end
  def rindex(*_arg0, **_arg1, &_arg2); end
  def rotate(*_arg0, **_arg1, &_arg2); end
  def rotate!(*_arg0, **_arg1, &_arg2); end
  def sample(*_arg0, **_arg1, &_arg2); end
  def second(*_arg0, **_arg1, &_arg2); end
  def second_to_last(*_arg0, **_arg1, &_arg2); end
  def select(*_arg0, **_arg1, &_arg2); end
  def select!(*_arg0, **_arg1, &_arg2); end
  def shelljoin(*_arg0, **_arg1, &_arg2); end
  def shift(*_arg0, **_arg1, &_arg2); end
  def shuffle(*_arg0, **_arg1, &_arg2); end
  def shuffle!(*_arg0, **_arg1, &_arg2); end
  def size(*_arg0, **_arg1, &_arg2); end
  def slice(*_arg0, **_arg1, &_arg2); end
  def slice!(*_arg0, **_arg1, &_arg2); end
  def slice_after(*_arg0, **_arg1, &_arg2); end
  def slice_before(*_arg0, **_arg1, &_arg2); end
  def slice_when(*_arg0, **_arg1, &_arg2); end
  def sole(*_arg0, **_arg1, &_arg2); end
  def sort(*_arg0, **_arg1, &_arg2); end
  def sort!(*_arg0, **_arg1, &_arg2); end
  def sort_by(*_arg0, **_arg1, &_arg2); end
  def sort_by!(*_arg0, **_arg1, &_arg2); end
  def split(*_arg0, **_arg1, &_arg2); end
  def sum(*_arg0, **_arg1, &_arg2); end
  def take(*_arg0, **_arg1, &_arg2); end
  def take_while(*_arg0, **_arg1, &_arg2); end
  def tally(*_arg0, **_arg1, &_arg2); end
  def third(*_arg0, **_arg1, &_arg2); end
  def third_to_last(*_arg0, **_arg1, &_arg2); end
  def to(*_arg0, **_arg1, &_arg2); end
  def to_a(*_arg0, **_arg1, &_arg2); end
  def to_ary(*_arg0, **_arg1, &_arg2); end
  def to_default_s(*_arg0, **_arg1, &_arg2); end
  def to_formatted_s(*_arg0, **_arg1, &_arg2); end
  def to_fs(*_arg0, **_arg1, &_arg2); end
  def to_h(*_arg0, **_arg1, &_arg2); end
  def to_msgpack(*_arg0, **_arg1, &_arg2); end
  def to_sentence(*_arg0, **_arg1, &_arg2); end
  def to_set(*_arg0, **_arg1, &_arg2); end
  def to_xml(*_arg0, **_arg1, &_arg2); end
  def transpose(*_arg0, **_arg1, &_arg2); end
  def union(*_arg0, **_arg1, &_arg2); end
  def uniq(*_arg0, **_arg1, &_arg2); end
  def uniq!(*_arg0, **_arg1, &_arg2); end
  def unshift(*_arg0, **_arg1, &_arg2); end
  def values_at(*_arg0, **_arg1, &_arg2); end
  def without(*_arg0, **_arg1, &_arg2); end
  def zip(*_arg0, **_arg1, &_arg2); end
  def |(*_arg0, **_arg1, &_arg2); end

  class << self
    def decorate(*_arg0); end
  end
end

class ActiveAdmin::Comment < ::ActiveRecord::Base
  include ::ActiveAdmin::Comment::GeneratedAttributeMethods
  include ::ActiveAdmin::Comment::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
  extend ::Kaminari::ConfigurationMethods::ClassMethods

  def autosave_associated_records_for_author(*args); end
  def autosave_associated_records_for_resource(*args); end
  def set_resource_type; end

  class << self
    def __callbacks; end
    def _reflections; end
    def _validators; end
    def defined_enums; end
    def find_for_resource_in_namespace(resource, namespace); end
    def page(num = T.unsafe(nil)); end

    # @return [String] The name of the record to use for the polymorphic relationship
    def resource_type(resource); end
  end
end

module ActiveAdmin::Comment::GeneratedAssociationMethods
  def author; end
  def author=(value); end
  def author_changed?; end
  def author_previously_changed?; end
  def reload_author; end
  def reload_resource; end
  def resource; end
  def resource=(value); end
  def resource_changed?; end
  def resource_previously_changed?; end
end

module ActiveAdmin::Comment::GeneratedAttributeMethods; end
module ActiveAdmin::Comments; end

module ActiveAdmin::Comments::NamespaceHelper
  # Returns true if the namespace allows comments
  #
  # @return [Boolean]
  def comments?; end
end

module ActiveAdmin::Comments::ResourceHelper
  extend ::ActiveSupport::Concern

  # @return [Boolean]
  def comments?; end
end

# Adds #active_admin_comments to the show page for use
# and sets it up on the default main content
module ActiveAdmin::Comments::ShowPageHelper
  # Display the comments for the resource. Same as calling
  # #active_admin_comments_for with the current resource
  def active_admin_comments(*args, &block); end

  # Add admin comments to the main content if they are
  # turned on for the current resource
  def default_main_content; end
end

module ActiveAdmin::Comments::Views; end

class ActiveAdmin::Comments::Views::Comments < ::ActiveAdmin::Views::Panel
  def build(resource); end

  # Returns the value of attribute resource.
  def resource; end

  # Sets the attribute resource
  #
  # @param value the value to set the attribute resource to.
  def resource=(_arg0); end

  protected

  def build_comment(comment); end
  def build_comment_form; end
  def build_comments; end
  def build_empty_message; end
  def comment_form_url; end
  def comments_url(*args); end
  def default_id_for_prefix; end
  def title; end
end

class ActiveAdmin::Component < ::Arbre::Component; end

class ActiveAdmin::ControllerAction
  # @return [ControllerAction] a new instance of ControllerAction
  def initialize(name, options = T.unsafe(nil)); end

  def http_verb; end

  # Returns the value of attribute name.
  def name; end
end

ActiveAdmin::DEFAULT_MENU = T.let(T.unsafe(nil), Symbol)

# The Active Admin DSL. This class is where all the registration blocks
# are evaluated. This is the central place for the API given to
# users of Active Admin.
class ActiveAdmin::DSL
  # @return [DSL] a new instance of DSL
  def initialize(config); end

  # Add a new action item to the resource
  #
  # @param name [Symbol]
  # @param options [Hash] valid keys include:
  #   :only:  A single or array of controller actions to display
  #   this action item on.
  #   :except: A single or array of controller actions not to
  #   display this action item on.
  def action_item(name, options = T.unsafe(nil), &block); end

  # Add a new batch action item to the resource
  # Provide a symbol/string to register the action, options, & block to execute on request
  #
  # To unregister an existing action, just provide the symbol & pass false as the second param
  #
  # => :if is a proc that will be called to determine if the BatchAction should be displayed
  # => :sort_order is used to sort the batch actions ascending
  # => :confirm is a string which the user will have to accept in order to process the action
  #
  # @param title [Symbol or String]
  # @param options [Hash] valid keys include:
  def batch_action(title, options = T.unsafe(nil), &block); end

  # Rewrite breadcrumb links.
  # Block will be executed inside controller.
  # Block must return an array if you want to rewrite breadcrumb links.
  #
  # Example:
  #   ActiveAdmin.register Post do
  #
  #     breadcrumb do
  #       [
  #         link_to('my piece', '/my/link/to/piece')
  #       ]
  #     end
  #   end
  def breadcrumb(&block); end

  # The instance of ActiveAdmin::Resource that's being registered
  # currently. You can use this within your registration blocks to
  # modify options:
  #
  # eg:
  #
  #   ActiveAdmin.register Post do
  #     config.sort_order = "id_desc"
  #   end
  def config; end

  # Returns the controller for this resource. If you pass a
  # block, it will be evaluated in the controller.
  #
  # Example:
  #
  #   ActiveAdmin.register Post do
  #
  #     controller do
  #       def some_method_on_controller
  #         # Method gets added to Admin::PostsController
  #       end
  #     end
  #
  #   end
  def controller(&block); end

  # Include a module with this resource. The modules's `included` method
  # is called with the instance of the `ActiveAdmin::DSL` passed into it.
  #
  # eg:
  #
  #   module HelpSidebar
  #
  #     def self.included(dsl)
  #       dsl.sidebar "Help" do
  #         "Call us for Help"
  #       end
  #     end
  #
  #   end
  #
  #   ActiveAdmin.register Post do
  #     include HelpSidebar
  #   end
  #
  # @param mod [Module] A module to include
  # @return [Nil]
  def include(mod); end

  # Set the options that are available for the item that will be placed in the global
  # navigation of the menu.
  def menu(options = T.unsafe(nil)); end

  # Set the name of the navigation menu to display. This is mainly used in conjunction with the
  # `#belongs_to` functionality.
  #
  # Pass a block returning the name of a menu you want rendered for the request, being
  # executed in the context of the controller
  #
  # @param menu_name [Symbol] The name of the menu to display as the global navigation
  #   when viewing this resource. Defaults to a menu named `:default`.
  def navigation_menu(menu_name = T.unsafe(nil), &block); end

  # Runs the registration block inside this object
  def run_registration_block(&block); end

  def sidebar(name, options = T.unsafe(nil), &block); end
end

class ActiveAdmin::DatabaseHitDuringLoad < ::ActiveAdmin::ErrorLoading
  # @return [DatabaseHitDuringLoad] a new instance of DatabaseHitDuringLoad
  def initialize(exception); end

  class << self
    def capture; end
    def database_error_classes; end
  end
end

module ActiveAdmin::Dependency
  class << self
    def [](name); end

    # Provides a clean interface to check for gem dependencies at runtime.
    #
    # ActiveAdmin::Dependency.rails
    # => #<ActiveAdmin::Dependency::Matcher for rails 6.0.3.2>
    #
    # ActiveAdmin::Dependency.rails?
    # => true
    #
    # ActiveAdmin::Dependency.rails? '>= 6.1'
    # => false
    #
    # ActiveAdmin::Dependency.rails? '= 6.0.3.2'
    # => true
    #
    # ActiveAdmin::Dependency.rails? '~> 6.0.3'
    # => true
    #
    # ActiveAdmin::Dependency.rails? '>= 6.0.3', '<= 6.1.0'
    # => true
    #
    # ActiveAdmin::Dependency.rails! '5'
    # -> ActiveAdmin::DependencyError: You provided rails 4.2.7 but we need: 5.
    #
    # ActiveAdmin::Dependency.devise!
    # -> ActiveAdmin::DependencyError: To use devise you need to specify it in your Gemfile.
    #
    #
    # All but the pessimistic operator (~>) can also be run using Ruby's comparison syntax.
    #
    # ActiveAdmin::Dependency.rails >= '4.2.7'
    # => true
    #
    # Which is especially useful if you're looking up a gem with dashes in the name.
    #
    # ActiveAdmin::Dependency['jquery-rails'] < 5
    # => false
    def method_missing(name, *args); end

    # @return [Boolean]
    def supports_zeitwerk?; end
  end
end

class ActiveAdmin::Dependency::Matcher
  include ::Comparable

  # @return [Matcher] a new instance of Matcher
  def initialize(name); end

  def <=>(other); end
  def inspect; end
  def match!(*reqs); end

  # @return [Boolean]
  def match?(*reqs); end

  # Returns the value of attribute name.
  def name; end

  def spec; end
  def spec!; end
end

module ActiveAdmin::Dependency::Requirements; end
ActiveAdmin::Dependency::Requirements::DEVISE = T.let(T.unsafe(nil), Array)
class ActiveAdmin::DependencyError < ::ActiveAdmin::ErrorLoading; end

module ActiveAdmin::Deprecation
  private

  def warn(message, callstack = T.unsafe(nil)); end

  class << self
    def warn(message, callstack = T.unsafe(nil)); end
  end
end

class ActiveAdmin::DynamicSetting
  # @return [DynamicSetting] a new instance of DynamicSetting
  def initialize(setting); end

  def value(*_args); end

  class << self
    def build(setting, type); end

    # @raise [ArgumentError]
    def klass(type); end
  end
end

class ActiveAdmin::DynamicSettingsNode < ::ActiveAdmin::SettingsNode
  class << self
    def add_reader(name); end
    def add_writer(name, type); end
    def register(name, value, type = T.unsafe(nil)); end
  end
end

class ActiveAdmin::Engine < ::Rails::Engine; end
class ActiveAdmin::Error < ::RuntimeError; end

class ActiveAdmin::ErrorLoading < ::ActiveAdmin::Error
  # Locates the most recent file and line from the caught exception's backtrace.
  def find_cause(folder, backtrace); end
end

module ActiveAdmin::Filters; end

class ActiveAdmin::Filters::Active
  # @param resource [ActiveAdmin::Resource] current resource
  # @param search [Ransack::Search] search object
  # @return [Active] a new instance of Active
  # @see ActiveAdmin::ResourceController::DataAcces#apply_filtering
  def initialize(resource, search); end

  # Returns the value of attribute filters.
  def filters; end

  # Sets the attribute filters
  #
  # @param value the value to set the attribute filters to.
  def filters=(_arg0); end

  # Returns the value of attribute resource.
  def resource; end

  # Sets the attribute resource
  #
  # @param value the value to set the attribute resource to.
  def resource=(_arg0); end

  private

  def build_filters(conditions); end
end

class ActiveAdmin::Filters::ActiveFilter
  include ::ActiveAdmin::ViewHelpers::ActiveAdminApplicationHelper
  include ::ActiveAdmin::ViewHelpers::AutoLinkHelper
  include ::ActiveAdmin::ViewHelpers::BreadcrumbHelper
  include ::ActiveAdmin::ViewHelpers::DisplayHelper
  include ::MethodOrProcHelper
  include ::ActiveAdmin::ViewHelpers::SidebarHelper
  include ::ActiveAdmin::ViewHelpers::FormHelper
  include ::ActiveAdmin::ViewHelpers::TitleHelper
  include ::ActiveAdmin::ViewHelpers::ViewFactoryHelper
  include ::ActiveAdmin::ViewHelpers::FlashHelper
  include ::ActiveAdmin::ViewHelpers::ScopeNameHelper
  include ::ActiveAdmin::Filters::ViewHelper
  include ::ActiveAdmin::ViewHelpers

  # Instantiate a `ActiveFilter`
  #
  # @param resource [ActiveAdmin::Resource] current resource
  # @param condition [Ransack::Nodes::Condition] applied ransack condition
  # @return [ActiveFilter] a new instance of ActiveFilter
  def initialize(resource, condition); end

  # Returns the value of attribute condition.
  def condition; end

  def html_options; end
  def label; end
  def predicate_name; end

  # Returns the value of attribute related_class.
  def related_class; end

  # Returns the value of attribute resource.
  def resource; end

  def values; end

  private

  def attribute_name; end

  # @return Ransack::Nodes::Attribute
  def condition_attribute; end

  def filter; end
  def filter_label; end

  # detect related class for Ransack::Nodes::Attribute
  def find_class; end

  # @return [Boolean]
  def find_class?; end

  def find_predicate_association; end
  def name; end
  def predicate_association; end
  def ransack_predicate_name; end
  def related_class_name; end
  def related_primary_key; end
  def resource_class; end
end

class ActiveAdmin::Filters::ActiveSidebar < ::ActiveAdmin::SidebarSection
  # @return [ActiveSidebar] a new instance of ActiveSidebar
  def initialize; end

  def block; end
  def title; end

  protected

  def sidebar_options; end
end

module ActiveAdmin::Filters::DSL
  # For docs, please see ActiveAdmin::Filters::ResourceExtension#add_filter
  def filter(attribute, options = T.unsafe(nil)); end

  # For docs, please see ActiveAdmin::Filters::ResourceExtension#preserve_default_filters!
  def preserve_default_filters!; end

  # For docs, please see ActiveAdmin::Filters::ResourceExtension#remove_filter
  def remove_filter(*attributes); end
end

class ActiveAdmin::Filters::Disabled < ::RuntimeError
  # @return [Disabled] a new instance of Disabled
  def initialize; end
end

# This form builder defines methods to build filter forms such
# as the one found in the sidebar of the index page of a standard resource.
class ActiveAdmin::Filters::FormBuilder < ::ActiveAdmin::FormBuilder
  include ::ActiveAdmin::Filters::FormtasticAddons

  def filter(method, options = T.unsafe(nil)); end

  protected

  # Returns the default filter type for a given attribute. If you want
  # to use a custom search method, you have to specify the type yourself.
  def default_input_type(method, options = T.unsafe(nil)); end

  class << self
    def input_class_finder; end
    def input_namespaces; end
  end
end

module ActiveAdmin::Filters::FormtasticAddons
  def column; end
  def column_for(method); end

  # If the given method has a predicate (like _eq or _lteq), it's pretty
  # likely we're dealing with a valid search method.
  #
  # @return [Boolean]
  def has_predicate?; end

  # The below are Formtastic method overrides that jump inside of the Ransack
  # search object to get at the object being searched upon.
  def humanized_method_name; end

  # The resource class, unwrapped from Ransack
  def klass; end

  # @return [Boolean]
  def polymorphic_foreign_type?(method); end

  def reflection_for(method); end

  # Ransack supports exposing selected scopes on your model for advanced searches.
  #
  # @return [Boolean]
  def scope?; end

  # These help figure out whether the given method or association will be recognized by Ransack.
  #
  # @return [Boolean]
  def searchable_has_many_through?; end

  # @return [Boolean]
  def seems_searchable?; end
end

module ActiveAdmin::Filters::ResourceExtension
  def initialize(*_arg0); end

  # Add a filter for this resource. If filters are not enabled, this method
  # will raise a RuntimeError
  #
  # @param attribute [Symbol] The attribute to filter on
  # @param options [Hash] The set of options that are passed through to
  #   ransack for the field definition.
  # @raise [Disabled]
  def add_filter(attribute, options = T.unsafe(nil)); end

  # Setter to enable/disable showing current filters on this resource.
  #
  # Set to `nil` to inherit the setting from the namespace
  def current_filters=(bool); end

  # @return [Boolean] If show current filters are enabled for this resource
  def current_filters_enabled?; end

  # Returns the filters for this resource. If filters are not enabled,
  # it will always return an empty hash.
  #
  # @return [Hash] Filters that apply for this resource
  def filters; end

  # Setter to enable / disable filters on this resource.
  #
  # Set to `nil` to inherit the setting from the namespace
  def filters=(bool); end

  # @return [Boolean] If filters are enabled for this resource
  def filters_enabled?; end

  def preserve_default_filters!; end

  # @return [Boolean]
  def preserve_default_filters?; end

  # Remove a filter for this resource. If filters are not enabled, this method
  # will raise a RuntimeError
  #
  # @param attributes [Symbol] The attributes to not filter on
  # @raise [Disabled]
  def remove_filter(*attributes); end

  # Reset the filters to use defaults
  def reset_filters!; end

  private

  def add_filters_sidebar_section; end
  def add_search_status_sidebar_section; end
  def custom_ransack_filters; end

  # Returns a default set of filters for the associations
  def default_association_filters; end

  # @return [Array] The array of default filters for this resource
  def default_filters; end

  # Collapses the waveform, if you will, of which filters should be displayed.
  # Removes filters and adds in default filters as desired.
  def filter_lookup; end

  def filters_sidebar_section; end
  def search_columns; end
  def searchable_column_for(relation); end
end

# This module is included into the view
module ActiveAdmin::Filters::ViewHelper
  # Helper method to render a filter form
  def active_admin_filters_form_for(search, filters, options = T.unsafe(nil)); end

  private

  def except_hidden_fields; end
end

class ActiveAdmin::FormBuilder < ::Formtastic::FormBuilder
  # Returns the value of attribute already_in_an_inputs_block.
  def already_in_an_inputs_block; end

  # Sets the attribute already_in_an_inputs_block
  #
  # @param value the value to set the attribute already_in_an_inputs_block to.
  def already_in_an_inputs_block=(_arg0); end

  def cancel_link(url = T.unsafe(nil), html_options = T.unsafe(nil), li_attrs = T.unsafe(nil)); end
  def has_many(assoc, options = T.unsafe(nil), &block); end

  class << self
    def action_class_finder; end
    def input_class_finder; end
    def input_namespaces; end
  end
end

class ActiveAdmin::GeneratorError < ::ActiveAdmin::Error; end

# Decorates a FormBuilder with the additional attributes and methods
# to build a has_many block.  Nested has_many blocks are handled by
# nested decorators.
class ActiveAdmin::HasManyBuilder < ::SimpleDelegator
  # @return [HasManyBuilder] a new instance of HasManyBuilder
  def initialize(has_many_form, assoc, options); end

  # Returns the value of attribute assoc.
  def assoc; end

  # Returns the value of attribute destroy_option.
  def destroy_option; end

  # Returns the value of attribute heading.
  def heading; end

  # Returns the value of attribute new_record.
  def new_record; end

  # Returns the value of attribute options.
  def options; end

  # Returns the value of attribute remove_record.
  def remove_record; end

  def render(&block); end

  # Returns the value of attribute sortable_column.
  def sortable_column; end

  # Returns the value of attribute sortable_start.
  def sortable_start; end

  protected

  # @return [Boolean]
  def allow_destroy?(form_object); end

  def assoc_klass; end
  def content_has_many(&block); end
  def default_heading; end

  # remove options that should not render as attributes
  def extract_custom_settings!(options); end

  def has_many_actions(form_builder, contents); end

  # Capture the ADD JS
  def js_for_has_many(class_string, &form_block); end

  # Renders the Formtastic inputs then appends ActiveAdmin delete and sort actions.
  def render_has_many_form(form_builder, parent, &block); end

  def sorted_children(column); end
  def without_wrapper; end
  def wrap_div_or_li(html); end
end

module ActiveAdmin::Helpers; end

module ActiveAdmin::Helpers::Collection
  # @return [Boolean]
  def collection_is_empty?(c = T.unsafe(nil)); end

  # 1. removes `select` and `order` to prevent invalid SQL
  # 2. correctly handles the Hash returned when `group by` is used
  def collection_size(c = T.unsafe(nil)); end
end

module ActiveAdmin::Helpers::I18n; end
ActiveAdmin::Helpers::I18n::PLURAL_MANY_COUNT = T.let(T.unsafe(nil), Float)

module ActiveAdmin::Inputs
  extend ::ActiveSupport::Autoload
end

class ActiveAdmin::Inputs::DatepickerInput < ::Formtastic::Inputs::StringInput
  def input_html_options; end

  # Can pass proc to filter label option
  def label_from_options; end

  private

  def datepicker_options; end
end

module ActiveAdmin::Inputs::Filters
  extend ::ActiveSupport::Autoload
end

module ActiveAdmin::Inputs::Filters::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base
  include ::ActiveAdmin::Filters::FormtasticAddons
  extend ::ActiveSupport::Autoload

  # Override the standard finder to accept a proc
  def collection_from_options; end

  def input_wrapping(&block); end

  # Can pass proc to filter label option
  def label_from_options; end

  # @return [Boolean]
  def required?; end

  def wrapper_html_options; end
end

module ActiveAdmin::Inputs::Filters::Base::SearchMethodSelect
  mixes_in_class_methods ::ActiveAdmin::Inputs::Filters::Base::SearchMethodSelect::ClassMethods

  def current_filter; end
  def filter_options; end
  def filters; end
  def input_html; end
  def select_html; end
  def to_html; end
  def wrapper_html_options; end

  class << self
    # @private
    def included(base); end
  end
end

module ActiveAdmin::Inputs::Filters::Base::SearchMethodSelect::ClassMethods
  def filter(*filters); end

  # Returns the value of attribute filters.
  def filters; end
end

class ActiveAdmin::Inputs::Filters::BooleanInput < ::Formtastic::Inputs::SelectInput
  include ::ActiveAdmin::Filters::FormtasticAddons
  include ::ActiveAdmin::Inputs::Filters::Base

  # Provide the AA translation to the blank input field.
  def include_blank; end

  def input_html_options_name; end
  def input_name; end
end

class ActiveAdmin::Inputs::Filters::CheckBoxesInput < ::Formtastic::Inputs::CheckBoxesInput
  include ::ActiveAdmin::Filters::FormtasticAddons
  include ::ActiveAdmin::Inputs::Filters::Base

  # Add whitespace before label
  def choice_label(choice); end

  # Don't wrap in LI tag
  def choice_wrapping(html_options, &block); end

  # Don't wrap in UL tag
  def choices_group_wrapping(&block); end

  # Don't render hidden fields
  def hidden_field_for_all; end

  # Don't render hidden fields
  #
  # @return [Boolean]
  def hidden_fields?; end

  def input_name; end
  def searchable_method_name; end
  def selected_values; end
end

class ActiveAdmin::Inputs::Filters::DatePickerInput < ::Formtastic::Inputs::DatePickerInput
  include ::ActiveAdmin::Filters::FormtasticAddons
  include ::ActiveAdmin::Inputs::Filters::Base

  def input_html_options; end
end

class ActiveAdmin::Inputs::Filters::DateRangeInput < ::Formtastic::Inputs::StringInput
  include ::ActiveAdmin::Filters::FormtasticAddons
  include ::ActiveAdmin::Inputs::Filters::Base

  def gt_input_name; end
  def gt_input_placeholder; end
  def input_html_options; end
  def input_html_options_for(input_name, placeholder); end
  def input_name; end
  def lt_input_name; end
  def lt_input_placeholder; end
  def to_html; end
end

class ActiveAdmin::Inputs::Filters::NumericInput < ::Formtastic::Inputs::NumberInput
  include ::ActiveAdmin::Filters::FormtasticAddons
  include ::ActiveAdmin::Inputs::Filters::Base
  include ::ActiveAdmin::Inputs::Filters::Base::SearchMethodSelect
  extend ::ActiveAdmin::Inputs::Filters::Base::SearchMethodSelect::ClassMethods
end

class ActiveAdmin::Inputs::Filters::SelectInput < ::Formtastic::Inputs::SelectInput
  include ::ActiveAdmin::Filters::FormtasticAddons
  include ::ActiveAdmin::Inputs::Filters::Base

  # Provides an efficient default lookup query if the attribute is a DB column.
  def collection; end

  # Provide the AA translation to the blank input field.
  def include_blank; end

  def input_html_options_name; end
  def input_name; end

  # Would normally return true for has_many and HABTM, which would subsequently
  # cause the select field to be multi-select instead of a dropdown.
  #
  # @return [Boolean]
  def multiple_by_association?; end

  def pluck_column; end

  # @return [Boolean]
  def reflection_searchable?; end

  def searchable_method_name; end
end

class ActiveAdmin::Inputs::Filters::StringInput < ::Formtastic::Inputs::StringInput
  include ::ActiveAdmin::Filters::FormtasticAddons
  include ::ActiveAdmin::Inputs::Filters::Base
  include ::ActiveAdmin::Inputs::Filters::Base::SearchMethodSelect
  extend ::ActiveAdmin::Inputs::Filters::Base::SearchMethodSelect::ClassMethods

  # If the filter method includes a search condition, build a normal string search field.
  # Else, build a search field with a companion dropdown to choose a search condition from.
  def to_html; end
end

class ActiveAdmin::Inputs::Filters::TextInput < ::Formtastic::Inputs::TextInput
  include ::ActiveAdmin::Filters::FormtasticAddons
  include ::ActiveAdmin::Inputs::Filters::Base
  include ::ActiveAdmin::Inputs::Filters::Base::SearchMethodSelect
  extend ::ActiveAdmin::Inputs::Filters::Base::SearchMethodSelect::ClassMethods

  def input_html_options; end
  def to_html; end
end

module ActiveAdmin::Localizers
  class << self
    def resource(active_admin_config); end
  end
end

class ActiveAdmin::Localizers::ResourceLocalizer
  # @return [ResourceLocalizer] a new instance of ResourceLocalizer
  def initialize(model_name, model = T.unsafe(nil)); end

  def t(key, options = T.unsafe(nil)); end
  def translate(key, options = T.unsafe(nil)); end

  protected

  def array_to_key(*arr); end

  class << self
    def from_resource(resource_config); end
    def t(key, options); end
    def translate(key, options); end
  end
end

# Each Namespace builds up it's own menu as the global navigation
#
# To build a new menu:
#
#   menu = Menu.new do |m|
#     m.add label: 'Dashboard', url: '/'
#     m.add label: 'Users',     url: '/users'
#   end
#
# If you're interested in configuring a menu item, take a look at the
# options available in `ActiveAdmin::MenuItem`
class ActiveAdmin::Menu
  include ::ActiveAdmin::Menu::MenuNode

  # @return [Menu] a new instance of Menu
  # @yield [_self]
  # @yieldparam _self [ActiveAdmin::Menu] the object that the method was called on
  def initialize; end
end

module ActiveAdmin::Menu::MenuNode
  def initialize; end

  def [](id); end
  def []=(id, child); end

  # Recursively builds any given menu items. There are two syntaxes supported,
  # as shown in the below examples. Both create an identical menu structure.
  #
  # Example 1:
  #   menu = Menu.new
  #   menu.add label: 'Dashboard' do |dash|
  #     dash.add label: 'My Child Dashboard'
  #   end
  #
  # Example 2:
  #   menu = Menu.new
  #   menu.add label:  'Dashboard'
  #   menu.add parent: 'Dashboard', label: 'My Child Dashboard'
  #
  # @yield [item]
  def add(options); end

  # Returns the value of attribute children.
  def children; end

  # Used in the UI to visually distinguish which menu item is selected.
  #
  # @return [Boolean]
  def current?(item); end

  # Whether any children match the given item.
  #
  # @return [Boolean]
  def include?(item); end

  def items; end

  private

  # The method that actually adds new menu items. Called by the public method.
  # If this ID is already taken, transfer the children of the existing item to the new item.
  def _add(options); end

  # Sets the attribute children
  #
  # @param value the value to set the attribute children to.
  def children=(_arg0); end

  def normalize_id(id); end
end

# A MenuCollection stores multiple menus for any given namespace. Namespaces delegate
# the addition of menu items to this class.
class ActiveAdmin::MenuCollection
  # @return [MenuCollection] a new instance of MenuCollection
  def initialize; end

  # Add a new menu item to a menu in the collection
  def add(menu_name, menu_item_options = T.unsafe(nil)); end

  # Add callbacks that will be run before the menu is built
  def before_build(&block); end

  def clear!; end

  # @return [Boolean]
  def exists?(menu_name); end

  def fetch(menu_name); end

  # @yield [menu]
  def menu(menu_name); end

  # Add callbacks that will be run when the menu is going to be built. This
  # helps use with reloading and allows configurations to add items to menus.
  #
  # @param block [Proc] A block which will be ran when the menu is built. The
  #   will have the menu collection yielded.
  def on_build(&block); end

  private

  def build_default_menu; end
  def build_menus!; end

  # @return [Boolean]
  def built?; end

  def find_or_create(menu_name); end
  def run_on_build_callbacks; end
end

class ActiveAdmin::MenuItem
  include ::ActiveAdmin::Menu::MenuNode

  # Builds a new menu item
  #
  # NOTE: for :label, :url, and :if
  # These options are evaluated in the view context at render time. Symbols are called
  # as methods on `self`, and Procs are exec'd within `self`.
  # Here are some examples of what you can do:
  #
  #   menu if:  :admin?
  #   menu url: :new_book_path
  #   menu url: :awesome_helper_you_defined
  #   menu label: ->{ User.some_method }
  #   menu label: ->{ I18n.t 'menus.user' }
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option [ActiveAdmin::MenuItem]
  # @param options [Hash] The options for the menu
  # @param [ActiveAdmin::MenuItem] [Hash] a customizable set of options
  # @return [MenuItem] a new instance of MenuItem
  # @yield [_self]
  # @yieldparam _self [ActiveAdmin::MenuItem] the object that the method was called on
  def initialize(options = T.unsafe(nil)); end

  # Returns the value of attribute html_options.
  def html_options; end

  def id; end

  # Returns the value of attribute label.
  def label; end

  # Returns the value of attribute parent.
  def parent; end

  # Returns the value of attribute priority.
  def priority; end

  # Don't display if the :if option passed says so
  def should_display; end

  # Returns the value of attribute url.
  def url; end
end

class ActiveAdmin::Model
  # @return [Model] a new instance of Model
  def initialize(resource, record); end

  def to_model; end
end

# Namespaces are the basic organizing principle for resources within Active Admin
#
# Each resource is registered into a namespace which defines:
#   * the namespaceing for routing
#   * the module to namespace controllers
#   * the menu which gets displayed (other resources in the same namespace)
#
# For example:
#
#   ActiveAdmin.register Post, namespace: :admin
#
# Will register the Post model into the "admin" namespace. This will namespace the
# urls for the resource to "/admin/posts" and will set the controller to
# Admin::PostsController
#
# You can also register to the "root" namespace, which is to say no namespace at all.
#
#   ActiveAdmin.register Post, namespace: false
#
# This will register the resource to an instantiated namespace called :root. The
# resource will be accessible from "/posts" and the controller will be PostsController.
class ActiveAdmin::Namespace
  include ::ActiveAdmin::Comments::NamespaceHelper

  # @return [Namespace] a new instance of Namespace
  def initialize(application, name); end

  # The default user session menu item
  #
  # @param menu [ActiveAdmin::MenuItem] The menu to add the logout link to
  # @param priority [Fixnum] The numeric priority for the order in which it appears
  # @param html_options [Hash] An options hash to pass along to link_to
  def add_current_user_to_menu(menu, priority = T.unsafe(nil), html_options = T.unsafe(nil)); end

  # The default logout menu item
  #
  # @param menu [ActiveAdmin::MenuItem] The menu to add the logout link to
  # @param priority [Fixnum] The numeric priority for the order in which it appears
  # @param html_options [Hash] An options hash to pass along to link_to
  def add_logout_button_to_menu(menu, priority = T.unsafe(nil), html_options = T.unsafe(nil)); end

  # Returns the value of attribute application.
  def application; end

  # Add a callback to be ran when we build the menu
  #
  # @param name [Symbol] The name of the menu. Default: :default
  # @return [void]
  # @yield [ActiveAdmin::Menu] The block to be ran when the menu is built
  def build_menu(name = T.unsafe(nil)); end

  def fetch_menu(name); end

  # Returns the value of attribute menus.
  def menus; end

  def method_missing(method, *args); end

  # Returns the name of the module if required. Will be nil if none
  # is required.
  #
  # eg:
  #   Namespace.new(:admin).module_name # => 'Admin'
  #   Namespace.new(:root).module_name # => nil
  def module_name; end

  def name; end

  # Register a resource into this namespace. The preffered method to access this is to
  # use the global registration ActiveAdmin.register which delegates to the proper
  # namespace instance.
  def register(resource_class, options = T.unsafe(nil), &block); end

  def register_page(name, options = T.unsafe(nil), &block); end
  def reset_menu!; end

  # Returns the first registered ActiveAdmin::Resource instance for a given class
  def resource_for(klass); end

  # Returns the value of attribute resources.
  def resources; end

  # @return [Boolean]
  def root?; end

  def route_prefix; end
  def settings; end

  # Unload all the registered resources for this namespace
  def unload!; end

  protected

  # Builds the default utility navigation in top right header with current user & logout button
  def build_default_utility_nav; end

  def build_menu_collection; end
  def build_page(name, options); end

  # Either returns an existing Resource instance or builds a new one.
  def find_or_build_resource(resource_class, options); end

  def parse_page_registration_block(config, &block); end
  def parse_registration_block(config, &block); end

  # Creates a ruby module to namespace all the classes in if required
  def register_module; end

  # TODO: replace `eval` with `Class.new`
  def register_page_controller(config); end

  # TODO: replace `eval` with `Class.new`
  def register_resource_controller(config); end

  def unload_resources!; end

  private

  # @return [Boolean]
  def respond_to_missing?(method, include_private = T.unsafe(nil)); end

  class << self
    def setting(name, default); end
  end
end

ActiveAdmin::Namespace::RegisterEvent = T.let(T.unsafe(nil), String)

class ActiveAdmin::Namespace::Store
  include ::Enumerable

  # @return [Store] a new instance of Store
  def initialize; end

  def [](*_arg0, **_arg1, &_arg2); end
  def []=(*_arg0, **_arg1, &_arg2); end
  def each(&block); end
  def empty?(*_arg0, **_arg1, &_arg2); end
  def names; end
end

class ActiveAdmin::NamespaceSettings < ::ActiveAdmin::DynamicSettingsNode
  def authentication_method_setting; end
  def authentication_method_setting=(_arg0); end
  def authentication_method_setting?; end
  def authorization_adapter_setting; end
  def authorization_adapter_setting=(_arg0); end
  def authorization_adapter_setting?; end
  def batch_actions_setting; end
  def batch_actions_setting=(_arg0); end
  def batch_actions_setting?; end
  def breadcrumb_setting; end
  def breadcrumb_setting=(_arg0); end
  def breadcrumb_setting?; end
  def comments_menu_setting; end
  def comments_menu_setting=(_arg0); end
  def comments_menu_setting?; end
  def comments_order_setting; end
  def comments_order_setting=(_arg0); end
  def comments_order_setting?; end
  def comments_registration_name_setting; end
  def comments_registration_name_setting=(_arg0); end
  def comments_registration_name_setting?; end
  def comments_setting; end
  def comments_setting=(_arg0); end
  def comments_setting?; end
  def create_another_setting; end
  def create_another_setting=(_arg0); end
  def create_another_setting?; end
  def csv_options_setting; end
  def csv_options_setting=(_arg0); end
  def csv_options_setting?; end
  def current_filters_setting; end
  def current_filters_setting=(_arg0); end
  def current_filters_setting?; end
  def current_user_method_setting; end
  def current_user_method_setting=(_arg0); end
  def current_user_method_setting?; end
  def default_per_page_setting; end
  def default_per_page_setting=(_arg0); end
  def default_per_page_setting?; end
  def download_links_setting; end
  def download_links_setting=(_arg0); end
  def download_links_setting?; end
  def favicon_setting; end
  def favicon_setting=(_arg0); end
  def favicon_setting?; end
  def filter_columns_for_large_association_setting; end
  def filter_columns_for_large_association_setting=(_arg0); end
  def filter_columns_for_large_association_setting?; end
  def filter_method_for_large_association_setting; end
  def filter_method_for_large_association_setting=(_arg0); end
  def filter_method_for_large_association_setting?; end
  def filters_setting; end
  def filters_setting=(_arg0); end
  def filters_setting?; end
  def flash_keys_to_except_setting; end
  def flash_keys_to_except_setting=(_arg0); end
  def flash_keys_to_except_setting?; end
  def footer_setting; end
  def footer_setting=(_arg0); end
  def footer_setting?; end
  def head_setting; end
  def head_setting=(_arg0); end
  def head_setting?; end
  def include_default_association_filters_setting; end
  def include_default_association_filters_setting=(_arg0); end
  def include_default_association_filters_setting?; end
  def logout_link_method_setting; end
  def logout_link_method_setting=(_arg0); end
  def logout_link_method_setting?; end
  def logout_link_path_setting; end
  def logout_link_path_setting=(_arg0); end
  def logout_link_path_setting?; end
  def max_per_page_setting; end
  def max_per_page_setting=(_arg0); end
  def max_per_page_setting?; end
  def maximum_association_filter_arity_setting; end
  def maximum_association_filter_arity_setting=(_arg0); end
  def maximum_association_filter_arity_setting?; end
  def meta_tags_for_logged_out_pages_setting; end
  def meta_tags_for_logged_out_pages_setting=(_arg0); end
  def meta_tags_for_logged_out_pages_setting?; end
  def meta_tags_setting; end
  def meta_tags_setting=(_arg0); end
  def meta_tags_setting?; end
  def on_unauthorized_access_setting; end
  def on_unauthorized_access_setting=(_arg0); end
  def on_unauthorized_access_setting?; end
  def order_clause_setting; end
  def order_clause_setting=(_arg0); end
  def order_clause_setting?; end
  def permitted_params_setting; end
  def permitted_params_setting=(_arg0); end
  def permitted_params_setting?; end
  def root_to_options_setting; end
  def root_to_options_setting=(_arg0); end
  def root_to_options_setting?; end
  def root_to_setting; end
  def root_to_setting=(_arg0); end
  def root_to_setting?; end
  def route_options_setting; end
  def route_options_setting=(_arg0); end
  def route_options_setting?; end
  def scopes_show_count_setting; end
  def scopes_show_count_setting=(_arg0); end
  def scopes_show_count_setting?; end
  def site_title_image_setting; end
  def site_title_image_setting=(_arg0); end
  def site_title_image_setting?; end
  def site_title_link_setting; end
  def site_title_link_setting=(_arg0); end
  def site_title_link_setting?; end
  def site_title_setting; end
  def site_title_setting=(_arg0); end
  def site_title_setting?; end
  def unsupported_browser_matcher_setting; end
  def unsupported_browser_matcher_setting=(_arg0); end
  def unsupported_browser_matcher_setting?; end
  def use_webpacker_setting; end
  def use_webpacker_setting=(_arg0); end
  def use_webpacker_setting?; end
  def view_factory_setting; end
  def view_factory_setting=(_arg0); end
  def view_factory_setting?; end

  class << self
    def authentication_method(*args); end
    def authentication_method=(value); end
    def authentication_method_setting; end
    def authentication_method_setting=(value); end
    def authentication_method_setting?; end
    def authorization_adapter(*args); end
    def authorization_adapter=(value); end
    def authorization_adapter_setting; end
    def authorization_adapter_setting=(value); end
    def authorization_adapter_setting?; end
    def batch_actions(*args); end
    def batch_actions=(value); end
    def batch_actions_setting; end
    def batch_actions_setting=(value); end
    def batch_actions_setting?; end
    def breadcrumb(*args); end
    def breadcrumb=(value); end
    def breadcrumb_setting; end
    def breadcrumb_setting=(value); end
    def breadcrumb_setting?; end
    def comments(*args); end
    def comments=(value); end
    def comments_menu(*args); end
    def comments_menu=(value); end
    def comments_menu_setting; end
    def comments_menu_setting=(value); end
    def comments_menu_setting?; end
    def comments_order(*args); end
    def comments_order=(value); end
    def comments_order_setting; end
    def comments_order_setting=(value); end
    def comments_order_setting?; end
    def comments_registration_name(*args); end
    def comments_registration_name=(value); end
    def comments_registration_name_setting; end
    def comments_registration_name_setting=(value); end
    def comments_registration_name_setting?; end
    def comments_setting; end
    def comments_setting=(value); end
    def comments_setting?; end
    def create_another(*args); end
    def create_another=(value); end
    def create_another_setting; end
    def create_another_setting=(value); end
    def create_another_setting?; end
    def csv_options(*args); end
    def csv_options=(value); end
    def csv_options_setting; end
    def csv_options_setting=(value); end
    def csv_options_setting?; end
    def current_filters(*args); end
    def current_filters=(value); end
    def current_filters_setting; end
    def current_filters_setting=(value); end
    def current_filters_setting?; end
    def current_user_method(*args); end
    def current_user_method=(value); end
    def current_user_method_setting; end
    def current_user_method_setting=(value); end
    def current_user_method_setting?; end
    def default_per_page(*args); end
    def default_per_page=(value); end
    def default_per_page_setting; end
    def default_per_page_setting=(value); end
    def default_per_page_setting?; end
    def download_links(*args); end
    def download_links=(value); end
    def download_links_setting; end
    def download_links_setting=(value); end
    def download_links_setting?; end
    def favicon(*args); end
    def favicon=(value); end
    def favicon_setting; end
    def favicon_setting=(value); end
    def favicon_setting?; end
    def filter_columns_for_large_association(*args); end
    def filter_columns_for_large_association=(value); end
    def filter_columns_for_large_association_setting; end
    def filter_columns_for_large_association_setting=(value); end
    def filter_columns_for_large_association_setting?; end
    def filter_method_for_large_association(*args); end
    def filter_method_for_large_association=(value); end
    def filter_method_for_large_association_setting; end
    def filter_method_for_large_association_setting=(value); end
    def filter_method_for_large_association_setting?; end
    def filters(*args); end
    def filters=(value); end
    def filters_setting; end
    def filters_setting=(value); end
    def filters_setting?; end
    def flash_keys_to_except(*args); end
    def flash_keys_to_except=(value); end
    def flash_keys_to_except_setting; end
    def flash_keys_to_except_setting=(value); end
    def flash_keys_to_except_setting?; end
    def footer(*args); end
    def footer=(value); end
    def footer_setting; end
    def footer_setting=(value); end
    def footer_setting?; end
    def head(*args); end
    def head=(value); end
    def head_setting; end
    def head_setting=(value); end
    def head_setting?; end
    def include_default_association_filters(*args); end
    def include_default_association_filters=(value); end
    def include_default_association_filters_setting; end
    def include_default_association_filters_setting=(value); end
    def include_default_association_filters_setting?; end
    def logout_link_method(*args); end
    def logout_link_method=(value); end
    def logout_link_method_setting; end
    def logout_link_method_setting=(value); end
    def logout_link_method_setting?; end
    def logout_link_path(*args); end
    def logout_link_path=(value); end
    def logout_link_path_setting; end
    def logout_link_path_setting=(value); end
    def logout_link_path_setting?; end
    def max_per_page(*args); end
    def max_per_page=(value); end
    def max_per_page_setting; end
    def max_per_page_setting=(value); end
    def max_per_page_setting?; end
    def maximum_association_filter_arity(*args); end
    def maximum_association_filter_arity=(value); end
    def maximum_association_filter_arity_setting; end
    def maximum_association_filter_arity_setting=(value); end
    def maximum_association_filter_arity_setting?; end
    def meta_tags(*args); end
    def meta_tags=(value); end
    def meta_tags_for_logged_out_pages(*args); end
    def meta_tags_for_logged_out_pages=(value); end
    def meta_tags_for_logged_out_pages_setting; end
    def meta_tags_for_logged_out_pages_setting=(value); end
    def meta_tags_for_logged_out_pages_setting?; end
    def meta_tags_setting; end
    def meta_tags_setting=(value); end
    def meta_tags_setting?; end
    def on_unauthorized_access(*args); end
    def on_unauthorized_access=(value); end
    def on_unauthorized_access_setting; end
    def on_unauthorized_access_setting=(value); end
    def on_unauthorized_access_setting?; end
    def order_clause(*args); end
    def order_clause=(value); end
    def order_clause_setting; end
    def order_clause_setting=(value); end
    def order_clause_setting?; end
    def permitted_params(*args); end
    def permitted_params=(value); end
    def permitted_params_setting; end
    def permitted_params_setting=(value); end
    def permitted_params_setting?; end
    def root_to(*args); end
    def root_to=(value); end
    def root_to_options(*args); end
    def root_to_options=(value); end
    def root_to_options_setting; end
    def root_to_options_setting=(value); end
    def root_to_options_setting?; end
    def root_to_setting; end
    def root_to_setting=(value); end
    def root_to_setting?; end
    def route_options(*args); end
    def route_options=(value); end
    def route_options_setting; end
    def route_options_setting=(value); end
    def route_options_setting?; end
    def scopes_show_count(*args); end
    def scopes_show_count=(value); end
    def scopes_show_count_setting; end
    def scopes_show_count_setting=(value); end
    def scopes_show_count_setting?; end
    def site_title(*args); end
    def site_title=(value); end
    def site_title_image(*args); end
    def site_title_image=(value); end
    def site_title_image_setting; end
    def site_title_image_setting=(value); end
    def site_title_image_setting?; end
    def site_title_link(*args); end
    def site_title_link=(value); end
    def site_title_link_setting; end
    def site_title_link_setting=(value); end
    def site_title_link_setting?; end
    def site_title_setting; end
    def site_title_setting=(value); end
    def site_title_setting?; end
    def unsupported_browser_matcher(*args); end
    def unsupported_browser_matcher=(value); end
    def unsupported_browser_matcher_setting; end
    def unsupported_browser_matcher_setting=(value); end
    def unsupported_browser_matcher_setting?; end
    def use_webpacker(*args); end
    def use_webpacker=(value); end
    def use_webpacker_setting; end
    def use_webpacker_setting=(value); end
    def use_webpacker_setting?; end
    def view_factory(*args); end
    def view_factory=(value); end
    def view_factory_setting; end
    def view_factory_setting=(value); end
    def view_factory_setting?; end
  end
end

class ActiveAdmin::NoMenuError < ::KeyError; end

# Shareable module to give a #display_on?(action) method
# which returns true or false depending on an options hash.
#
# The options hash accepts:
#
# only: :index
# only: [:index, :show]
# except: :index
# except: [:index, :show]
#
# call #normalize_display_options! after @options has been set
# to ensure that the display options are setup correctly
module ActiveAdmin::OptionalDisplay
  # @return [Boolean]
  def display_on?(action, render_context = T.unsafe(nil)); end

  private

  def normalize_display_options!; end
end

class ActiveAdmin::OrderClause
  # @return [OrderClause] a new instance of OrderClause
  def initialize(active_admin_config, clause); end

  # Returns the value of attribute active_admin_config.
  def active_admin_config; end

  def apply(chain); end

  # Returns the value of attribute field.
  def field; end

  # Returns the value of attribute order.
  def order; end

  def sql; end
  def table; end
  def table_column; end
  def to_sql; end

  # @return [Boolean]
  def valid?; end

  protected

  def custom_sql; end
end

# Page is the primary data storage for page configuration in Active Admin
#
# When you register a page (ActiveAdmin.register_page "Status") you are actually creating
# a new Page instance within the given Namespace.
#
# The instance of the current page is available in PageController and views
# by calling the #active_admin_config method.
class ActiveAdmin::Page
  include ::ActiveAdmin::Page::Base
  include ::ActiveAdmin::Resource::Controllers
  include ::ActiveAdmin::Resource::PagePresenters
  include ::ActiveAdmin::Resource::Sidebars
  include ::ActiveAdmin::Resource::ActionItems
  include ::ActiveAdmin::Resource::Menu
  include ::ActiveAdmin::Resource::Naming
  include ::ActiveAdmin::Resource::Routes

  def add_default_action_items; end
  def add_default_sidebar_sections; end
  def belongs_to(target, options = T.unsafe(nil)); end

  # Do we belong to another resource?
  #
  # @return [Boolean]
  def belongs_to?; end

  def belongs_to_config; end

  # Set breadcrumb builder
  def breadcrumb; end

  # Set breadcrumb builder
  def breadcrumb=(_arg0); end

  def camelized_resource_name; end

  # Clears all the custom actions this page knows about
  def clear_page_actions!; end

  def controller_name; end
  def default_menu_options; end

  # The name of the page
  def name; end

  # The namespace this config belongs to
  def namespace; end

  def namespace_name; end
  def order_clause; end

  # An array of custom actions defined for this page
  def page_actions; end

  # label is singular
  def plural_resource_label; end

  def resource_name; end

  # Override from `ActiveAdmin::Resource::Controllers`
  #
  # @return [Boolean]
  def route_uncountable?; end

  def underscored_resource_name; end
end

module ActiveAdmin::Page::Base
  def initialize(namespace, name, options); end
end

# This is the class where all the register_page blocks are evaluated.
class ActiveAdmin::PageDSL < ::ActiveAdmin::DSL
  def belongs_to(target, options = T.unsafe(nil)); end

  # Page content.
  #
  # The block should define the view using Arbre.
  #
  # Example:
  #
  #   ActiveAdmin.register "My Page" do
  #     content do
  #       para "Sweet!"
  #     end
  #   end
  def content(options = T.unsafe(nil), &block); end

  def page_action(name, options = T.unsafe(nil), &block); end
end

# A simple object that gets used to present different aspects of views
#
# Initialize with a set of options and a block. The options become
# available using hash style syntax.
#
# Usage:
#
#     presenter = PagePresenter.new as: :table do
#       # some awesome stuff
#     end
#
#     presenter[:as]    #=> :table
#     presenter.block   #=> The block passed in to new
class ActiveAdmin::PagePresenter
  # @return [PagePresenter] a new instance of PagePresenter
  def initialize(options = T.unsafe(nil), &block); end

  def [](key); end

  # Returns the value of attribute block.
  def block; end

  def fetch(*_arg0, **_arg1, &_arg2); end
  def has_key?(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute options.
  def options; end
end

# Resource is the primary data storage for resource configuration in Active Admin
#
# When you register a resource (ActiveAdmin.register Post) you are actually creating
# a new Resource instance within the given Namespace.
#
# The instance of the current resource is available in ResourceController and views
# by calling the #active_admin_config method.
class ActiveAdmin::Resource
  include ::MethodOrProcHelper
  include ::ActiveAdmin::Resource::Base
  include ::ActiveAdmin::Resource::ActionItems
  include ::ActiveAdmin::Authorization
  include ::ActiveAdmin::Resource::Controllers
  include ::ActiveAdmin::Resource::Menu
  include ::ActiveAdmin::Resource::Naming
  include ::ActiveAdmin::Resource::PagePresenters
  include ::ActiveAdmin::Resource::Pagination
  include ::ActiveAdmin::Resource::Scopes
  include ::ActiveAdmin::Resource::Includes
  include ::ActiveAdmin::Resource::ScopeTo
  include ::ActiveAdmin::Resource::Sidebars
  include ::ActiveAdmin::Resource::Routes
  include ::ActiveAdmin::Resource::Ordering
  include ::ActiveAdmin::Resource::Attributes
  include ::ActiveAdmin::Filters::ResourceExtension
  include ::ActiveAdmin::Comments::ResourceHelper

  def association_columns; end
  def belongs_to(target, options = T.unsafe(nil)); end

  # Do we belong to another resource?
  #
  # @return [Boolean]
  def belongs_to?; end

  def belongs_to_config; end
  def belongs_to_param; end
  def breadcrumb; end

  # Set breadcrumb builder
  def breadcrumb=(_arg0); end

  def clear_collection_actions!; end

  # Clears all the member actions this resource knows about
  def clear_member_actions!; end

  # An array of collection actions defined for this resource
  def collection_actions; end

  def comments; end
  def comments=(_arg0); end
  def content_columns; end
  def create_another; end

  # Display create another checkbox on a new page
  #
  # @return [Boolean]
  def create_another=(_arg0); end

  # The csv builder for this resource
  def csv_builder; end

  # Set the configuration for the CSV
  def csv_builder=(_arg0); end

  def decorator_class; end

  # The string identifying a class to decorate our resource with for the view.
  # nil to not decorate.
  def decorator_class_name; end

  # The string identifying a class to decorate our resource with for the view.
  # nil to not decorate.
  def decorator_class_name=(_arg0); end

  # Return only defined resource actions
  def defined_actions; end

  # Store a reference to the DSL so that we can dereference it during garbage collection.
  def dsl; end

  # Store a reference to the DSL so that we can dereference it during garbage collection.
  def dsl=(_arg0); end

  def find_resource(id); end

  # An array of member actions defined for this resource
  def member_actions; end

  # The namespace this config belongs to
  def namespace; end

  def order_clause; end

  # Set order clause
  def order_clause=(_arg0); end

  def resource_attributes; end

  # The class this resource wraps. If you register the Post model, Resource#resource_class
  # will point to the Post class
  def resource_class; end

  # The name of the resource class
  def resource_class_name; end

  def resource_column_names; end
  def resource_columns; end
  def resource_name_extension; end
  def resource_quoted_column_name(column); end
  def resource_table_name; end
  def sort_order; end

  # The default sort order to use in the controller
  def sort_order=(_arg0); end

  private

  def default_csv_builder; end
  def define_resource_name_extension(resource); end
  def method_for_find(id); end
end

module ActiveAdmin::Resource::ActionItems
  # Adds the default action items to a resource when it's initialized
  def initialize(*args); end

  # @return [Array] The set of action items for this resource
  def action_items; end

  # Used by active_admin Base view
  #
  # @return [Boolean]
  def action_items?; end

  # Returns a set of action items to display for a specific controller action
  #
  # @param action [String, Symbol] the action to retrieve action items for
  # @return [Array] Array of ActionItems for the controller actions
  def action_items_for(action, render_context = T.unsafe(nil)); end

  # Add a new action item to a resource
  #
  # @param name [Symbol]
  # @param options [Hash] valid keys include:
  #   :only:  A single or array of controller actions to display
  #   this action item on.
  #   :except: A single or array of controller actions not to
  #   display this action item on.
  #   :priority: A single integer value. To control the display order. Default is 10.
  def add_action_item(name, options = T.unsafe(nil), &block); end

  # Clears all the existing action items for this resource
  def clear_action_items!; end

  def remove_action_item(name); end

  private

  # Adds the default action items to each resource
  def add_default_action_items; end

  # Adds the default Edit link on show
  def add_default_edit_action_item; end

  # Adds the default New link on index
  def add_default_new_action_item; end

  # Adds the default Destroy link on show
  def add_default_show_action_item; end
end

module ActiveAdmin::Resource::Attributes
  # @return [Boolean]
  def counter_cache_col?(c); end

  def default_attributes; end

  # @return [Boolean]
  def filtered_col?(c); end

  def foreign_methods; end
  def method_for_column(c); end

  # @return [Boolean]
  def primary_col?(c); end

  # @return [Boolean]
  def reject_col?(c); end

  # @return [Boolean]
  def sti_col?(c); end
end

module ActiveAdmin::Resource::Base
  def initialize(namespace, resource_class, options = T.unsafe(nil)); end
end

class ActiveAdmin::Resource::BelongsTo
  # @return [BelongsTo] a new instance of BelongsTo
  def initialize(owner, target_name, options = T.unsafe(nil)); end

  def namespace; end

  # @return [Boolean]
  def optional?; end

  # The resource which initiated this relationship
  def owner; end

  # @return [Boolean]
  def required?; end

  def resource; end

  # Returns the target resource class or raises an exception if it doesn't exist
  def target; end

  # The name of the relation
  def target_name; end

  def to_param; end
end

class ActiveAdmin::Resource::BelongsTo::TargetNotFound < ::StandardError
  # @return [TargetNotFound] a new instance of TargetNotFound
  def initialize(key, namespace); end
end

module ActiveAdmin::Resource::Controllers
  # Returns the controller for this config
  def controller; end

  # Returns a properly formatted controller name for this
  # config within its namespace
  def controller_name; end

  def resources_configuration(*_arg0, **_arg1, &_arg2); end
end

module ActiveAdmin::Resource::Includes
  # Return an array of includes for this resource
  def includes; end
end

module ActiveAdmin::Resource::Menu
  def add_to_menu(menu_collection); end
  def default_menu_options; end

  # Should this resource be added to the menu system?
  #
  # @return [Boolean]
  def include_in_menu?; end

  # Returns the value of attribute menu_item.
  def menu_item; end

  def menu_item_options; end

  # Set the menu options.
  # To disable this menu item, call `menu(false)` from the DSL
  def menu_item_options=(options); end

  def navigation_menu; end
  def navigation_menu_name; end
  def navigation_menu_name=(menu_name); end
end

class ActiveAdmin::Resource::Name < ::ActiveModel::Name
  # @return [Name] a new instance of Name
  def initialize(klass, name = T.unsafe(nil)); end

  # @return [Boolean]
  def eql?(other); end

  def hash(*_arg0, **_arg1, &_arg2); end
  def route_key; end
  def translate(options = T.unsafe(nil)); end
end

module ActiveAdmin::Resource::Naming
  # Forms use the model's original `param_key`, so we can't use our
  # custom `resource_name` when the model's been renamed in ActiveAdmin.
  def param_key; end

  # Returns the plural version of this resource such as "Bank Accounts"
  def plural_resource_label(options = T.unsafe(nil)); end

  # Returns the name to call this resource such as "Bank Account"
  def resource_label; end

  def resource_name; end
end

module ActiveAdmin::Resource::Ordering
  def ordering; end
end

module ActiveAdmin::Resource::PagePresenters
  # for setting default css class in admin ui
  def default_index_class; end

  # Returns a stored page config
  #
  # @param action [Symbol, String] The action to get the config for
  # @param type [String] The string specified in the presenters index_name method
  # @return [PagePresenter, nil]
  def get_page_presenter(action, type = T.unsafe(nil)); end

  # A hash of page configurations for the controller indexed by action name
  def page_presenters; end

  # Sets a page config for a given action
  #
  # @param action [String, Symbol] The action to store this configuration for
  # @param page_presenter [PagePresenter] The instance of PagePresenter to store
  def set_page_presenter(action, page_presenter); end

  protected

  # Returns the actual class for renderering the main content on the index
  # page. To set this, use the :as option in the page_presenter block.
  #
  # @param symbol_or_class [Symbol, Class] The component symbol or class
  # @return [Class]
  def find_index_class(symbol_or_class); end

  # Stores a config for all index actions supplied
  #
  # @param index_as [Symbol] The index type to store in the configuration
  # @param page_presenter [PagePresenter] The intance of PagePresenter to store
  def set_index_presenter(index_as, page_presenter); end
end

module ActiveAdmin::Resource::Pagination
  def initialize(*args); end

  # The default number of records to display per page
  def max_per_page; end

  # The default number of records to display per page
  def max_per_page=(_arg0); end

  # Enable / disable pagination (defaults to true)
  def paginate; end

  # Enable / disable pagination (defaults to true)
  def paginate=(_arg0); end

  # The default number of records to display per page
  def per_page; end

  # The default number of records to display per page
  def per_page=(_arg0); end
end

# Event dispatched when a new resource is registered
ActiveAdmin::Resource::RegisterEvent = T.let(T.unsafe(nil), String)

module ActiveAdmin::Resource::Routes
  def route_batch_action_path(params = T.unsafe(nil), additional_params = T.unsafe(nil)); end
  def route_builder; end

  # @example "/admin/posts"
  # @param params [Hash] of params: { study_id: 3 }
  # @return [String] the path to this resource collection page
  def route_collection_path(params = T.unsafe(nil), additional_params = T.unsafe(nil)); end

  def route_edit_instance_path(resource, additional_params = T.unsafe(nil)); end

  # @example "/admin/posts/1"
  # @param resource [ActiveRecord::Base] the instance we want the path of
  # @return [String] the path to this resource collection page
  def route_instance_path(resource, additional_params = T.unsafe(nil)); end

  def route_member_action_path(action, resource, additional_params = T.unsafe(nil)); end

  # Returns the routes prefix for this config
  def route_prefix; end

  # @return [Boolean]
  def route_uncountable?; end
end

class ActiveAdmin::Resource::Routes::RouteBuilder
  # @return [RouteBuilder] a new instance of RouteBuilder
  def initialize(resource); end

  def batch_action_path(params, additional_params = T.unsafe(nil)); end
  def collection_path(params, additional_params = T.unsafe(nil)); end

  # @example "/admin/posts/1"
  # @param instance [ActiveRecord::Base] the instance we want the path of
  # @return [String] the path to this resource collection page
  def instance_path(instance, additional_params = T.unsafe(nil)); end

  # @example "/admin/posts/1/edit"
  # @param action [Symbol]
  # @param instance [ActiveRecord::Base] the instance we want the path of
  # @return [String] the path to the member action of this resource
  def member_action_path(action, instance, additional_params = T.unsafe(nil)); end

  private

  def belongs_to_config; end
  def belongs_to_name; end
  def belongs_to_target_name; end

  # @return [Boolean]
  def nested?; end

  # Returns the value of attribute resource.
  def resource; end

  def route_collection_params(params); end

  # @return params to pass to instance path
  def route_instance_params(instance); end

  def route_name(resource_path_name, options = T.unsafe(nil)); end
  def routes; end
end

module ActiveAdmin::Resource::ScopeTo
  # Scope this controller to some object which has a relation
  # to the resource. Can either accept a block or a symbol
  # of a method to call.
  #
  # Eg:
  #
  #   ActiveAdmin.register Post do
  #     scope_to :current_user
  #   end
  #
  # Then every time we instantiate and object, it would call
  #
  #   current_user.posts.build
  #
  # By default Active Admin will use the resource name to build a
  # method to call as the association. If its different, you can
  # pass in the association_method as an option.
  #
  #   scope_to :current_user, association_method: :blog_posts
  #
  # will result in the following
  #
  #   current_user.blog_posts.build
  #
  # To conditionally use this scope, you can use conditional procs
  #
  #   scope_to :current_user, if: proc{ admin_user_signed_in? }
  #
  # or
  #
  #   scope_to :current_user, unless: proc{ current_user.admin? }
  def scope_to(*args, &block); end

  # @return [Boolean]
  def scope_to?(context = T.unsafe(nil)); end

  def scope_to_association_method; end
  def scope_to_config; end
  def scope_to_method; end
end

module ActiveAdmin::Resource::Scopes
  def default_scope(context = T.unsafe(nil)); end

  # Returns a scope for this object by its identifier
  def get_scope_by_id(id); end

  # Create a new scope object for this resource.
  # If you want to internationalize the scope name, you can add
  # to your i18n files a key like "active_admin.scopes.scope_method".
  def scope(*args, &block); end

  # Return an array of scopes for this resource
  def scopes; end
end

module ActiveAdmin::Resource::Sidebars
  def clear_sidebar_sections!; end
  def sidebar_sections; end

  # @return [Boolean]
  def sidebar_sections?; end

  def sidebar_sections_for(action, render_context = T.unsafe(nil)); end
end

# This is a container for resources, which acts much like a Hash.
# It's assumed that an added resource responds to `resource_name`.
class ActiveAdmin::ResourceCollection
  include ::Enumerable
  extend ::Forwardable

  # @return [ResourceCollection] a new instance of ResourceCollection
  def initialize; end

  def [](obj); end
  def add(resource); end

  # Changes `each` to pass in the value, instead of both the key and value.
  def each(&block); end

  def empty?(*args, **_arg1, &block); end
  def has_key?(*args, **_arg1, &block); end
  def keys(*args, **_arg1, &block); end
  def size(*args, **_arg1, &block); end
  def values(*args, **_arg1, &block); end

  private

  # Finds a resource based on the resource name, resource class, or base class.
  def find_resource(obj); end

  def raise_if_mismatched!(existing, given); end
  def resources; end
end

class ActiveAdmin::ResourceCollection::ConfigMismatch < ::StandardError
  # @return [ConfigMismatch] a new instance of ConfigMismatch
  def initialize(existing, given); end
end

class ActiveAdmin::ResourceCollection::IncorrectClass < ::StandardError
  # @return [IncorrectClass] a new instance of IncorrectClass
  def initialize(existing, given); end
end

# This is the class where all the register blocks are evaluated.
class ActiveAdmin::ResourceDSL < ::ActiveAdmin::DSL
  include ::ActiveAdmin::Filters::DSL

  def actions(*_arg0, **_arg1, &_arg2); end
  def after_action(*_arg0, **_arg1, &_arg2); end
  def after_build(*_arg0, **_arg1, &_arg2); end
  def after_create(*_arg0, **_arg1, &_arg2); end
  def after_destroy(*_arg0, **_arg1, &_arg2); end
  def after_save(*_arg0, **_arg1, &_arg2); end
  def after_update(*_arg0, **_arg1, &_arg2); end
  def append_after_action(*_arg0, **_arg1, &_arg2); end
  def append_around_action(*_arg0, **_arg1, &_arg2); end
  def append_before_action(*_arg0, **_arg1, &_arg2); end
  def around_action(*_arg0, **_arg1, &_arg2); end
  def before_action(*_arg0, **_arg1, &_arg2); end
  def before_build(*_arg0, **_arg1, &_arg2); end
  def before_create(*_arg0, **_arg1, &_arg2); end
  def before_destroy(*_arg0, **_arg1, &_arg2); end
  def before_save(*_arg0, **_arg1, &_arg2); end
  def before_update(*_arg0, **_arg1, &_arg2); end
  def prepend_after_action(*_arg0, **_arg1, &_arg2); end
  def prepend_around_action(*_arg0, **_arg1, &_arg2); end
  def prepend_before_action(*_arg0, **_arg1, &_arg2); end
  def skip_after_action(*_arg0, **_arg1, &_arg2); end
  def skip_around_action(*_arg0, **_arg1, &_arg2); end
  def skip_before_action(*_arg0, **_arg1, &_arg2); end

  private

  # Member Actions give you the functionality of defining both the
  # action and the route directly from your ActiveAdmin registration
  # block.
  #
  # For example:
  #
  #   ActiveAdmin.register Post do
  #     member_action :comments do
  #       @post = Post.find(params[:id])
  #       @comments = @post.comments
  #     end
  #   end
  #
  # Will create a new controller action comments and will hook it up to
  # the named route (comments_admin_post_path) /admin/posts/:id/comments
  #
  # You can treat everything within the block as a standard Rails controller
  # action.
  def action(set, name, options = T.unsafe(nil), &block); end

  def belongs_to(target, options = T.unsafe(nil)); end
  def collection_action(name, options = T.unsafe(nil), &block); end

  # Configure the CSV format
  #
  # For example:
  #
  #   csv do
  #     column :name
  #     column("Author") { |post| post.author.full_name }
  #   end
  #
  #   csv col_sep: ";", force_quotes: true do
  #     column :name
  #   end
  def csv(options = T.unsafe(nil), &block); end

  def decorate_with(decorator_class); end
  def form(options = T.unsafe(nil), &block); end

  # Store relations that should be included
  def includes(*args); end

  # Configure the index page for the resource
  def index(options = T.unsafe(nil), &block); end

  def member_action(name, options = T.unsafe(nil), &block); end

  # Redefine sort behaviour for column
  #
  # For example:
  #
  #   # nulls last
  #   order_by(:age) do |order_clause|
  #     [order_clause.to_sql, 'NULLS LAST'].join(' ')  if order_clause.order == 'desc'
  #   end
  #
  #   # by last_name but in the case that there is no last name, by first_name.
  #   order_by(:full_name) do |order_clause|
  #     ['COALESCE(NULLIF(last_name, ''), first_name), first_name', order_clause.order].join(' ')
  #   end
  def order_by(column, &block); end

  # Keys included in the `permitted_params` setting are automatically whitelisted.
  #
  # Either
  #
  #   permit_params :title, :author, :body, tags: []
  #
  # Or
  #
  #   permit_params do
  #     defaults = [:title, :body]
  #     if current_user.admin?
  #       defaults + [:author]
  #     else
  #       defaults
  #     end
  #   end
  def permit_params(*args, &block); end

  # Create a scope
  def scope(*args, &block); end

  # Scope collection to a relation
  def scope_to(*args, &block); end

  # Configure the show page for the resource
  def show(options = T.unsafe(nil), &block); end
end

# @private
class ActiveAdmin::Router
  # @return [Router] a new instance of Router
  def initialize(router:, namespaces:); end

  def apply; end

  # Returns the value of attribute namespaces.
  def namespaces; end

  # Returns the value of attribute router.
  def router; end

  private

  # Deals with +ControllerAction+ instances
  # Builds one route for each HTTP verb passed in
  def build_action(action); end

  def build_route(verbs, *args); end

  # Defines member and collection actions
  def define_actions(config); end

  def define_belongs_to_routes(config); end
  def define_namespace(config); end
  def define_resource_routes(config); end

  # Defines the routes for each resource
  def define_resources_routes; end

  def define_root_routes; end
  def define_routes(config); end
  def page_or_resource_routes(config); end
  def page_routes(config); end
  def resource_routes(config); end
end

class ActiveAdmin::Scope
  # Create a Scope
  #
  # Examples:
  #
  #   Scope.new(:published)
  #   # => Scope with name 'Published' and scope method :published
  #
  #   Scope.new('Published', :public)
  #   # => Scope with name 'Published' and scope method :public
  #
  #   Scope.new 'Published', :public, if: proc { current_admin_user.can? :manage, resource_class } do |articles|
  #     articles.where published: true
  #   end
  #   # => Scope with name 'Published' and scope method :public, optionally displaying the scope per the :if block
  #
  #   Scope.new('Published') { |articles| articles.where(published: true) }
  #   # => Scope with name 'Published' using a block to scope
  #
  #   Scope.new ->{Date.today.strftime '%A'}, :published_today
  #   # => Scope with dynamic title using the :published_today scope method
  #
  #   Scope.new :published, nil, group: :status
  #   # => Scope with the group :status
  #
  # @return [Scope] a new instance of Scope
  def initialize(name, method = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # Returns the value of attribute default_block.
  def default_block; end

  # Returns the value of attribute display_if_block.
  def display_if_block; end

  # Returns the value of attribute group.
  def group; end

  # Returns the value of attribute id.
  def id; end

  def name; end

  # Returns the value of attribute scope_block.
  def scope_block; end

  # Returns the value of attribute scope_method.
  def scope_method; end

  # Returns the value of attribute show_count.
  def show_count; end
end

module ActiveAdmin::ScopeChain
  private

  # Scope an ActiveRecord::Relation chain
  #
  # Example:
  #   scope_chain(Scope.new(:published), Article)
  #   # => Article.published
  #
  # @param scope The <ActiveAdmin::Scope> we want to scope on
  # @param chain The ActiveRecord::Relation chain or ActiveRecord::Base class to scope
  # @return [ActiveRecord::Relation or ActiveRecord::Base] The scoped relation chain
  def scope_chain(scope, chain); end
end

class ActiveAdmin::SettingsNode
  class << self
    # @return anonymous class with same accessors as the superclass.
    def build(superclass = T.unsafe(nil)); end

    def register(name, value); end
  end
end

class ActiveAdmin::SidebarSection
  include ::ActiveAdmin::OptionalDisplay

  # @return [SidebarSection] a new instance of SidebarSection
  def initialize(name, options = T.unsafe(nil), &block); end

  # Returns the value of attribute block.
  def block; end

  # Sets the attribute block
  #
  # @param value the value to set the attribute block to.
  def block=(_arg0); end

  def custom_class; end

  # The id gets used for the div in the view
  def id; end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end

  # Returns the value of attribute options.
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  def options=(_arg0); end

  # If a block is not passed in, the name of the partial to render
  def partial_name; end

  def priority; end

  # The title gets displayed within the section in the view
  def title; end
end

# Many configuration options (Ex: site_title, title_image) could either be
# static (String), methods (Symbol) or procs (Proc). This wrapper takes care of
# returning the content when String or using instance_eval when Symbol or Proc.
class ActiveAdmin::StringSymbolOrProcSetting < ::ActiveAdmin::DynamicSetting
  def value(context = T.unsafe(nil)); end
end

ActiveAdmin::VERSION = T.let(T.unsafe(nil), String)

class ActiveAdmin::ViewFactory < ::ActiveAdmin::AbstractViewFactory
  def action_items; end
  def action_items=(_arg0); end
  def action_items?; end
  def blank_slate; end
  def blank_slate=(_arg0); end
  def blank_slate?; end
  def edit_page; end
  def edit_page=(_arg0); end
  def edit_page?; end
  def footer; end
  def footer=(_arg0); end
  def footer?; end
  def global_navigation; end
  def global_navigation=(_arg0); end
  def global_navigation?; end
  def header; end
  def header=(_arg0); end
  def header?; end
  def index_page; end
  def index_page=(_arg0); end
  def index_page?; end
  def index_scopes; end
  def index_scopes=(_arg0); end
  def index_scopes?; end
  def layout; end
  def layout=(_arg0); end
  def layout?; end
  def new_page; end
  def new_page=(_arg0); end
  def new_page?; end
  def page; end
  def page=(_arg0); end
  def page?; end
  def show_page; end
  def show_page=(_arg0); end
  def show_page?; end
  def site_title; end
  def site_title=(_arg0); end
  def site_title?; end
  def title_bar; end
  def title_bar=(_arg0); end
  def title_bar?; end
  def unsupported_browser; end
  def unsupported_browser=(_arg0); end
  def unsupported_browser?; end
  def utility_navigation; end
  def utility_navigation=(_arg0); end
  def utility_navigation?; end

  class << self
    def action_items; end
    def action_items=(value); end
    def action_items?; end
    def blank_slate; end
    def blank_slate=(value); end
    def blank_slate?; end
    def edit_page; end
    def edit_page=(value); end
    def edit_page?; end
    def footer; end
    def footer=(value); end
    def footer?; end
    def global_navigation; end
    def global_navigation=(value); end
    def global_navigation?; end
    def header; end
    def header=(value); end
    def header?; end
    def index_page; end
    def index_page=(value); end
    def index_page?; end
    def index_scopes; end
    def index_scopes=(value); end
    def index_scopes?; end
    def layout; end
    def layout=(value); end
    def layout?; end
    def new_page; end
    def new_page=(value); end
    def new_page?; end
    def page; end
    def page=(value); end
    def page?; end
    def show_page; end
    def show_page=(value); end
    def show_page?; end
    def site_title; end
    def site_title=(value); end
    def site_title?; end
    def title_bar; end
    def title_bar=(value); end
    def title_bar?; end
    def unsupported_browser; end
    def unsupported_browser=(value); end
    def unsupported_browser?; end
    def utility_navigation; end
    def utility_navigation=(value); end
    def utility_navigation?; end
  end
end

module ActiveAdmin::ViewHelpers
  include ::ActiveAdmin::ViewHelpers::ActiveAdminApplicationHelper
  include ::ActiveAdmin::ViewHelpers::AutoLinkHelper
  include ::ActiveAdmin::ViewHelpers::BreadcrumbHelper
  include ::ActiveAdmin::ViewHelpers::DisplayHelper
  include ::MethodOrProcHelper
  include ::ActiveAdmin::ViewHelpers::SidebarHelper
  include ::ActiveAdmin::ViewHelpers::FormHelper
  include ::ActiveAdmin::ViewHelpers::TitleHelper
  include ::ActiveAdmin::ViewHelpers::ViewFactoryHelper
  include ::ActiveAdmin::ViewHelpers::FlashHelper
  include ::ActiveAdmin::ViewHelpers::ScopeNameHelper
  include ::ActiveAdmin::Filters::ViewHelper
end

module ActiveAdmin::ViewHelpers::ActiveAdminApplicationHelper
  # Returns the current Active Admin application instance
  def active_admin_application; end
end

module ActiveAdmin::ViewHelpers::AutoLinkHelper
  # Returns the ActiveAdmin::Resource instance for a class
  def active_admin_resource_for(klass); end

  # Automatically links objects to their resource controllers. If
  # the resource has not been registered, a string representation of
  # the object is returned.
  #
  # The default content in the link is returned from ActiveAdmin::ViewHelpers::DisplayHelper#display_name
  #
  # You can pass in the content to display
  #   eg: auto_link(@post, "My Link")
  def auto_link(resource, content = T.unsafe(nil)); end

  # Like `auto_link`, except that it only returns a URL instead of a full <a> tag
  def auto_url_for(resource); end
end

module ActiveAdmin::ViewHelpers::BreadcrumbHelper
  # Returns an array of links to use in a breadcrumb
  def breadcrumb_links(path = T.unsafe(nil)); end
end

module ActiveAdmin::ViewHelpers::DisplayHelper
  def association_methods_for(resource); end

  # @return [Boolean]
  def boolean_attr?(resource, attr, value); end

  # Attempts to call any known display name methods on the resource.
  # See the setting in `application.rb` for the list of methods and their priority.
  def display_name(resource); end

  # Looks up and caches the first available display name method.
  # To prevent conflicts, we exclude any methods that happen to be associations.
  # If no methods are available and we're about to use the Kernel's `to_s`, provide our own.
  def display_name_method_for(resource); end

  def find_value(resource, attr); end
  def format_attribute(resource, attr); end
  def format_collection(collection); end

  # Attempts to create a human-readable string for any object
  def pretty_format(object); end
end

ActiveAdmin::ViewHelpers::DisplayHelper::DISPLAY_NAME_FALLBACK = T.let(T.unsafe(nil), Proc)

module ActiveAdmin::ViewHelpers::DownloadFormatLinksHelper
  mixes_in_class_methods ::ActiveAdmin::ViewHelpers::DownloadFormatLinksHelper::ClassMethods

  private

  def build_download_format_links(formats = T.unsafe(nil)); end
  def build_download_formats(download_links); end

  class << self
    # @private
    def included(base); end
  end
end

module ActiveAdmin::ViewHelpers::DownloadFormatLinksHelper::ClassMethods
  # Adds a mime type to the list of available formats available for data
  # export. You must register the extension prior to adding it here.
  #
  # @param format [Symbol] the mime type to add
  # @return [Array] A copy of the updated formats array.
  def add_format(format); end

  # A ready only of formats to make available in index/paginated
  # collection view.
  # formats
  #
  # @return [Array]
  # @see add_format for information on adding custom download link
  def formats; end
end

module ActiveAdmin::ViewHelpers::FlashHelper
  # Returns all the flash keys to display in any Active Admin view.
  # This method removes the :timedout key that Devise uses by default.
  # Note Rails >= 4.1 normalizes keys to strings automatically.
  def flash_messages; end
end

module ActiveAdmin::ViewHelpers::FormHelper
  def active_admin_form_for(resource, options = T.unsafe(nil), &block); end

  # Flatten a params Hash to an array of fields.
  #
  # @example
  #   fields_for_params(scope: "all", users: ["greg"])
  #   => [ {"scope" => "all"} , {"users[]" => "greg"} ]
  # @param params [Hash]
  # @param options [Hash] :namespace and :except
  # @return [Array] of [Hash] with one element.
  def fields_for_params(params, options = T.unsafe(nil)); end

  def hidden_field_tags_for(params, options = T.unsafe(nil)); end
end

module ActiveAdmin::ViewHelpers::ScopeNameHelper
  def scope_name(scope); end
end

module ActiveAdmin::ViewHelpers::SidebarHelper
  def skip_sidebar!; end

  # @return [Boolean]
  def skip_sidebar?; end
end

module ActiveAdmin::ViewHelpers::TitleHelper
  def title(_title); end
end

module ActiveAdmin::ViewHelpers::ViewFactoryHelper
  def view_factory; end
end

module ActiveAdmin::Views; end

class ActiveAdmin::Views::ActionItems < ::ActiveAdmin::Component
  def build(action_items); end
end

class ActiveAdmin::Views::ActiveAdminForm < ::ActiveAdmin::Views::FormtasticProxy
  def actions(*args, &block); end
  def add_create_another_checkbox; end
  def build(resource, options = T.unsafe(nil), &block); end
  def commit_action_with_cancel_link; end
  def form_buffers; end
  def has_many(*args, &block); end
  def input(*args); end
  def inputs(*args, &block); end

  # @return [Boolean]
  def multipart?; end

  def object; end

  private

  def create_another_checkbox; end
end

class ActiveAdmin::Views::ActiveFiltersSidebarContent < ::ActiveAdmin::Component
  def build; end
  def filter_item(filter); end
  def filters_list(active_filters, active_scopes); end
  def scope_block(current_scope); end
  def scope_item(name, value); end
end

class ActiveAdmin::Views::AttributesTable < ::ActiveAdmin::Component
  def build(obj, *attrs); end
  def row(*args, &block); end
  def rows(*attrs); end

  protected

  # Build Colgroups
  #
  # Colgroups are only necessary for a collection of records; not
  # a single record.
  def build_colgroups; end

  def content_for(record, attr); end
  def default_id_for_prefix; end
  def empty_value; end
  def header_content_for(attr); end

  # @return [Boolean]
  def single_record?; end
end

# Build a Blank Slate
class ActiveAdmin::Views::BlankSlate < ::ActiveAdmin::Component
  def build(content); end
  def default_class_name; end
end

class ActiveAdmin::Views::Column < ::ActiveAdmin::Component
  # @option options
  # @param options [Hash] An options hash for the column
  def build(options = T.unsafe(nil)); end

  # Returns the value of attribute max_width.
  def max_width; end

  # Sets the attribute max_width
  #
  # @param value the value to set the attribute max_width to.
  def max_width=(_arg0); end

  # Returns the value of attribute min_width.
  def min_width; end

  # Sets the attribute min_width
  #
  # @param value the value to set the attribute min_width to.
  def min_width=(_arg0); end

  def set_column_styles(column_width, margin_width, is_last_column = T.unsafe(nil)); end

  # Returns the value of attribute span_size.
  def span_size; end

  # Sets the attribute span_size
  #
  # @param value the value to set the attribute span_size to.
  def span_size=(_arg0); end

  private

  # Converts values without a '%' or 'px' suffix to a pixel value
  def safe_width(width); end
end

# = Columns Component
#
# The Columns component allows you draw content into scalable columns. All
# you need to do is define the number of columns and the component will
# take care of the rest.
#
# == Simple Columns
#
# To display columns, use the #columns method. Within the block, call the
# #column method to create a new column.
#
# To create a two column layout:
#
#     columns do
#       column do
#         span "Column # 1
#       end
#       column do
#         span "Column # 2
#       end
#     end
#
#
# == Multiple Span Columns
#
# To make a column span multiple, pass the :span option to the column method:
#
#     columns do
#       column span: 2 do
#         span "Column # 1
#       end
#       column do
#         span "Column # 2
#       end
#     end
#
# By default, each column spans 1 column. So the above layout would have 2 columns,
# the first being 2 time bigger than the second.
#
#
# == Max and Min Column Sizes
#
# Active Admin is a fluid width layout, which means that columns are all defined
# using percentages. Sometimes this can cause issues if you don't want a column
# to shrink or expand past a certain point.
#
# To overcome this, columns include a :max_width and :min_width option.
#
#     columns do
#       column max_width: "200px", min_width: "100px" do
#         span "Column # 1
#       end
#       column do
#         span "Column # 2
#       end
#     end
#
# Now the first column will not grow bigger than 200px and will not shrink smaller
# than 100px.
class ActiveAdmin::Views::Columns < ::ActiveAdmin::Component
  # Override add child to set widths
  def add_child(*_arg0); end

  # For documentation, please take a look at Column#build
  def column(*args, &block); end

  protected

  # Calculate our columns sizes and margins
  def calculate_columns!; end

  # Override the closing tag to include a clear
  def closing_tag; end

  def columns; end
  def columns_span_count; end
  def margin_size; end
end

# Action List - A button with a drop down menu of links
#
# Creating a new action list:
#
#     dropdown_menu "Administration" do
#       item "Edit Details", edit_details_path
#       item "Edit My Account", edit_my_account_path
#     end
#
# This will create a button with the label "Administration" and
# a drop down once clicked with 2 options.
class ActiveAdmin::Views::DropdownMenu < ::ActiveAdmin::Component
  # Build a new action list
  #
  # @param name [String] The name to display in the button
  # @param options [Hash] A set of options that get passed along to
  #   to the parent dom element.
  def build(name, options = T.unsafe(nil)); end

  def item(*args, **kwargs); end

  private

  def build_button(name, button_options); end
  def build_menu(options); end
end

class ActiveAdmin::Views::Footer < ::ActiveAdmin::Component
  def build(namespace); end

  private

  def footer_text; end
  def powered_by_message; end
end

class ActiveAdmin::Views::FormtasticProxy < ::Arbre::Rails::Forms::FormBuilderProxy
  def closing_tag; end
  def opening_tag; end
  def split_string_on(string, match); end
  def to_s; end
end

class ActiveAdmin::Views::HasManyProxy < ::ActiveAdmin::Views::FormtasticProxy
  def build(form_builder, *args, &block); end
end

class ActiveAdmin::Views::Header < ::ActiveAdmin::Component
  def build(namespace, menu); end
end

# # Index as a Block
#
# If you want to fully customize the display of your resources on the index
# screen, Index as a Block allows you to render a block of content for each
# resource.
#
# ```ruby
# index as: :block do |product|
#   div for: product do
#     resource_selection_cell product
#     h2  auto_link     product.title
#     div simple_format product.description
#   end
# end
# ```
class ActiveAdmin::Views::IndexAsBlock < ::ActiveAdmin::Component
  def build(page_presenter, collection); end

  class << self
    def index_name; end
  end
end

# # Index as Blog
#
# Render your index page as a set of posts. The post has two main options:
# title and body.
#
# ```ruby
# index as: :blog do
#   title :my_title # Calls #my_title on each resource
#   body  :my_body  # Calls #my_body on each resource
# end
# ```
#
# ## Post Title
#
# The title is the content that will be rendered within a link to the
# resource. There are two main ways to set the content for the title
#
# First, you can pass in a method to be called on your resource. For example:
#
# ```ruby
# index as: :blog do
#   title :a_method_to_call
# end
# ```
#
# Second, you can pass a block to the tile option which will then be
# used as the contents of the title. The resource being rendered
# is passed in to the block. For Example:
#
# ```ruby
# index as: :blog do
#   title do |post|
#     span post.title,      class: 'title'
#     span post.created_at, class: 'created_at'
#   end
# end
# ```
#
# ## Post Body
#
# The body is rendered underneath the title of each post. The same two
# style of options work as the Post Title above.
#
# Call a method on the resource as the body:
#
# ```ruby
# index as: :blog do
#   title :my_title
#   body :my_body
# end
# ```
#
# Or, render a block as the body:
#
# ```ruby
# index as: :blog do
#   title :my_title
#   body do |post|
#     div truncate post.title
#     div class: 'meta' do
#       span "Post in #{post.categories.join(', ')}"
#     end
#   end
# end
# ```
class ActiveAdmin::Views::IndexAsBlog < ::ActiveAdmin::Component
  # Setter method for the configuration of the body
  def body(method = T.unsafe(nil), &block); end

  def build(page_presenter, collection); end

  # Setter method for the configuration of the title
  def title(method = T.unsafe(nil), &block); end

  private

  def build_body(post); end
  def build_post(post); end
  def build_posts; end
  def build_title(post); end
  def render_method_on_post_or_call_proc(post, proc); end

  class << self
    def index_name; end
  end
end

# # Index as a Grid
#
# Sometimes you want to display the index screen for a set of resources as a grid
# (possibly a grid of thumbnail images). To do so, use the :grid option for the
# index block.
#
# ```ruby
# index as: :grid do |product|
#   link_to image_tag(product.image_path), admin_product_path(product)
# end
# ```
#
# The block is rendered within a cell in the grid once for each resource in the
# collection. The resource is passed into the block for you to use in the view.
#
# You can customize the number of columns that are rendered using the columns
# option:
#
# ```ruby
# index as: :grid, columns: 5 do |product|
#   link_to image_tag(product.image_path), admin_product_path(product)
# end
# ```
class ActiveAdmin::Views::IndexAsGrid < ::ActiveAdmin::Component
  def build(page_presenter, collection); end
  def number_of_columns; end

  protected

  def build_empty_cell; end
  def build_item(item); end
  def build_row(group); end
  def build_table; end
  def default_number_of_columns; end

  class << self
    def index_name; end
  end
end

# # Index as a Table
#
# By default, the index page is a table with each of the models content columns and links to
# show, edit and delete the object. There are many ways to customize what gets
# displayed.
#
# ## Defining Columns
#
# To display an attribute or a method on a resource, simply pass a symbol into the
# column method:
#
# ```ruby
# index do
#   selectable_column
#   column :title
# end
# ```
#
# For association columns we make an educated guess on what to display by
# calling the following methods in the following order:
#
# ```ruby
# :display_name, :full_name, :name, :username, :login, :title, :email, :to_s
# ```
#
# This can be customized in `config/initializers/active_admin.rb`.
#
# If the default title does not work for you, pass it as the first argument:
#
# ```ruby
# index do
#   selectable_column
#   column "My Custom Title", :title
# end
# ```
#
# Sometimes that just isn't enough and you need to write some view-specific code.
# For example, say we wanted a "Title" column that links to the posts admin screen.
#
# `column` accepts a block that will be rendered for each of the objects in the collection.
# The block is called once for each resource, which is passed as an argument to the block.
#
# ```ruby
# index do
#   selectable_column
#   column "Title" do |post|
#     link_to post.title, admin_post_path(post)
#   end
# end
# ```
#
# ## Defining Actions
#
# To setup links to View, Edit and Delete a resource, use the `actions` method:
#
# ```ruby
# index do
#   selectable_column
#   column :title
#   actions
# end
# ```
#
# You can also append custom links to the default links:
#
# ```ruby
# index do
#   selectable_column
#   column :title
#   actions do |post|
#     item "Preview", admin_preview_post_path(post), class: "member_link"
#   end
# end
# ```
#
# Or forego the default links entirely:
#
# ```ruby
# index do
#   column :title
#   actions defaults: false do |post|
#     item "View", admin_post_path(post)
#   end
# end
# ```
#
# Or append custom action with custom html via arbre:
#
# ```ruby
# index do
#   column :title
#   actions do |post|
#     a "View", href: admin_post_path(post)
#   end
# end
# ```
#
# In case you prefer to list actions links in a dropdown menu:
#
# ```ruby
# index do
#   selectable_column
#   column :title
#   actions dropdown: true do |post|
#     item "Preview", admin_preview_post_path(post)
#   end
# end
# ```
#
# In addition, you can insert the position of the row in the greater
# collection by using the index_column special command:
#
# ```ruby
# index do
#   selectable_column
#   index_column
#   column :title
# end
# ```
#
# index_column take an optional offset parameter to allow a developer to set
# the starting number for the index (default is 1).
#
# ## Sorting
#
# When a column is generated from an Active Record attribute, the table is
# sortable by default. If you are creating a custom column, you may need to give
# Active Admin a hint for how to sort the table.
#
# You can pass the key specifying the attribute which gets used to sort objects using Active Record.
# By default, this is the column on the resource's table that the attribute corresponds to.
# Otherwise, any attribute that the resource collection responds to can be used.
#
# ```ruby
# index do
#   column :title, sortable: :title do |post|
#     link_to post.title, admin_post_path(post)
#   end
# end
# ```
#
# You can turn off sorting on any column by passing false:
#
# ```ruby
# index do
#   column :title, sortable: false
# end
# ```
#
# It's also possible to sort by PostgreSQL's hstore column key. You should set `sortable`
# option to a `column->'key'` value:
#
# ```ruby
# index do
#   column :keywords, sortable: "meta->'keywords'"
# end
# ```
#
# ## Custom sorting
#
# It is also possible to use database specific expressions and options for sorting by column
#
# ```ruby
# order_by(:title) do |order_clause|
#    if order_clause.order == 'desc'
#      [order_clause.to_sql, 'NULLS LAST'].join(' ')
#    else
#      [order_clause.to_sql, 'NULLS FIRST'].join(' ')
#    end
# end
#
# index do
#   column :title
# end
# ```
#
# ## Associated Sorting
#
# You're normally able to sort columns alphabetically, but by default you
# can't sort by associated objects. Though with a few simple changes, you can.
#
# Assuming you're on the Books index page, and Book has_one Publisher:
#
# ```ruby
# controller do
#   def scoped_collection
#     super.includes :publisher # prevents N+1 queries to your database
#   end
# end
# ```
#
# You can also define associated objects to include outside of the
# `scoped_collection` method:
#
# ```ruby
# includes :publisher
# ```
#
# Then it's simple to sort by any Publisher attribute from within the index table:
#
# ```ruby
# index do
#   column :publisher, sortable: 'publishers.name'
# end
# ```
#
# ## Showing and Hiding Columns
#
# The entire index block is rendered within the context of the view, so you can
# easily do things that show or hide columns based on the current context.
#
# For example, if you were using CanCan:
#
# ```ruby
# index do
#   column :title, sortable: false
#   column :secret_data if can? :manage, Post
# end
# ```
#
# ## Custom row class
#
# In order to add special class to table rows pass the proc object as a `:row_class` option
# of the `index` method.
#
# ```ruby
# index row_class: ->elem { 'active' if elem.active? } do
#   # columns
# end
# ```
class ActiveAdmin::Views::IndexAsTable < ::ActiveAdmin::Component
  def build(page_presenter, collection); end
  def default_table; end
  def table_for(*args, &block); end

  class << self
    def index_name; end
  end
end

# Extend the default ActiveAdmin::Views::TableFor with some
# methods for quickly displaying items on the index page
class ActiveAdmin::Views::IndexAsTable::IndexTableFor < ::ActiveAdmin::Views::TableFor
  # Add links to perform actions.
  #
  # ```ruby
  # # Add default links.
  # actions
  #
  # # Add default links with a custom column title (empty by default).
  # actions name: 'A title!'
  #
  # # Append some actions onto the end of the default actions.
  # actions do |admin_user|
  #   item 'Grant Admin', grant_admin_admin_user_path(admin_user)
  #   item 'Grant User', grant_user_admin_user_path(admin_user)
  # end
  #
  # # Append some actions onto the end of the default actions using arbre dsl.
  # actions do |admin_user|
  #   a 'Grant Admin', href: grant_admin_admin_user_path(admin_user)
  # end
  #
  # # Custom actions without the defaults.
  # actions defaults: false do |admin_user|
  #   item 'Grant Admin', grant_admin_admin_user_path(admin_user)
  # end
  #
  # # Append some actions onto the end of the default actions displayed in a Dropdown Menu
  # actions dropdown: true do |admin_user|
  #   item 'Grant Admin', grant_admin_admin_user_path(admin_user)
  # end
  #
  # # Custom actions without the defaults displayed in a Dropdown Menu.
  # actions defaults: false, dropdown: true, dropdown_name: 'Additional actions' do |admin_user|
  #   item 'Grant Admin', grant_admin_admin_user_path(admin_user)
  # end
  #
  # ```
  def actions(options = T.unsafe(nil), &block); end

  def default_actions; end

  # Display a column for the id
  def id_column; end

  def index_column(start_value = T.unsafe(nil)); end

  # Display a column for checkbox
  def selectable_column; end

  private

  def defaults(resource, options = T.unsafe(nil)); end
end

class ActiveAdmin::Views::IndexAsTable::IndexTableFor::TableActions < ::ActiveAdmin::Component
  def item(*args, **kwargs); end
end

# Renders a collection of index views available to the resource
# as a list with a separator
class ActiveAdmin::Views::IndexList < ::ActiveAdmin::Component
  include ::ActiveAdmin::Helpers::Collection

  # Builds the links for presenting different index views to the user
  #
  # @param index_classes [Array] The class constants that represent index page presenters
  def build(index_classes); end

  def default_class_name; end
  def tag_name; end

  protected

  # Builds the individual link and HTML classes for each index page presenter
  #
  # @param index_class [Class] The class on which to build the link and html classes
  def build_index_list(index_class); end

  def classes_for_index(index_class); end

  # @return [Boolean]
  def current_filter_search_empty?; end

  # @return [Boolean]
  def current_index?(index_class); end
end

# Renders an ActiveAdmin::Menu as a set of unordered list items.
#
# This component takes cares of deciding which items should be
# displayed given the current context and renders them appropriately.
#
# The entire component is rendered within one ul element.
class ActiveAdmin::Views::Menu < ::ActiveAdmin::Component
  # @param menu [ActiveAdmin::Menu] the Menu to render
  # @param options [Hash] the options as passed to the underlying ul element.
  def build(menu, options = T.unsafe(nil)); end

  # Returns the value of attribute menu.
  def menu; end

  def tag_name; end
end

# Arbre component used to render ActiveAdmin::MenuItem
class ActiveAdmin::Views::MenuItem < ::ActiveAdmin::Component
  # Sorts by priority first, then alphabetically by label if needed.
  def <=>(other); end

  def build(item, options = T.unsafe(nil)); end

  # Returns the value of attribute label.
  def label; end

  # Returns the value of attribute priority.
  def priority; end

  def tag_name; end
  def to_s; end

  # Returns the value of attribute url.
  def url; end

  # @return [Boolean]
  def visible?; end

  private

  # URL is not nil, empty, or '#'
  #
  # @return [Boolean]
  def real_url?; end
end

module ActiveAdmin::Views::Pages; end

class ActiveAdmin::Views::Pages::Base < ::Arbre::HTML::Document
  def active_admin_config(*_arg0, **_arg1, &_arg2); end
  def build(*args); end
  def controller(*_arg0, **_arg1, &_arg2); end

  # Arbre::HTML::Title
  def html_title(*args, &block); end

  def main_content; end
  def params(*_arg0, **_arg1, &_arg2); end
  def title; end

  private

  def action_items_for_action; end
  def body_classes; end
  def build_active_admin_head; end
  def build_flash_messages; end
  def build_main_content_wrapper; end
  def build_page; end
  def build_page_content; end
  def build_unsupported_browser; end

  # Returns the sidebar sections to render for the current action
  def sidebar_sections_for_action; end

  # @return [Boolean]
  def skip_sidebar?; end
end

class ActiveAdmin::Views::Pages::Form < ::ActiveAdmin::Views::Pages::Base
  def form_presenter; end
  def main_content; end
  def title; end

  private

  def default_form_config; end
  def default_form_options; end
  def default_form_path; end
  def normalized_action; end
end

class ActiveAdmin::Views::Pages::Index < ::ActiveAdmin::Views::Pages::Base
  include ::ActiveAdmin::Helpers::Collection
  include ::ActiveAdmin::ViewHelpers::DownloadFormatLinksHelper
  extend ::ActiveAdmin::ViewHelpers::DownloadFormatLinksHelper::ClassMethods

  # Retrieves the given page presenter, or uses the default.
  def config; end

  # Renders the index configuration that was set in the
  # controller. Defaults to rendering the ActiveAdmin::Pages::Index::Table
  def main_content; end

  def title; end

  protected

  # @return [Boolean]
  def any_table_tools?; end

  def build_batch_actions_selector; end
  def build_collection; end
  def build_index_list; end
  def build_scopes; end
  def build_table_tools; end

  # Returns the actual class for renderering the main content on the index
  # page. To set this, use the :as option in the page_presenter block.
  def find_index_renderer_class(klass); end

  # @return [Boolean]
  def items_in_collection?; end

  def render_blank_slate; end
  def render_empty_results; end
  def render_index; end
  def wrap_with_batch_action_form(&block); end

  private

  def blank_slate_link; end
  def default_blank_slate_link; end
end

# Acts as a standard Rails Layout for use when logged
# out or when rendering custom actions.
class ActiveAdmin::Views::Pages::Layout < ::ActiveAdmin::Views::Pages::Base
  # Render the content_for(:layout) into the main content area
  def main_content; end

  def title; end
end

class ActiveAdmin::Views::Pages::Page < ::ActiveAdmin::Views::Pages::Base
  def main_content; end

  protected

  def page_presenter; end
  def title; end
end

class ActiveAdmin::Views::Pages::Show < ::ActiveAdmin::Views::Pages::Base
  include ::ActiveAdmin::Views::Pages::Show::DefaultMainContent
  include ::ActiveAdmin::Comments::ShowPageHelper

  def attributes_table(*args, &block); end
  def config; end
  def main_content; end
  def title; end

  protected

  def default_title; end
end

module ActiveAdmin::Views::Pages::Show::DefaultMainContent
  def default_attribute_table_rows; end
  def default_main_content(&block); end
end

# Wraps the content with pagination and available formats.
#
# *Example:*
#
#   paginated_collection collection, entry_name: "Post" do
#     div do
#       h2 "Inside the
#     end
#   end
#
# This will create a div with a sentence describing the number of
# posts in one of the following formats:
#
# * "No Posts found"
# * "Displaying all 10 Posts"
# * "Displaying Posts 1 - 30 of 31 in total"
#
# It will also generate pagination links.
class ActiveAdmin::Views::PaginatedCollection < ::ActiveAdmin::Component
  include ::ActiveAdmin::Helpers::Collection
  include ::ActiveAdmin::ViewHelpers::DownloadFormatLinksHelper
  extend ::ActiveAdmin::ViewHelpers::DownloadFormatLinksHelper::ClassMethods

  # Override add_child to insert all children into the @contents div
  def add_child(*args, &block); end

  # Builds a new paginated collection component
  #
  # collection => A paginated collection from kaminari
  # options    => These options will be passed to `page_entries_info`
  #   entry_name     => The name to display for this resource collection
  #   params         => Extra parameters for pagination (e.g. { anchor: 'details' })
  #   param_name     => Parameter name for page number in the links (:page by default)
  #   download_links => Download links override (false or [:csv, :pdf])
  def build(collection, options = T.unsafe(nil)); end

  # Returns the value of attribute collection.
  def collection; end

  protected

  def build_pagination; end
  def build_pagination_with_formats(options); end
  def build_per_page_select; end

  # modified from will_paginate
  def page_entries_info(options = T.unsafe(nil)); end
end

class ActiveAdmin::Views::Panel < ::ActiveAdmin::Component
  def add_child(child); end
  def build(title, attributes = T.unsafe(nil)); end

  # Override children? to only report children when the panel's
  # contents have been added to. This ensures that the panel
  # correcly appends string values, etc.
  #
  # @return [Boolean]
  def children?; end

  def header_action(*args); end
end

# Renders a collection of ActiveAdmin::Scope objects as a
# simple list with a seperator
class ActiveAdmin::Views::Scopes < ::ActiveAdmin::Component
  include ::ActiveAdmin::ScopeChain
  include ::ActiveAdmin::Helpers::Collection

  def build(scopes, options = T.unsafe(nil)); end
  def default_class_name; end
  def tag_name; end

  protected

  def build_scope(scope, options); end
  def classes_for_scope(scope); end

  # @return [Boolean]
  def current_scope?(scope); end

  # Return the count for the scope passed in.
  def get_scope_count(scope); end

  def group_class(group); end
end

class ActiveAdmin::Views::SemanticActionsProxy < ::ActiveAdmin::Views::FormtasticProxy
  def build(form_builder, *args, &block); end
end

class ActiveAdmin::Views::SemanticInputsProxy < ::ActiveAdmin::Views::FormtasticProxy
  def build(form_builder, *args, &block); end
end

class ActiveAdmin::Views::Sidebar < ::ActiveAdmin::Component
  def build(sections, attributes = T.unsafe(nil)); end
end

class ActiveAdmin::Views::SidebarSection < ::ActiveAdmin::Views::Panel
  # Renders attributes_table_for current resource
  def attributes_table(*args, &block); end

  # Takes a ActiveAdmin::SidebarSection instance
  def build(section); end

  protected

  def build_sidebar_content; end
end

class ActiveAdmin::Views::SiteTitle < ::ActiveAdmin::Component
  def build(namespace); end
  def site_title_image; end

  # @return [Boolean]
  def site_title_link?; end

  def tag_name; end

  private

  def site_title_content; end
  def site_title_with_link; end
  def title_image; end
  def title_text; end
end

# Build a StatusTag
class ActiveAdmin::Views::StatusTag < ::ActiveAdmin::Component
  # @example
  #   status_tag('In Progress')
  #   # => <span class='status_tag in_progress'>In Progress</span>
  # @example
  #   status_tag('active', class: 'important', id: 'status_123', label: 'on')
  #   # => <span class='status_tag active important' id='status_123'>on</span>
  # @overload status_tag
  def build(status, options = T.unsafe(nil)); end

  def default_class_name; end
  def tag_name; end

  protected

  def convert_to_boolean_status(status); end
  def status_to_class(status); end
end

class ActiveAdmin::Views::TabbedNavigation < ::ActiveAdmin::Views::Menu
  def build(menu, options = T.unsafe(nil)); end
end

class ActiveAdmin::Views::TableFor < ::Arbre::HTML::Table
  def build(obj, *attrs); end
  def column(*args, &block); end
  def columns(*attrs); end

  # @return [Boolean]
  def sortable?; end

  def tag_name; end

  protected

  def build_table; end
  def build_table_body; end
  def build_table_cell(col, resource); end
  def build_table_head; end
  def build_table_header(col); end

  # Returns an array for the current sort order
  #   current_sort[0] #=> sort_key
  #   current_sort[1] #=> asc | desc
  def current_sort; end

  def default_options; end

  # Returns the order to use for a given sort key
  #
  # Default is to use 'desc'. If the current sort key is
  # 'desc' it will return 'asc'
  def order_for_sort_key(sort_key); end
end

class ActiveAdmin::Views::TableFor::Column
  # @return [Column] a new instance of Column
  def initialize(*args, &block); end

  # Returns the value of attribute data.
  def data; end

  # Sets the attribute data
  #
  # @param value the value to set the attribute data to.
  def data=(_arg0); end

  # Returns the value of attribute html_class.
  def html_class; end

  # Sets the attribute html_class
  #
  # @param value the value to set the attribute html_class to.
  def html_class=(_arg0); end

  def pretty_title; end

  # Returns the key to be used for sorting this column
  #
  # Defaults to the column's method if its a symbol
  #   column :username
  #   # => Sort key will be set to 'username'
  #
  # You can set the sort key by passing a string or symbol
  # to the sortable option:
  #   column :username, sortable: 'other_column_to_sort_on'
  def sort_key; end

  # @return [Boolean]
  def sortable?; end

  # Returns the value of attribute title.
  def title; end

  # Sets the attribute title
  #
  # @param value the value to set the attribute title to.
  def title=(_arg0); end

  private

  def sort_column_name; end
end

class ActiveAdmin::Views::Tabs < ::ActiveAdmin::Component
  def build(&block); end
  def build_content_item(title, options, &block); end
  def build_menu_item(title, options, &block); end
  def tab(title, options = T.unsafe(nil), &block); end

  private

  def fragmentize(string); end
end

class ActiveAdmin::Views::TitleBar < ::ActiveAdmin::Component
  def build(title, action_items); end

  private

  def build_action_items; end
  def build_breadcrumb(separator = T.unsafe(nil)); end
  def build_title_tag; end
  def build_titlebar_left; end
  def build_titlebar_right; end
end

class ActiveAdmin::Views::UnsupportedBrowser < ::ActiveAdmin::Component
  def build; end
end

# Provides an intuitive way to build has_many associated records in the same form.
module Formtastic
  extend ::ActiveSupport::Autoload
end

Formtastic::Deprecation = ActiveSupport::Deprecation

module Formtastic::Inputs
  extend ::ActiveSupport::Autoload
end

module Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::Inputs::Base::Wrapping
  extend ::ActiveSupport::Autoload

  def initialize(builder, template, object, object_name, method, options); end

  def builder; end
  def builder=(_arg0); end
  def input_wrapping(&block); end
  def method; end
  def method=(_arg0); end
  def object; end
  def object=(_arg0); end
  def object_name; end
  def object_name=(_arg0); end
  def options; end
  def options=(_arg0); end
  def removed_option!(old_option_name); end
  def template; end
  def template=(_arg0); end
  def warn_and_correct_option!(old_option_name, new_option_name); end
  def warn_deprecated_option!(old_option_name, instructions); end
end

# Utility methods for internal use.
#
# @private
module MethodOrProcHelper
  extend ::MethodOrProcHelper

  # This method will either call the symbol on self or instance_exec the Proc
  # within self. Any args will be passed along to the method dispatch.
  #
  # Calling with a Symbol:
  #
  #     call_method_or_exec_proc(:to_s) #=> will call #to_s
  #
  # Calling with a Proc
  #
  #     my_proc = Proc.new{ to_s }
  #     call_method_or_exec_proc(my_proc) #=> will instance_exec in self
  def call_method_or_exec_proc(symbol_or_proc, *args); end

  # Many times throughout the views we want to either call a method on an object
  # or instance_exec a proc passing in the object as the first parameter. This
  # method wraps that pattern.
  #
  # Calling with a String or Symbol:
  #
  #     call_method_or_proc_on(@my_obj, :size) same as @my_obj.size
  #
  # Calling with a Proc:
  #
  #     proc = Proc.new{|s| s.size }
  #     call_method_or_proc_on(@my_obj, proc)
  #
  # By default, the Proc will be instance_exec'd within self. If you would rather
  # not instance exec, but just call the Proc, then pass along `exec: false` in
  # the options hash.
  #
  #     proc = Proc.new{|s| s.size }
  #     call_method_or_proc_on(@my_obj, proc, exec: false)
  #
  # You can pass along any necessary arguments to the method / Proc as arguments. For
  # example:
  #
  #     call_method_or_proc_on(@my_obj, :find, 1) #=> @my_obj.find(1)
  def call_method_or_proc_on(receiver, *args); end

  # This method is different from the others in that it calls `instance_exec` on the receiver,
  # passing it the proc. This evaluates the proc in the context of the receiver, thus changing
  # what `self` means inside the proc.
  def render_in_context(context, obj, *args); end

  # Many configuration options (Ex: site_title, title_image) could either be
  # static (String), methods (Symbol) or procs (Proc). This helper takes care of
  # returning the content when String or call call_method_or_proc_on when Symbol or Proc.
  def render_or_call_method_or_proc_on(obj, string_symbol_or_proc, options = T.unsafe(nil)); end
end
